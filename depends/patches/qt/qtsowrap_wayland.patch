From 8d6f4cf07aaa74b6e696bb8c8f3a49fa1267f426 Mon Sep 17 00:00:00 2001
From: laanwj <126646+laanwj@users.noreply.github.com>
Date: Wed, 24 Apr 2024 11:49:45 +0200
Subject: [PATCH] qtsowrap: Replace UNIX wayland libraries linking with
 qtsowrap

---
 src/client/client.pro                         |   59 +-
 src/client/configure.json                     |   17 +-
 src/client/qwayland-hardware-integration.cpp  |  113 +
 src/client/qwayland-hardware-integration.h    |   68 +
 src/client/qwayland-qt-key-unstable-v1.cpp    |  118 +
 src/client/qwayland-qt-key-unstable-v1.h      |   73 +
 src/client/qwayland-qt-windowmanager.cpp      |  119 +
 src/client/qwayland-qt-windowmanager.h        |   69 +
 .../qwayland-server-buffer-extension.cpp      |   76 +
 src/client/qwayland-server-buffer-extension.h |   56 +
 src/client/qwayland-surface-extension.cpp     |  218 +
 src/client/qwayland-surface-extension.h       |  119 +
 src/client/qwayland-tablet-unstable-v2.cpp    | 1314 ++++
 src/client/qwayland-tablet-unstable-v2.h      |  564 ++
 .../qwayland-text-input-unstable-v2.cpp       |  473 ++
 src/client/qwayland-text-input-unstable-v2.h  |  246 +
 src/client/qwayland-touch-extension.cpp       |  145 +
 src/client/qwayland-touch-extension.h         |   87 +
 src/client/qwayland-wayland.cpp               | 2493 ++++++++
 src/client/qwayland-wayland.h                 | 1178 ++++
 ...yland-wp-primary-selection-unstable-v1.cpp |  380 ++
 ...wayland-wp-primary-selection-unstable-v1.h |  176 +
 .../qwayland-xdg-output-unstable-v1.cpp       |  225 +
 src/client/qwayland-xdg-output-unstable-v1.h  |  113 +
 src/client/qwaylandcursor.cpp                 |    2 +-
 src/client/qwaylanddisplay.cpp                |    2 +-
 src/client/qwaylandinputcontext_p.h           |    2 +-
 src/client/qwaylandinputdevice.cpp            |    2 +-
 ...and-hardware-integration-client-protocol.h |  149 +
 .../wayland-hardware-integration-protocol.c   |   60 +
 ...yland-qt-key-unstable-v1-client-protocol.h |  173 +
 .../wayland-qt-key-unstable-v1-protocol.c     |   70 +
 ...wayland-qt-windowmanager-client-protocol.h |  162 +
 .../wayland-qt-windowmanager-protocol.c       |   65 +
 ...-server-buffer-extension-client-protocol.h |  137 +
 ...wayland-server-buffer-extension-protocol.c |   58 +
 ...ayland-surface-extension-client-protocol.h |  311 +
 .../wayland-surface-extension-protocol.c      |   84 +
 ...yland-tablet-unstable-v2-client-protocol.h | 2263 +++++++
 .../wayland-tablet-unstable-v2-protocol.c     |  223 +
 ...d-text-input-unstable-v2-client-protocol.h |  974 +++
 .../wayland-text-input-unstable-v2-protocol.c |  100 +
 .../wayland-touch-extension-client-protocol.h |  178 +
 src/client/wayland-touch-extension-protocol.c |   77 +
 src/client/wayland-wayland-client-protocol.h  | 5676 +++++++++++++++++
 src/client/wayland-wayland-protocol.c         |  507 ++
 ...ry-selection-unstable-v1-client-protocol.h |  590 ++
 ...p-primary-selection-unstable-v1-protocol.c |  105 +
 ...d-xdg-output-unstable-v1-client-protocol.h |  415 ++
 .../wayland-xdg-output-unstable-v1-protocol.c |   68 +
 .../compositor_api/qwaylandkeyboard_p.h       |    2 +-
 .../brcm-egl/qwaylandbrcmeglintegration.h     |    2 +-
 .../qwaylandeglclientbufferintegration.cpp    |    2 +-
 .../client/wayland-egl/qwaylandeglinclude.h   |    4 +-
 .../client/wayland-egl/qwaylandglcontext.cpp  |   13 +-
 .../client/wayland-egl/qwaylandglcontext.h    |    4 +
 ...landxcompositeeglclientbufferintegration.h |    2 +-
 .../qwaylandxcompositeglxintegration.h        |    2 +-
 .../platforms/qwayland-generic/main.cpp       |   17 +
 .../qwaylandfullscreenshellv1integration.h    |    2 +-
 ...-xdg-shell-unstable-v5-client-protocol_p.h |    2 +-
 .../qwayland-xdg-decoration-unstable-v1.cpp   |  176 +
 .../qwayland-xdg-decoration-unstable-v1.h     |   97 +
 .../xdg-shell/qwayland-xdg-shell.cpp          |  630 ++
 .../xdg-shell/qwayland-xdg-shell.h            |  308 +
 ...g-decoration-unstable-v1-client-protocol.h |  382 ++
 ...land-xdg-decoration-unstable-v1-protocol.c |   65 +
 .../wayland-xdg-shell-client-protocol.h       | 1857 ++++++
 .../xdg-shell/wayland-xdg-shell-protocol.c    |  164 +
 .../shellintegration/xdg-shell/xdg-shell.pro  |   19 +-
 70 files changed, 24661 insertions(+), 41 deletions(-)
 create mode 100644 src/client/qwayland-hardware-integration.cpp
 create mode 100644 src/client/qwayland-hardware-integration.h
 create mode 100644 src/client/qwayland-qt-key-unstable-v1.cpp
 create mode 100644 src/client/qwayland-qt-key-unstable-v1.h
 create mode 100644 src/client/qwayland-qt-windowmanager.cpp
 create mode 100644 src/client/qwayland-qt-windowmanager.h
 create mode 100644 src/client/qwayland-server-buffer-extension.cpp
 create mode 100644 src/client/qwayland-server-buffer-extension.h
 create mode 100644 src/client/qwayland-surface-extension.cpp
 create mode 100644 src/client/qwayland-surface-extension.h
 create mode 100644 src/client/qwayland-tablet-unstable-v2.cpp
 create mode 100644 src/client/qwayland-tablet-unstable-v2.h
 create mode 100644 src/client/qwayland-text-input-unstable-v2.cpp
 create mode 100644 src/client/qwayland-text-input-unstable-v2.h
 create mode 100644 src/client/qwayland-touch-extension.cpp
 create mode 100644 src/client/qwayland-touch-extension.h
 create mode 100644 src/client/qwayland-wayland.cpp
 create mode 100644 src/client/qwayland-wayland.h
 create mode 100644 src/client/qwayland-wp-primary-selection-unstable-v1.cpp
 create mode 100644 src/client/qwayland-wp-primary-selection-unstable-v1.h
 create mode 100644 src/client/qwayland-xdg-output-unstable-v1.cpp
 create mode 100644 src/client/qwayland-xdg-output-unstable-v1.h
 create mode 100644 src/client/wayland-hardware-integration-client-protocol.h
 create mode 100644 src/client/wayland-hardware-integration-protocol.c
 create mode 100644 src/client/wayland-qt-key-unstable-v1-client-protocol.h
 create mode 100644 src/client/wayland-qt-key-unstable-v1-protocol.c
 create mode 100644 src/client/wayland-qt-windowmanager-client-protocol.h
 create mode 100644 src/client/wayland-qt-windowmanager-protocol.c
 create mode 100644 src/client/wayland-server-buffer-extension-client-protocol.h
 create mode 100644 src/client/wayland-server-buffer-extension-protocol.c
 create mode 100644 src/client/wayland-surface-extension-client-protocol.h
 create mode 100644 src/client/wayland-surface-extension-protocol.c
 create mode 100644 src/client/wayland-tablet-unstable-v2-client-protocol.h
 create mode 100644 src/client/wayland-tablet-unstable-v2-protocol.c
 create mode 100644 src/client/wayland-text-input-unstable-v2-client-protocol.h
 create mode 100644 src/client/wayland-text-input-unstable-v2-protocol.c
 create mode 100644 src/client/wayland-touch-extension-client-protocol.h
 create mode 100644 src/client/wayland-touch-extension-protocol.c
 create mode 100644 src/client/wayland-wayland-client-protocol.h
 create mode 100644 src/client/wayland-wayland-protocol.c
 create mode 100644 src/client/wayland-wp-primary-selection-unstable-v1-client-protocol.h
 create mode 100644 src/client/wayland-wp-primary-selection-unstable-v1-protocol.c
 create mode 100644 src/client/wayland-xdg-output-unstable-v1-client-protocol.h
 create mode 100644 src/client/wayland-xdg-output-unstable-v1-protocol.c
 create mode 100644 src/plugins/shellintegration/xdg-shell/qwayland-xdg-decoration-unstable-v1.cpp
 create mode 100644 src/plugins/shellintegration/xdg-shell/qwayland-xdg-decoration-unstable-v1.h
 create mode 100644 src/plugins/shellintegration/xdg-shell/qwayland-xdg-shell.cpp
 create mode 100644 src/plugins/shellintegration/xdg-shell/qwayland-xdg-shell.h
 create mode 100644 src/plugins/shellintegration/xdg-shell/wayland-xdg-decoration-unstable-v1-client-protocol.h
 create mode 100644 src/plugins/shellintegration/xdg-shell/wayland-xdg-decoration-unstable-v1-protocol.c
 create mode 100644 src/plugins/shellintegration/xdg-shell/wayland-xdg-shell-client-protocol.h
 create mode 100644 src/plugins/shellintegration/xdg-shell/wayland-xdg-shell-protocol.c

diff --git a/src/client/client.pro b/src/client/client.pro
index e7b1dad5ca943bf3469e7316d9c7f31b26569112..d31185d8e496d57e6025a08d8829eeb97ac32dd6 100644
--- a/qtwayland/src/client/client.pro
+++ a/qtwayland/src/client/client.pro
@@ -17,7 +17,7 @@ QMAKE_CXXFLAGS_WARN_ON -= -Wcast-qual
 use_gold_linker: CONFIG += no_linker_version_script
 
 CONFIG -= precompile_header
-CONFIG += link_pkgconfig wayland-scanner
+CONFIG += link_pkgconfig
 
 qtConfig(xkbcommon) {
     QT_FOR_PRIVATE += xkbcommon_support-private
@@ -30,16 +30,53 @@ QMAKE_USE += wayland-client
 
 INCLUDEPATH += $$PWD/../shared
 
-WAYLANDCLIENTSOURCES += \
-            ../extensions/surface-extension.xml \
-            ../extensions/touch-extension.xml \
-            ../extensions/qt-key-unstable-v1.xml \
-            ../extensions/qt-windowmanager.xml \
-            ../3rdparty/protocol/wp-primary-selection-unstable-v1.xml \
-            ../3rdparty/protocol/tablet-unstable-v2.xml \
-            ../3rdparty/protocol/text-input-unstable-v2.xml \
-            ../3rdparty/protocol/xdg-output-unstable-v1.xml \
-            ../3rdparty/protocol/wayland.xml
+SOURCES += wayland-hardware-integration-protocol.c \
+           wayland-qt-key-unstable-v1-protocol.c \
+           wayland-qt-windowmanager-protocol.c \
+           wayland-server-buffer-extension-protocol.c \
+           wayland-surface-extension-protocol.c \
+           wayland-tablet-unstable-v2-protocol.c \
+           wayland-text-input-unstable-v2-protocol.c \
+           wayland-touch-extension-protocol.c \
+           wayland-wayland-protocol.c \
+           wayland-wp-primary-selection-unstable-v1-protocol.c \
+           wayland-xdg-output-unstable-v1-protocol.c
+
+HEADERS += wayland-hardware-integration-client-protocol.h \
+           wayland-qt-key-unstable-v1-client-protocol.h \
+           wayland-qt-windowmanager-client-protocol.h \
+           wayland-server-buffer-extension-client-protocol.h \
+           wayland-surface-extension-client-protocol.h \
+           wayland-tablet-unstable-v2-client-protocol.h \
+           wayland-text-input-unstable-v2-client-protocol.h \
+           wayland-touch-extension-client-protocol.h \
+           wayland-wayland-client-protocol.h \
+           wayland-wp-primary-selection-unstable-v1-client-protocol.h \
+           wayland-xdg-output-unstable-v1-client-protocol.h
+
+SOURCES += qwayland-hardware-integration.cpp \
+           qwayland-qt-key-unstable-v1.cpp \
+           qwayland-qt-windowmanager.cpp \
+           qwayland-server-buffer-extension.cpp \
+           qwayland-surface-extension.cpp \
+           qwayland-tablet-unstable-v2.cpp \
+           qwayland-text-input-unstable-v2.cpp \
+           qwayland-touch-extension.cpp \
+           qwayland-wayland.cpp \
+           qwayland-wp-primary-selection-unstable-v1.cpp \
+           qwayland-xdg-output-unstable-v1.cpp
+
+HEADERS += qwayland-hardware-integration.h \
+           qwayland-qt-key-unstable-v1.h \
+           qwayland-qt-windowmanager.h \
+           qwayland-server-buffer-extension.h \
+           qwayland-surface-extension.h \
+           qwayland-tablet-unstable-v2.h \
+           qwayland-text-input-unstable-v2.h \
+           qwayland-touch-extension.h \
+           qwayland-wayland.h \
+           qwayland-wp-primary-selection-unstable-v1.h \
+           qwayland-xdg-output-unstable-v1.h
 
 SOURCES +=  qwaylandintegration.cpp \
             qwaylandnativeinterface.cpp \
diff --git a/src/client/configure.json b/src/client/configure.json
index 2f4245804632127b16b7f5324e5fe8856f0819b5..d92b90fd3b688197d9c38d71dada8aa003fe840a 100644
--- a/qtwayland/src/client/configure.json
+++ a/qtwayland/src/client/configure.json
@@ -9,7 +9,7 @@
     "libraries": {
         "wayland-client": {
             "label": "Wayland client library",
-            "headers": "wayland-version.h",
+            "headers": "wayland_client-so_wrap.h",
             "test": {
                 "main": [
                     "#if WAYLAND_VERSION_MAJOR < 1",
@@ -29,31 +29,30 @@
             },
             "sources": [
                 { "type": "pkgConfig", "args": "wayland-client" },
-                "-lwayland-client"
+                "-lqtsowrap -ldl"
             ]
         },
         "wayland-cursor": {
             "label": "Wayland cursor library",
-            "headers": "wayland-cursor.h",
+            "headers": "wayland_cursor-so_wrap.h",
             "test": {
                 "main": "struct wl_cursor_image *image = 0;"
             },
             "use": "wayland-client",
             "sources": [
                 { "type": "pkgConfig", "args": "wayland-cursor" },
-                "-lwayland-cursor"
+                "-lqtsowrap -ldl"
             ]
         },
         "wayland-egl": {
             "label": "Wayland EGL library",
-            "headers": "wayland-egl.h",
+            "headers": "wayland_egl-so_wrap.h",
             "test": {
                 "main": "struct wl_egl_window *window = wl_egl_window_create(0, 100, 100);"
             },
             "sources": [
                 { "type": "pkgConfig", "args": "wayland-egl" },
-                "-lwayland-egl",
-                "-lEGL"
+                "-lqtsowrap -ldl"
             ]
         },
         "xcomposite": {
@@ -177,7 +176,7 @@
                 "include": [
                     "EGL/egl.h",
                     "EGL/eglext.h",
-                    "wayland-client.h"
+                    "wayland_client-so_wrap.h"
                 ],
                 "main": [
                     "eglGetPlatformDisplay(EGL_PLATFORM_WAYLAND_EXT, (struct wl_display *)(nullptr), nullptr);"
@@ -190,7 +189,7 @@
     "features": {
         "wayland-client": {
             "label": "Qt Wayland Client",
-            "condition": "!config.win32 && libs.wayland-client && libs.wayland-cursor && tests.wayland-scanner",
+            "condition": "!config.win32 && libs.wayland-client && libs.wayland-cursor",
             "output": [ "privateFeature" ]
         },
         "wayland-datadevice": {
diff --git a/src/client/qwayland-hardware-integration.cpp b/src/client/qwayland-hardware-integration.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..adc85776f684a6d6b06c130c7377f377c884d50a
--- /dev/null
+++ a/qtwayland/src/client/qwayland-hardware-integration.cpp
@@ -0,0 +1,113 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/hardware-integration.xml
+
+#include <QtWaylandClient/private/qwayland-hardware-integration.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    qt_hardware_integration::qt_hardware_integration(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    qt_hardware_integration::qt_hardware_integration(struct ::qt_hardware_integration *obj)
+        : m_qt_hardware_integration(obj)
+    {
+        init_listener();
+    }
+
+    qt_hardware_integration::qt_hardware_integration()
+        : m_qt_hardware_integration(nullptr)
+    {
+    }
+
+    qt_hardware_integration::~qt_hardware_integration()
+    {
+    }
+
+    void qt_hardware_integration::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_qt_hardware_integration = static_cast<struct ::qt_hardware_integration *>(wlRegistryBind(registry, id, &qt_hardware_integration_interface, version));
+        init_listener();
+    }
+
+    void qt_hardware_integration::init(struct ::qt_hardware_integration *obj)
+    {
+        m_qt_hardware_integration = obj;
+        init_listener();
+    }
+
+    qt_hardware_integration *qt_hardware_integration::fromObject(struct ::qt_hardware_integration *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_qt_hardware_integration_listener)
+            return nullptr;
+        return static_cast<qt_hardware_integration *>(qt_hardware_integration_get_user_data(object));
+    }
+
+    bool qt_hardware_integration::isInitialized() const
+    {
+        return m_qt_hardware_integration != nullptr;
+    }
+
+    const struct wl_interface *qt_hardware_integration::interface()
+    {
+        return &::qt_hardware_integration_interface;
+    }
+
+    void qt_hardware_integration::hardware_integration_client_backend(const QString &)
+    {
+    }
+
+    void qt_hardware_integration::handle_client_backend(
+        void *data,
+        struct ::qt_hardware_integration *object,
+        const char *name)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_hardware_integration *>(data)->hardware_integration_client_backend(
+            QString::fromUtf8(name));
+    }
+
+    void qt_hardware_integration::hardware_integration_server_backend(const QString &)
+    {
+    }
+
+    void qt_hardware_integration::handle_server_backend(
+        void *data,
+        struct ::qt_hardware_integration *object,
+        const char *name)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_hardware_integration *>(data)->hardware_integration_server_backend(
+            QString::fromUtf8(name));
+    }
+
+    const struct qt_hardware_integration_listener qt_hardware_integration::m_qt_hardware_integration_listener = {
+        qt_hardware_integration::handle_client_backend,
+        qt_hardware_integration::handle_server_backend,
+    };
+
+    void qt_hardware_integration::init_listener()
+    {
+        qt_hardware_integration_add_listener(m_qt_hardware_integration, &m_qt_hardware_integration_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-hardware-integration.h b/src/client/qwayland-hardware-integration.h
new file mode 100644
index 0000000000000000000000000000000000000000..f2d24ee6cc528e18c3ba0a4998d92f69cf61cd30
--- /dev/null
+++ a/qtwayland/src/client/qwayland-hardware-integration.h
@@ -0,0 +1,68 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/hardware-integration.xml
+
+#ifndef QT_WAYLAND_HARDWARE_INTEGRATION
+#define QT_WAYLAND_HARDWARE_INTEGRATION
+
+#include <QtWaylandClient/private/wayland-hardware-integration-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_HARDWARE_INTEGRATION_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_HARDWARE_INTEGRATION_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_HARDWARE_INTEGRATION_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_HARDWARE_INTEGRATION_EXPORT qt_hardware_integration
+    {
+    public:
+        qt_hardware_integration(struct ::wl_registry *registry, int id, int version);
+        qt_hardware_integration(struct ::qt_hardware_integration *object);
+        qt_hardware_integration();
+
+        virtual ~qt_hardware_integration();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::qt_hardware_integration *object);
+
+        struct ::qt_hardware_integration *object() { return m_qt_hardware_integration; }
+        const struct ::qt_hardware_integration *object() const { return m_qt_hardware_integration; }
+        static qt_hardware_integration *fromObject(struct ::qt_hardware_integration *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+    protected:
+        virtual void hardware_integration_client_backend(const QString &name);
+        virtual void hardware_integration_server_backend(const QString &name);
+
+    private:
+        void init_listener();
+        static const struct qt_hardware_integration_listener m_qt_hardware_integration_listener;
+        static void handle_client_backend(
+            void *data,
+            struct ::qt_hardware_integration *object,
+            const char *name);
+        static void handle_server_backend(
+            void *data,
+            struct ::qt_hardware_integration *object,
+            const char *name);
+        struct ::qt_hardware_integration *m_qt_hardware_integration;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-qt-key-unstable-v1.cpp b/src/client/qwayland-qt-key-unstable-v1.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..53576716d8235e01c117027154c32001801d5683
--- /dev/null
+++ a/qtwayland/src/client/qwayland-qt-key-unstable-v1.cpp
@@ -0,0 +1,118 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/qt-key-unstable-v1.xml
+
+#include <QtWaylandClient/private/qwayland-qt-key-unstable-v1.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    zqt_key_v1::zqt_key_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zqt_key_v1::zqt_key_v1(struct ::zqt_key_v1 *obj)
+        : m_zqt_key_v1(obj)
+    {
+        init_listener();
+    }
+
+    zqt_key_v1::zqt_key_v1()
+        : m_zqt_key_v1(nullptr)
+    {
+    }
+
+    zqt_key_v1::~zqt_key_v1()
+    {
+    }
+
+    void zqt_key_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zqt_key_v1 = static_cast<struct ::zqt_key_v1 *>(wlRegistryBind(registry, id, &zqt_key_v1_interface, version));
+        init_listener();
+    }
+
+    void zqt_key_v1::init(struct ::zqt_key_v1 *obj)
+    {
+        m_zqt_key_v1 = obj;
+        init_listener();
+    }
+
+    zqt_key_v1 *zqt_key_v1::fromObject(struct ::zqt_key_v1 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zqt_key_v1_listener)
+            return nullptr;
+        return static_cast<zqt_key_v1 *>(zqt_key_v1_get_user_data(object));
+    }
+
+    bool zqt_key_v1::isInitialized() const
+    {
+        return m_zqt_key_v1 != nullptr;
+    }
+
+    const struct wl_interface *zqt_key_v1::interface()
+    {
+        return &::zqt_key_v1_interface;
+    }
+
+    void zqt_key_v1::zqt_key_v1_key(struct ::wl_surface *, uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , const QString &, uint32_t , uint32_t )
+    {
+    }
+
+    void zqt_key_v1::handle_key(
+        void *data,
+        struct ::zqt_key_v1 *object,
+        struct ::wl_surface *surface,
+        uint32_t time,
+        uint32_t type,
+        uint32_t key,
+        uint32_t modifiers,
+        uint32_t nativeScanCode,
+        uint32_t nativeVirtualKey,
+        uint32_t nativeModifiers,
+        const char *text,
+        uint32_t autorepeat,
+        uint32_t count)
+    {
+        Q_UNUSED(object);
+        static_cast<zqt_key_v1 *>(data)->zqt_key_v1_key(
+            surface,
+            time,
+            type,
+            key,
+            modifiers,
+            nativeScanCode,
+            nativeVirtualKey,
+            nativeModifiers,
+            QString::fromUtf8(text),
+            autorepeat,
+            count);
+    }
+
+    const struct zqt_key_v1_listener zqt_key_v1::m_zqt_key_v1_listener = {
+        zqt_key_v1::handle_key,
+    };
+
+    void zqt_key_v1::init_listener()
+    {
+        zqt_key_v1_add_listener(m_zqt_key_v1, &m_zqt_key_v1_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-qt-key-unstable-v1.h b/src/client/qwayland-qt-key-unstable-v1.h
new file mode 100644
index 0000000000000000000000000000000000000000..29d744fa57eb38ee0fc6ac802bacdb13101e0d27
--- /dev/null
+++ a/qtwayland/src/client/qwayland-qt-key-unstable-v1.h
@@ -0,0 +1,73 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/qt-key-unstable-v1.xml
+
+#ifndef QT_WAYLAND_QT_KEY_UNSTABLE_V1
+#define QT_WAYLAND_QT_KEY_UNSTABLE_V1
+
+#include <QtWaylandClient/private/wayland-qt-key-unstable-v1-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_QT_KEY_UNSTABLE_V1_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_QT_KEY_UNSTABLE_V1_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_QT_KEY_UNSTABLE_V1_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_QT_KEY_UNSTABLE_V1_EXPORT zqt_key_v1
+    {
+    public:
+        zqt_key_v1(struct ::wl_registry *registry, int id, int version);
+        zqt_key_v1(struct ::zqt_key_v1 *object);
+        zqt_key_v1();
+
+        virtual ~zqt_key_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zqt_key_v1 *object);
+
+        struct ::zqt_key_v1 *object() { return m_zqt_key_v1; }
+        const struct ::zqt_key_v1 *object() const { return m_zqt_key_v1; }
+        static zqt_key_v1 *fromObject(struct ::zqt_key_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+    protected:
+        virtual void zqt_key_v1_key(struct ::wl_surface *surface, uint32_t time, uint32_t type, uint32_t key, uint32_t modifiers, uint32_t nativeScanCode, uint32_t nativeVirtualKey, uint32_t nativeModifiers, const QString &text, uint32_t autorepeat, uint32_t count);
+
+    private:
+        void init_listener();
+        static const struct zqt_key_v1_listener m_zqt_key_v1_listener;
+        static void handle_key(
+            void *data,
+            struct ::zqt_key_v1 *object,
+            struct ::wl_surface *surface,
+            uint32_t time,
+            uint32_t type,
+            uint32_t key,
+            uint32_t modifiers,
+            uint32_t nativeScanCode,
+            uint32_t nativeVirtualKey,
+            uint32_t nativeModifiers,
+            const char *text,
+            uint32_t autorepeat,
+            uint32_t count);
+        struct ::zqt_key_v1 *m_zqt_key_v1;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-qt-windowmanager.cpp b/src/client/qwayland-qt-windowmanager.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..87a7c0e31c1d59c5e3b94343108267af3f6f1d6b
--- /dev/null
+++ a/qtwayland/src/client/qwayland-qt-windowmanager.cpp
@@ -0,0 +1,119 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/qt-windowmanager.xml
+
+#include <QtWaylandClient/private/qwayland-qt-windowmanager.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    qt_windowmanager::qt_windowmanager(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    qt_windowmanager::qt_windowmanager(struct ::qt_windowmanager *obj)
+        : m_qt_windowmanager(obj)
+    {
+        init_listener();
+    }
+
+    qt_windowmanager::qt_windowmanager()
+        : m_qt_windowmanager(nullptr)
+    {
+    }
+
+    qt_windowmanager::~qt_windowmanager()
+    {
+    }
+
+    void qt_windowmanager::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_qt_windowmanager = static_cast<struct ::qt_windowmanager *>(wlRegistryBind(registry, id, &qt_windowmanager_interface, version));
+        init_listener();
+    }
+
+    void qt_windowmanager::init(struct ::qt_windowmanager *obj)
+    {
+        m_qt_windowmanager = obj;
+        init_listener();
+    }
+
+    qt_windowmanager *qt_windowmanager::fromObject(struct ::qt_windowmanager *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_qt_windowmanager_listener)
+            return nullptr;
+        return static_cast<qt_windowmanager *>(qt_windowmanager_get_user_data(object));
+    }
+
+    bool qt_windowmanager::isInitialized() const
+    {
+        return m_qt_windowmanager != nullptr;
+    }
+
+    const struct wl_interface *qt_windowmanager::interface()
+    {
+        return &::qt_windowmanager_interface;
+    }
+
+    void qt_windowmanager::open_url(uint32_t remaining, const QString &url)
+    {
+        qt_windowmanager_open_url(
+            m_qt_windowmanager,
+            remaining,
+            url.toUtf8().constData());
+    }
+
+    void qt_windowmanager::windowmanager_hints(int32_t )
+    {
+    }
+
+    void qt_windowmanager::handle_hints(
+        void *data,
+        struct ::qt_windowmanager *object,
+        int32_t show_is_fullscreen)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_windowmanager *>(data)->windowmanager_hints(
+            show_is_fullscreen);
+    }
+
+    void qt_windowmanager::windowmanager_quit()
+    {
+    }
+
+    void qt_windowmanager::handle_quit(
+        void *data,
+        struct ::qt_windowmanager *object)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_windowmanager *>(data)->windowmanager_quit();
+    }
+
+    const struct qt_windowmanager_listener qt_windowmanager::m_qt_windowmanager_listener = {
+        qt_windowmanager::handle_hints,
+        qt_windowmanager::handle_quit,
+    };
+
+    void qt_windowmanager::init_listener()
+    {
+        qt_windowmanager_add_listener(m_qt_windowmanager, &m_qt_windowmanager_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-qt-windowmanager.h b/src/client/qwayland-qt-windowmanager.h
new file mode 100644
index 0000000000000000000000000000000000000000..986d86abf580002f164300526b1890be803d2f4a
--- /dev/null
+++ a/qtwayland/src/client/qwayland-qt-windowmanager.h
@@ -0,0 +1,69 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/qt-windowmanager.xml
+
+#ifndef QT_WAYLAND_QT_WINDOWMANAGER
+#define QT_WAYLAND_QT_WINDOWMANAGER
+
+#include <QtWaylandClient/private/wayland-qt-windowmanager-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_QT_WINDOWMANAGER_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_QT_WINDOWMANAGER_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_QT_WINDOWMANAGER_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_QT_WINDOWMANAGER_EXPORT qt_windowmanager
+    {
+    public:
+        qt_windowmanager(struct ::wl_registry *registry, int id, int version);
+        qt_windowmanager(struct ::qt_windowmanager *object);
+        qt_windowmanager();
+
+        virtual ~qt_windowmanager();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::qt_windowmanager *object);
+
+        struct ::qt_windowmanager *object() { return m_qt_windowmanager; }
+        const struct ::qt_windowmanager *object() const { return m_qt_windowmanager; }
+        static qt_windowmanager *fromObject(struct ::qt_windowmanager *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void open_url(uint32_t remaining, const QString &url);
+
+    protected:
+        virtual void windowmanager_hints(int32_t show_is_fullscreen);
+        virtual void windowmanager_quit();
+
+    private:
+        void init_listener();
+        static const struct qt_windowmanager_listener m_qt_windowmanager_listener;
+        static void handle_hints(
+            void *data,
+            struct ::qt_windowmanager *object,
+            int32_t show_is_fullscreen);
+        static void handle_quit(
+            void *data,
+            struct ::qt_windowmanager *object);
+        struct ::qt_windowmanager *m_qt_windowmanager;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-server-buffer-extension.cpp b/src/client/qwayland-server-buffer-extension.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..b16cf09506c61198b4e0fb928b2ce7b90cd7eff0
--- /dev/null
+++ a/qtwayland/src/client/qwayland-server-buffer-extension.cpp
@@ -0,0 +1,76 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/server-buffer-extension.xml
+
+#include <QtWaylandClient/private/qwayland-server-buffer-extension.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    qt_server_buffer::qt_server_buffer(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    qt_server_buffer::qt_server_buffer(struct ::qt_server_buffer *obj)
+        : m_qt_server_buffer(obj)
+    {
+    }
+
+    qt_server_buffer::qt_server_buffer()
+        : m_qt_server_buffer(nullptr)
+    {
+    }
+
+    qt_server_buffer::~qt_server_buffer()
+    {
+    }
+
+    void qt_server_buffer::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_qt_server_buffer = static_cast<struct ::qt_server_buffer *>(wlRegistryBind(registry, id, &qt_server_buffer_interface, version));
+    }
+
+    void qt_server_buffer::init(struct ::qt_server_buffer *obj)
+    {
+        m_qt_server_buffer = obj;
+    }
+
+    qt_server_buffer *qt_server_buffer::fromObject(struct ::qt_server_buffer *object)
+    {
+        return static_cast<qt_server_buffer *>(qt_server_buffer_get_user_data(object));
+    }
+
+    bool qt_server_buffer::isInitialized() const
+    {
+        return m_qt_server_buffer != nullptr;
+    }
+
+    const struct wl_interface *qt_server_buffer::interface()
+    {
+        return &::qt_server_buffer_interface;
+    }
+
+    void qt_server_buffer::release()
+    {
+        qt_server_buffer_release(
+            m_qt_server_buffer);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-server-buffer-extension.h b/src/client/qwayland-server-buffer-extension.h
new file mode 100644
index 0000000000000000000000000000000000000000..1387cd0940d0e4e22a16abd1c24eddba51267023
--- /dev/null
+++ a/qtwayland/src/client/qwayland-server-buffer-extension.h
@@ -0,0 +1,56 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/server-buffer-extension.xml
+
+#ifndef QT_WAYLAND_SERVER_BUFFER_EXTENSION
+#define QT_WAYLAND_SERVER_BUFFER_EXTENSION
+
+#include <QtWaylandClient/private/wayland-server-buffer-extension-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_SERVER_BUFFER_EXTENSION_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_SERVER_BUFFER_EXTENSION_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_SERVER_BUFFER_EXTENSION_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_SERVER_BUFFER_EXTENSION_EXPORT qt_server_buffer
+    {
+    public:
+        qt_server_buffer(struct ::wl_registry *registry, int id, int version);
+        qt_server_buffer(struct ::qt_server_buffer *object);
+        qt_server_buffer();
+
+        virtual ~qt_server_buffer();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::qt_server_buffer *object);
+
+        struct ::qt_server_buffer *object() { return m_qt_server_buffer; }
+        const struct ::qt_server_buffer *object() const { return m_qt_server_buffer; }
+        static qt_server_buffer *fromObject(struct ::qt_server_buffer *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void release();
+
+    private:
+        struct ::qt_server_buffer *m_qt_server_buffer;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-surface-extension.cpp b/src/client/qwayland-surface-extension.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..553fcd564a6ae035f529c35c79b4cd708f83b4b2
--- /dev/null
+++ a/qtwayland/src/client/qwayland-surface-extension.cpp
@@ -0,0 +1,218 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/surface-extension.xml
+
+#include <QtWaylandClient/private/qwayland-surface-extension.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    qt_surface_extension::qt_surface_extension(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    qt_surface_extension::qt_surface_extension(struct ::qt_surface_extension *obj)
+        : m_qt_surface_extension(obj)
+    {
+    }
+
+    qt_surface_extension::qt_surface_extension()
+        : m_qt_surface_extension(nullptr)
+    {
+    }
+
+    qt_surface_extension::~qt_surface_extension()
+    {
+    }
+
+    void qt_surface_extension::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_qt_surface_extension = static_cast<struct ::qt_surface_extension *>(wlRegistryBind(registry, id, &qt_surface_extension_interface, version));
+    }
+
+    void qt_surface_extension::init(struct ::qt_surface_extension *obj)
+    {
+        m_qt_surface_extension = obj;
+    }
+
+    qt_surface_extension *qt_surface_extension::fromObject(struct ::qt_surface_extension *object)
+    {
+        return static_cast<qt_surface_extension *>(qt_surface_extension_get_user_data(object));
+    }
+
+    bool qt_surface_extension::isInitialized() const
+    {
+        return m_qt_surface_extension != nullptr;
+    }
+
+    const struct wl_interface *qt_surface_extension::interface()
+    {
+        return &::qt_surface_extension_interface;
+    }
+
+    struct ::qt_extended_surface *qt_surface_extension::get_extended_surface(struct ::wl_surface *surface)
+    {
+        return qt_surface_extension_get_extended_surface(
+            m_qt_surface_extension,
+            surface);
+    }
+
+    qt_extended_surface::qt_extended_surface(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    qt_extended_surface::qt_extended_surface(struct ::qt_extended_surface *obj)
+        : m_qt_extended_surface(obj)
+    {
+        init_listener();
+    }
+
+    qt_extended_surface::qt_extended_surface()
+        : m_qt_extended_surface(nullptr)
+    {
+    }
+
+    qt_extended_surface::~qt_extended_surface()
+    {
+    }
+
+    void qt_extended_surface::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_qt_extended_surface = static_cast<struct ::qt_extended_surface *>(wlRegistryBind(registry, id, &qt_extended_surface_interface, version));
+        init_listener();
+    }
+
+    void qt_extended_surface::init(struct ::qt_extended_surface *obj)
+    {
+        m_qt_extended_surface = obj;
+        init_listener();
+    }
+
+    qt_extended_surface *qt_extended_surface::fromObject(struct ::qt_extended_surface *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_qt_extended_surface_listener)
+            return nullptr;
+        return static_cast<qt_extended_surface *>(qt_extended_surface_get_user_data(object));
+    }
+
+    bool qt_extended_surface::isInitialized() const
+    {
+        return m_qt_extended_surface != nullptr;
+    }
+
+    const struct wl_interface *qt_extended_surface::interface()
+    {
+        return &::qt_extended_surface_interface;
+    }
+
+    void qt_extended_surface::update_generic_property(const QString &name, const QByteArray &value)
+    {
+        struct wl_array value_data;
+        value_data.size = value.size();
+        value_data.data = static_cast<void *>(const_cast<char *>(value.constData()));
+        value_data.alloc = 0;
+
+        qt_extended_surface_update_generic_property(
+            m_qt_extended_surface,
+            name.toUtf8().constData(),
+            &value_data);
+    }
+
+    void qt_extended_surface::set_content_orientation_mask(int32_t orientation)
+    {
+        qt_extended_surface_set_content_orientation_mask(
+            m_qt_extended_surface,
+            orientation);
+    }
+
+    void qt_extended_surface::set_window_flags(int32_t flags)
+    {
+        qt_extended_surface_set_window_flags(
+            m_qt_extended_surface,
+            flags);
+    }
+
+    void qt_extended_surface::raise()
+    {
+        qt_extended_surface_raise(
+            m_qt_extended_surface);
+    }
+
+    void qt_extended_surface::lower()
+    {
+        qt_extended_surface_lower(
+            m_qt_extended_surface);
+    }
+
+    void qt_extended_surface::extended_surface_onscreen_visibility(int32_t )
+    {
+    }
+
+    void qt_extended_surface::handle_onscreen_visibility(
+        void *data,
+        struct ::qt_extended_surface *object,
+        int32_t visible)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_extended_surface *>(data)->extended_surface_onscreen_visibility(
+            visible);
+    }
+
+    void qt_extended_surface::extended_surface_set_generic_property(const QString &, wl_array *)
+    {
+    }
+
+    void qt_extended_surface::handle_set_generic_property(
+        void *data,
+        struct ::qt_extended_surface *object,
+        const char *name,
+        wl_array *value)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_extended_surface *>(data)->extended_surface_set_generic_property(
+            QString::fromUtf8(name),
+            value);
+    }
+
+    void qt_extended_surface::extended_surface_close()
+    {
+    }
+
+    void qt_extended_surface::handle_close(
+        void *data,
+        struct ::qt_extended_surface *object)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_extended_surface *>(data)->extended_surface_close();
+    }
+
+    const struct qt_extended_surface_listener qt_extended_surface::m_qt_extended_surface_listener = {
+        qt_extended_surface::handle_onscreen_visibility,
+        qt_extended_surface::handle_set_generic_property,
+        qt_extended_surface::handle_close,
+    };
+
+    void qt_extended_surface::init_listener()
+    {
+        qt_extended_surface_add_listener(m_qt_extended_surface, &m_qt_extended_surface_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-surface-extension.h b/src/client/qwayland-surface-extension.h
new file mode 100644
index 0000000000000000000000000000000000000000..664155b854744fb80818a8e1a04441c4e8f1bfbb
--- /dev/null
+++ a/qtwayland/src/client/qwayland-surface-extension.h
@@ -0,0 +1,119 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/surface-extension.xml
+
+#ifndef QT_WAYLAND_SURFACE_EXTENSION
+#define QT_WAYLAND_SURFACE_EXTENSION
+
+#include <QtWaylandClient/private/wayland-surface-extension-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_SURFACE_EXTENSION_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_SURFACE_EXTENSION_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_SURFACE_EXTENSION_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_SURFACE_EXTENSION_EXPORT qt_surface_extension
+    {
+    public:
+        qt_surface_extension(struct ::wl_registry *registry, int id, int version);
+        qt_surface_extension(struct ::qt_surface_extension *object);
+        qt_surface_extension();
+
+        virtual ~qt_surface_extension();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::qt_surface_extension *object);
+
+        struct ::qt_surface_extension *object() { return m_qt_surface_extension; }
+        const struct ::qt_surface_extension *object() const { return m_qt_surface_extension; }
+        static qt_surface_extension *fromObject(struct ::qt_surface_extension *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        struct ::qt_extended_surface *get_extended_surface(struct ::wl_surface *surface);
+
+    private:
+        struct ::qt_surface_extension *m_qt_surface_extension;
+    };
+
+    class Q_WAYLAND_CLIENT_SURFACE_EXTENSION_EXPORT qt_extended_surface
+    {
+    public:
+        qt_extended_surface(struct ::wl_registry *registry, int id, int version);
+        qt_extended_surface(struct ::qt_extended_surface *object);
+        qt_extended_surface();
+
+        virtual ~qt_extended_surface();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::qt_extended_surface *object);
+
+        struct ::qt_extended_surface *object() { return m_qt_extended_surface; }
+        const struct ::qt_extended_surface *object() const { return m_qt_extended_surface; }
+        static qt_extended_surface *fromObject(struct ::qt_extended_surface *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum orientation {
+            orientation_PrimaryOrientation = 0,
+            orientation_PortraitOrientation = 1,
+            orientation_LandscapeOrientation = 2,
+            orientation_InvertedPortraitOrientation = 4,
+            orientation_InvertedLandscapeOrientation = 8,
+        };
+
+        enum windowflag {
+            windowflag_OverridesSystemGestures = 1,
+            windowflag_StaysOnTop = 2,
+            windowflag_BypassWindowManager = 4,
+        };
+
+        void update_generic_property(const QString &name, const QByteArray &value);
+        void set_content_orientation_mask(int32_t orientation);
+        void set_window_flags(int32_t flags);
+        void raise();
+        void lower();
+
+    protected:
+        virtual void extended_surface_onscreen_visibility(int32_t visible);
+        virtual void extended_surface_set_generic_property(const QString &name, wl_array *value);
+        virtual void extended_surface_close();
+
+    private:
+        void init_listener();
+        static const struct qt_extended_surface_listener m_qt_extended_surface_listener;
+        static void handle_onscreen_visibility(
+            void *data,
+            struct ::qt_extended_surface *object,
+            int32_t visible);
+        static void handle_set_generic_property(
+            void *data,
+            struct ::qt_extended_surface *object,
+            const char *name,
+            wl_array *value);
+        static void handle_close(
+            void *data,
+            struct ::qt_extended_surface *object);
+        struct ::qt_extended_surface *m_qt_extended_surface;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-tablet-unstable-v2.cpp b/src/client/qwayland-tablet-unstable-v2.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..af473f29657d160c3b91a2bc13ae0341ef959274
--- /dev/null
+++ a/qtwayland/src/client/qwayland-tablet-unstable-v2.cpp
@@ -0,0 +1,1314 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/tablet-unstable-v2.xml
+
+#include <QtWaylandClient/private/qwayland-tablet-unstable-v2.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    zwp_tablet_manager_v2::zwp_tablet_manager_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_tablet_manager_v2::zwp_tablet_manager_v2(struct ::zwp_tablet_manager_v2 *obj)
+        : m_zwp_tablet_manager_v2(obj)
+    {
+    }
+
+    zwp_tablet_manager_v2::zwp_tablet_manager_v2()
+        : m_zwp_tablet_manager_v2(nullptr)
+    {
+    }
+
+    zwp_tablet_manager_v2::~zwp_tablet_manager_v2()
+    {
+    }
+
+    void zwp_tablet_manager_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_tablet_manager_v2 = static_cast<struct ::zwp_tablet_manager_v2 *>(wlRegistryBind(registry, id, &zwp_tablet_manager_v2_interface, version));
+    }
+
+    void zwp_tablet_manager_v2::init(struct ::zwp_tablet_manager_v2 *obj)
+    {
+        m_zwp_tablet_manager_v2 = obj;
+    }
+
+    zwp_tablet_manager_v2 *zwp_tablet_manager_v2::fromObject(struct ::zwp_tablet_manager_v2 *object)
+    {
+        return static_cast<zwp_tablet_manager_v2 *>(zwp_tablet_manager_v2_get_user_data(object));
+    }
+
+    bool zwp_tablet_manager_v2::isInitialized() const
+    {
+        return m_zwp_tablet_manager_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_tablet_manager_v2::interface()
+    {
+        return &::zwp_tablet_manager_v2_interface;
+    }
+
+    struct ::zwp_tablet_seat_v2 *zwp_tablet_manager_v2::get_tablet_seat(struct ::wl_seat *seat)
+    {
+        return zwp_tablet_manager_v2_get_tablet_seat(
+            m_zwp_tablet_manager_v2,
+            seat);
+    }
+
+    void zwp_tablet_manager_v2::destroy()
+    {
+        zwp_tablet_manager_v2_destroy(
+            m_zwp_tablet_manager_v2);
+        m_zwp_tablet_manager_v2 = nullptr;
+    }
+
+    zwp_tablet_seat_v2::zwp_tablet_seat_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_tablet_seat_v2::zwp_tablet_seat_v2(struct ::zwp_tablet_seat_v2 *obj)
+        : m_zwp_tablet_seat_v2(obj)
+    {
+        init_listener();
+    }
+
+    zwp_tablet_seat_v2::zwp_tablet_seat_v2()
+        : m_zwp_tablet_seat_v2(nullptr)
+    {
+    }
+
+    zwp_tablet_seat_v2::~zwp_tablet_seat_v2()
+    {
+    }
+
+    void zwp_tablet_seat_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_tablet_seat_v2 = static_cast<struct ::zwp_tablet_seat_v2 *>(wlRegistryBind(registry, id, &zwp_tablet_seat_v2_interface, version));
+        init_listener();
+    }
+
+    void zwp_tablet_seat_v2::init(struct ::zwp_tablet_seat_v2 *obj)
+    {
+        m_zwp_tablet_seat_v2 = obj;
+        init_listener();
+    }
+
+    zwp_tablet_seat_v2 *zwp_tablet_seat_v2::fromObject(struct ::zwp_tablet_seat_v2 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_tablet_seat_v2_listener)
+            return nullptr;
+        return static_cast<zwp_tablet_seat_v2 *>(zwp_tablet_seat_v2_get_user_data(object));
+    }
+
+    bool zwp_tablet_seat_v2::isInitialized() const
+    {
+        return m_zwp_tablet_seat_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_tablet_seat_v2::interface()
+    {
+        return &::zwp_tablet_seat_v2_interface;
+    }
+
+    void zwp_tablet_seat_v2::destroy()
+    {
+        zwp_tablet_seat_v2_destroy(
+            m_zwp_tablet_seat_v2);
+        m_zwp_tablet_seat_v2 = nullptr;
+    }
+
+    void zwp_tablet_seat_v2::zwp_tablet_seat_v2_tablet_added(struct ::zwp_tablet_v2 *)
+    {
+    }
+
+    void zwp_tablet_seat_v2::handle_tablet_added(
+        void *data,
+        struct ::zwp_tablet_seat_v2 *object,
+        struct ::zwp_tablet_v2 *id)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_seat_v2 *>(data)->zwp_tablet_seat_v2_tablet_added(
+            id);
+    }
+
+    void zwp_tablet_seat_v2::zwp_tablet_seat_v2_tool_added(struct ::zwp_tablet_tool_v2 *)
+    {
+    }
+
+    void zwp_tablet_seat_v2::handle_tool_added(
+        void *data,
+        struct ::zwp_tablet_seat_v2 *object,
+        struct ::zwp_tablet_tool_v2 *id)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_seat_v2 *>(data)->zwp_tablet_seat_v2_tool_added(
+            id);
+    }
+
+    void zwp_tablet_seat_v2::zwp_tablet_seat_v2_pad_added(struct ::zwp_tablet_pad_v2 *)
+    {
+    }
+
+    void zwp_tablet_seat_v2::handle_pad_added(
+        void *data,
+        struct ::zwp_tablet_seat_v2 *object,
+        struct ::zwp_tablet_pad_v2 *id)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_seat_v2 *>(data)->zwp_tablet_seat_v2_pad_added(
+            id);
+    }
+
+    const struct zwp_tablet_seat_v2_listener zwp_tablet_seat_v2::m_zwp_tablet_seat_v2_listener = {
+        zwp_tablet_seat_v2::handle_tablet_added,
+        zwp_tablet_seat_v2::handle_tool_added,
+        zwp_tablet_seat_v2::handle_pad_added,
+    };
+
+    void zwp_tablet_seat_v2::init_listener()
+    {
+        zwp_tablet_seat_v2_add_listener(m_zwp_tablet_seat_v2, &m_zwp_tablet_seat_v2_listener, this);
+    }
+
+    zwp_tablet_tool_v2::zwp_tablet_tool_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_tablet_tool_v2::zwp_tablet_tool_v2(struct ::zwp_tablet_tool_v2 *obj)
+        : m_zwp_tablet_tool_v2(obj)
+    {
+        init_listener();
+    }
+
+    zwp_tablet_tool_v2::zwp_tablet_tool_v2()
+        : m_zwp_tablet_tool_v2(nullptr)
+    {
+    }
+
+    zwp_tablet_tool_v2::~zwp_tablet_tool_v2()
+    {
+    }
+
+    void zwp_tablet_tool_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_tablet_tool_v2 = static_cast<struct ::zwp_tablet_tool_v2 *>(wlRegistryBind(registry, id, &zwp_tablet_tool_v2_interface, version));
+        init_listener();
+    }
+
+    void zwp_tablet_tool_v2::init(struct ::zwp_tablet_tool_v2 *obj)
+    {
+        m_zwp_tablet_tool_v2 = obj;
+        init_listener();
+    }
+
+    zwp_tablet_tool_v2 *zwp_tablet_tool_v2::fromObject(struct ::zwp_tablet_tool_v2 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_tablet_tool_v2_listener)
+            return nullptr;
+        return static_cast<zwp_tablet_tool_v2 *>(zwp_tablet_tool_v2_get_user_data(object));
+    }
+
+    bool zwp_tablet_tool_v2::isInitialized() const
+    {
+        return m_zwp_tablet_tool_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_tablet_tool_v2::interface()
+    {
+        return &::zwp_tablet_tool_v2_interface;
+    }
+
+    void zwp_tablet_tool_v2::set_cursor(uint32_t serial, struct ::wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
+    {
+        zwp_tablet_tool_v2_set_cursor(
+            m_zwp_tablet_tool_v2,
+            serial,
+            surface,
+            hotspot_x,
+            hotspot_y);
+    }
+
+    void zwp_tablet_tool_v2::destroy()
+    {
+        zwp_tablet_tool_v2_destroy(
+            m_zwp_tablet_tool_v2);
+        m_zwp_tablet_tool_v2 = nullptr;
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_type(uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_type(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t tool_type)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_type(
+            tool_type);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_hardware_serial(uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_hardware_serial(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t hardware_serial_hi,
+        uint32_t hardware_serial_lo)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_hardware_serial(
+            hardware_serial_hi,
+            hardware_serial_lo);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_hardware_id_wacom(uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_hardware_id_wacom(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t hardware_id_hi,
+        uint32_t hardware_id_lo)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_hardware_id_wacom(
+            hardware_id_hi,
+            hardware_id_lo);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_capability(uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_capability(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t capability)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_capability(
+            capability);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_done()
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_done(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_done();
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_removed()
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_removed(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_removed();
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_proximity_in(uint32_t , struct ::zwp_tablet_v2 *, struct ::wl_surface *)
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_proximity_in(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t serial,
+        struct ::zwp_tablet_v2 *tablet,
+        struct ::wl_surface *surface)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_proximity_in(
+            serial,
+            tablet,
+            surface);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_proximity_out()
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_proximity_out(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_proximity_out();
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_down(uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_down(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t serial)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_down(
+            serial);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_up()
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_up(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_up();
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_motion(wl_fixed_t , wl_fixed_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_motion(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        wl_fixed_t x,
+        wl_fixed_t y)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_motion(
+            x,
+            y);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_pressure(uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_pressure(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t pressure)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_pressure(
+            pressure);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_distance(uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_distance(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t distance)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_distance(
+            distance);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_tilt(wl_fixed_t , wl_fixed_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_tilt(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        wl_fixed_t tilt_x,
+        wl_fixed_t tilt_y)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_tilt(
+            tilt_x,
+            tilt_y);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_rotation(wl_fixed_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_rotation(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        wl_fixed_t degrees)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_rotation(
+            degrees);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_slider(int32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_slider(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        int32_t position)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_slider(
+            position);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_wheel(wl_fixed_t , int32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_wheel(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        wl_fixed_t degrees,
+        int32_t clicks)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_wheel(
+            degrees,
+            clicks);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_button(uint32_t , uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_button(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t serial,
+        uint32_t button,
+        uint32_t state)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_button(
+            serial,
+            button,
+            state);
+    }
+
+    void zwp_tablet_tool_v2::zwp_tablet_tool_v2_frame(uint32_t )
+    {
+    }
+
+    void zwp_tablet_tool_v2::handle_frame(
+        void *data,
+        struct ::zwp_tablet_tool_v2 *object,
+        uint32_t time)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_tool_v2 *>(data)->zwp_tablet_tool_v2_frame(
+            time);
+    }
+
+    const struct zwp_tablet_tool_v2_listener zwp_tablet_tool_v2::m_zwp_tablet_tool_v2_listener = {
+        zwp_tablet_tool_v2::handle_type,
+        zwp_tablet_tool_v2::handle_hardware_serial,
+        zwp_tablet_tool_v2::handle_hardware_id_wacom,
+        zwp_tablet_tool_v2::handle_capability,
+        zwp_tablet_tool_v2::handle_done,
+        zwp_tablet_tool_v2::handle_removed,
+        zwp_tablet_tool_v2::handle_proximity_in,
+        zwp_tablet_tool_v2::handle_proximity_out,
+        zwp_tablet_tool_v2::handle_down,
+        zwp_tablet_tool_v2::handle_up,
+        zwp_tablet_tool_v2::handle_motion,
+        zwp_tablet_tool_v2::handle_pressure,
+        zwp_tablet_tool_v2::handle_distance,
+        zwp_tablet_tool_v2::handle_tilt,
+        zwp_tablet_tool_v2::handle_rotation,
+        zwp_tablet_tool_v2::handle_slider,
+        zwp_tablet_tool_v2::handle_wheel,
+        zwp_tablet_tool_v2::handle_button,
+        zwp_tablet_tool_v2::handle_frame,
+    };
+
+    void zwp_tablet_tool_v2::init_listener()
+    {
+        zwp_tablet_tool_v2_add_listener(m_zwp_tablet_tool_v2, &m_zwp_tablet_tool_v2_listener, this);
+    }
+
+    zwp_tablet_v2::zwp_tablet_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_tablet_v2::zwp_tablet_v2(struct ::zwp_tablet_v2 *obj)
+        : m_zwp_tablet_v2(obj)
+    {
+        init_listener();
+    }
+
+    zwp_tablet_v2::zwp_tablet_v2()
+        : m_zwp_tablet_v2(nullptr)
+    {
+    }
+
+    zwp_tablet_v2::~zwp_tablet_v2()
+    {
+    }
+
+    void zwp_tablet_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_tablet_v2 = static_cast<struct ::zwp_tablet_v2 *>(wlRegistryBind(registry, id, &zwp_tablet_v2_interface, version));
+        init_listener();
+    }
+
+    void zwp_tablet_v2::init(struct ::zwp_tablet_v2 *obj)
+    {
+        m_zwp_tablet_v2 = obj;
+        init_listener();
+    }
+
+    zwp_tablet_v2 *zwp_tablet_v2::fromObject(struct ::zwp_tablet_v2 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_tablet_v2_listener)
+            return nullptr;
+        return static_cast<zwp_tablet_v2 *>(zwp_tablet_v2_get_user_data(object));
+    }
+
+    bool zwp_tablet_v2::isInitialized() const
+    {
+        return m_zwp_tablet_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_tablet_v2::interface()
+    {
+        return &::zwp_tablet_v2_interface;
+    }
+
+    void zwp_tablet_v2::destroy()
+    {
+        zwp_tablet_v2_destroy(
+            m_zwp_tablet_v2);
+        m_zwp_tablet_v2 = nullptr;
+    }
+
+    void zwp_tablet_v2::zwp_tablet_v2_name(const QString &)
+    {
+    }
+
+    void zwp_tablet_v2::handle_name(
+        void *data,
+        struct ::zwp_tablet_v2 *object,
+        const char *name)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_v2 *>(data)->zwp_tablet_v2_name(
+            QString::fromUtf8(name));
+    }
+
+    void zwp_tablet_v2::zwp_tablet_v2_id(uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_tablet_v2::handle_id(
+        void *data,
+        struct ::zwp_tablet_v2 *object,
+        uint32_t vid,
+        uint32_t pid)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_v2 *>(data)->zwp_tablet_v2_id(
+            vid,
+            pid);
+    }
+
+    void zwp_tablet_v2::zwp_tablet_v2_path(const QString &)
+    {
+    }
+
+    void zwp_tablet_v2::handle_path(
+        void *data,
+        struct ::zwp_tablet_v2 *object,
+        const char *path)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_v2 *>(data)->zwp_tablet_v2_path(
+            QString::fromUtf8(path));
+    }
+
+    void zwp_tablet_v2::zwp_tablet_v2_done()
+    {
+    }
+
+    void zwp_tablet_v2::handle_done(
+        void *data,
+        struct ::zwp_tablet_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_v2 *>(data)->zwp_tablet_v2_done();
+    }
+
+    void zwp_tablet_v2::zwp_tablet_v2_removed()
+    {
+    }
+
+    void zwp_tablet_v2::handle_removed(
+        void *data,
+        struct ::zwp_tablet_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_v2 *>(data)->zwp_tablet_v2_removed();
+    }
+
+    const struct zwp_tablet_v2_listener zwp_tablet_v2::m_zwp_tablet_v2_listener = {
+        zwp_tablet_v2::handle_name,
+        zwp_tablet_v2::handle_id,
+        zwp_tablet_v2::handle_path,
+        zwp_tablet_v2::handle_done,
+        zwp_tablet_v2::handle_removed,
+    };
+
+    void zwp_tablet_v2::init_listener()
+    {
+        zwp_tablet_v2_add_listener(m_zwp_tablet_v2, &m_zwp_tablet_v2_listener, this);
+    }
+
+    zwp_tablet_pad_ring_v2::zwp_tablet_pad_ring_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_tablet_pad_ring_v2::zwp_tablet_pad_ring_v2(struct ::zwp_tablet_pad_ring_v2 *obj)
+        : m_zwp_tablet_pad_ring_v2(obj)
+    {
+        init_listener();
+    }
+
+    zwp_tablet_pad_ring_v2::zwp_tablet_pad_ring_v2()
+        : m_zwp_tablet_pad_ring_v2(nullptr)
+    {
+    }
+
+    zwp_tablet_pad_ring_v2::~zwp_tablet_pad_ring_v2()
+    {
+    }
+
+    void zwp_tablet_pad_ring_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_tablet_pad_ring_v2 = static_cast<struct ::zwp_tablet_pad_ring_v2 *>(wlRegistryBind(registry, id, &zwp_tablet_pad_ring_v2_interface, version));
+        init_listener();
+    }
+
+    void zwp_tablet_pad_ring_v2::init(struct ::zwp_tablet_pad_ring_v2 *obj)
+    {
+        m_zwp_tablet_pad_ring_v2 = obj;
+        init_listener();
+    }
+
+    zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2::fromObject(struct ::zwp_tablet_pad_ring_v2 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_tablet_pad_ring_v2_listener)
+            return nullptr;
+        return static_cast<zwp_tablet_pad_ring_v2 *>(zwp_tablet_pad_ring_v2_get_user_data(object));
+    }
+
+    bool zwp_tablet_pad_ring_v2::isInitialized() const
+    {
+        return m_zwp_tablet_pad_ring_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_tablet_pad_ring_v2::interface()
+    {
+        return &::zwp_tablet_pad_ring_v2_interface;
+    }
+
+    void zwp_tablet_pad_ring_v2::set_feedback(const QString &description, uint32_t serial)
+    {
+        zwp_tablet_pad_ring_v2_set_feedback(
+            m_zwp_tablet_pad_ring_v2,
+            description.toUtf8().constData(),
+            serial);
+    }
+
+    void zwp_tablet_pad_ring_v2::destroy()
+    {
+        zwp_tablet_pad_ring_v2_destroy(
+            m_zwp_tablet_pad_ring_v2);
+        m_zwp_tablet_pad_ring_v2 = nullptr;
+    }
+
+    void zwp_tablet_pad_ring_v2::zwp_tablet_pad_ring_v2_source(uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_ring_v2::handle_source(
+        void *data,
+        struct ::zwp_tablet_pad_ring_v2 *object,
+        uint32_t source)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_ring_v2 *>(data)->zwp_tablet_pad_ring_v2_source(
+            source);
+    }
+
+    void zwp_tablet_pad_ring_v2::zwp_tablet_pad_ring_v2_angle(wl_fixed_t )
+    {
+    }
+
+    void zwp_tablet_pad_ring_v2::handle_angle(
+        void *data,
+        struct ::zwp_tablet_pad_ring_v2 *object,
+        wl_fixed_t degrees)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_ring_v2 *>(data)->zwp_tablet_pad_ring_v2_angle(
+            degrees);
+    }
+
+    void zwp_tablet_pad_ring_v2::zwp_tablet_pad_ring_v2_stop()
+    {
+    }
+
+    void zwp_tablet_pad_ring_v2::handle_stop(
+        void *data,
+        struct ::zwp_tablet_pad_ring_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_ring_v2 *>(data)->zwp_tablet_pad_ring_v2_stop();
+    }
+
+    void zwp_tablet_pad_ring_v2::zwp_tablet_pad_ring_v2_frame(uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_ring_v2::handle_frame(
+        void *data,
+        struct ::zwp_tablet_pad_ring_v2 *object,
+        uint32_t time)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_ring_v2 *>(data)->zwp_tablet_pad_ring_v2_frame(
+            time);
+    }
+
+    const struct zwp_tablet_pad_ring_v2_listener zwp_tablet_pad_ring_v2::m_zwp_tablet_pad_ring_v2_listener = {
+        zwp_tablet_pad_ring_v2::handle_source,
+        zwp_tablet_pad_ring_v2::handle_angle,
+        zwp_tablet_pad_ring_v2::handle_stop,
+        zwp_tablet_pad_ring_v2::handle_frame,
+    };
+
+    void zwp_tablet_pad_ring_v2::init_listener()
+    {
+        zwp_tablet_pad_ring_v2_add_listener(m_zwp_tablet_pad_ring_v2, &m_zwp_tablet_pad_ring_v2_listener, this);
+    }
+
+    zwp_tablet_pad_strip_v2::zwp_tablet_pad_strip_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_tablet_pad_strip_v2::zwp_tablet_pad_strip_v2(struct ::zwp_tablet_pad_strip_v2 *obj)
+        : m_zwp_tablet_pad_strip_v2(obj)
+    {
+        init_listener();
+    }
+
+    zwp_tablet_pad_strip_v2::zwp_tablet_pad_strip_v2()
+        : m_zwp_tablet_pad_strip_v2(nullptr)
+    {
+    }
+
+    zwp_tablet_pad_strip_v2::~zwp_tablet_pad_strip_v2()
+    {
+    }
+
+    void zwp_tablet_pad_strip_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_tablet_pad_strip_v2 = static_cast<struct ::zwp_tablet_pad_strip_v2 *>(wlRegistryBind(registry, id, &zwp_tablet_pad_strip_v2_interface, version));
+        init_listener();
+    }
+
+    void zwp_tablet_pad_strip_v2::init(struct ::zwp_tablet_pad_strip_v2 *obj)
+    {
+        m_zwp_tablet_pad_strip_v2 = obj;
+        init_listener();
+    }
+
+    zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2::fromObject(struct ::zwp_tablet_pad_strip_v2 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_tablet_pad_strip_v2_listener)
+            return nullptr;
+        return static_cast<zwp_tablet_pad_strip_v2 *>(zwp_tablet_pad_strip_v2_get_user_data(object));
+    }
+
+    bool zwp_tablet_pad_strip_v2::isInitialized() const
+    {
+        return m_zwp_tablet_pad_strip_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_tablet_pad_strip_v2::interface()
+    {
+        return &::zwp_tablet_pad_strip_v2_interface;
+    }
+
+    void zwp_tablet_pad_strip_v2::set_feedback(const QString &description, uint32_t serial)
+    {
+        zwp_tablet_pad_strip_v2_set_feedback(
+            m_zwp_tablet_pad_strip_v2,
+            description.toUtf8().constData(),
+            serial);
+    }
+
+    void zwp_tablet_pad_strip_v2::destroy()
+    {
+        zwp_tablet_pad_strip_v2_destroy(
+            m_zwp_tablet_pad_strip_v2);
+        m_zwp_tablet_pad_strip_v2 = nullptr;
+    }
+
+    void zwp_tablet_pad_strip_v2::zwp_tablet_pad_strip_v2_source(uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_strip_v2::handle_source(
+        void *data,
+        struct ::zwp_tablet_pad_strip_v2 *object,
+        uint32_t source)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_strip_v2 *>(data)->zwp_tablet_pad_strip_v2_source(
+            source);
+    }
+
+    void zwp_tablet_pad_strip_v2::zwp_tablet_pad_strip_v2_position(uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_strip_v2::handle_position(
+        void *data,
+        struct ::zwp_tablet_pad_strip_v2 *object,
+        uint32_t position)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_strip_v2 *>(data)->zwp_tablet_pad_strip_v2_position(
+            position);
+    }
+
+    void zwp_tablet_pad_strip_v2::zwp_tablet_pad_strip_v2_stop()
+    {
+    }
+
+    void zwp_tablet_pad_strip_v2::handle_stop(
+        void *data,
+        struct ::zwp_tablet_pad_strip_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_strip_v2 *>(data)->zwp_tablet_pad_strip_v2_stop();
+    }
+
+    void zwp_tablet_pad_strip_v2::zwp_tablet_pad_strip_v2_frame(uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_strip_v2::handle_frame(
+        void *data,
+        struct ::zwp_tablet_pad_strip_v2 *object,
+        uint32_t time)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_strip_v2 *>(data)->zwp_tablet_pad_strip_v2_frame(
+            time);
+    }
+
+    const struct zwp_tablet_pad_strip_v2_listener zwp_tablet_pad_strip_v2::m_zwp_tablet_pad_strip_v2_listener = {
+        zwp_tablet_pad_strip_v2::handle_source,
+        zwp_tablet_pad_strip_v2::handle_position,
+        zwp_tablet_pad_strip_v2::handle_stop,
+        zwp_tablet_pad_strip_v2::handle_frame,
+    };
+
+    void zwp_tablet_pad_strip_v2::init_listener()
+    {
+        zwp_tablet_pad_strip_v2_add_listener(m_zwp_tablet_pad_strip_v2, &m_zwp_tablet_pad_strip_v2_listener, this);
+    }
+
+    zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2(struct ::zwp_tablet_pad_group_v2 *obj)
+        : m_zwp_tablet_pad_group_v2(obj)
+    {
+        init_listener();
+    }
+
+    zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2()
+        : m_zwp_tablet_pad_group_v2(nullptr)
+    {
+    }
+
+    zwp_tablet_pad_group_v2::~zwp_tablet_pad_group_v2()
+    {
+    }
+
+    void zwp_tablet_pad_group_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_tablet_pad_group_v2 = static_cast<struct ::zwp_tablet_pad_group_v2 *>(wlRegistryBind(registry, id, &zwp_tablet_pad_group_v2_interface, version));
+        init_listener();
+    }
+
+    void zwp_tablet_pad_group_v2::init(struct ::zwp_tablet_pad_group_v2 *obj)
+    {
+        m_zwp_tablet_pad_group_v2 = obj;
+        init_listener();
+    }
+
+    zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2::fromObject(struct ::zwp_tablet_pad_group_v2 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_tablet_pad_group_v2_listener)
+            return nullptr;
+        return static_cast<zwp_tablet_pad_group_v2 *>(zwp_tablet_pad_group_v2_get_user_data(object));
+    }
+
+    bool zwp_tablet_pad_group_v2::isInitialized() const
+    {
+        return m_zwp_tablet_pad_group_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_tablet_pad_group_v2::interface()
+    {
+        return &::zwp_tablet_pad_group_v2_interface;
+    }
+
+    void zwp_tablet_pad_group_v2::destroy()
+    {
+        zwp_tablet_pad_group_v2_destroy(
+            m_zwp_tablet_pad_group_v2);
+        m_zwp_tablet_pad_group_v2 = nullptr;
+    }
+
+    void zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2_buttons(wl_array *)
+    {
+    }
+
+    void zwp_tablet_pad_group_v2::handle_buttons(
+        void *data,
+        struct ::zwp_tablet_pad_group_v2 *object,
+        wl_array *buttons)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_group_v2 *>(data)->zwp_tablet_pad_group_v2_buttons(
+            buttons);
+    }
+
+    void zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2_ring(struct ::zwp_tablet_pad_ring_v2 *)
+    {
+    }
+
+    void zwp_tablet_pad_group_v2::handle_ring(
+        void *data,
+        struct ::zwp_tablet_pad_group_v2 *object,
+        struct ::zwp_tablet_pad_ring_v2 *ring)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_group_v2 *>(data)->zwp_tablet_pad_group_v2_ring(
+            ring);
+    }
+
+    void zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2_strip(struct ::zwp_tablet_pad_strip_v2 *)
+    {
+    }
+
+    void zwp_tablet_pad_group_v2::handle_strip(
+        void *data,
+        struct ::zwp_tablet_pad_group_v2 *object,
+        struct ::zwp_tablet_pad_strip_v2 *strip)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_group_v2 *>(data)->zwp_tablet_pad_group_v2_strip(
+            strip);
+    }
+
+    void zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2_modes(uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_group_v2::handle_modes(
+        void *data,
+        struct ::zwp_tablet_pad_group_v2 *object,
+        uint32_t modes)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_group_v2 *>(data)->zwp_tablet_pad_group_v2_modes(
+            modes);
+    }
+
+    void zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2_done()
+    {
+    }
+
+    void zwp_tablet_pad_group_v2::handle_done(
+        void *data,
+        struct ::zwp_tablet_pad_group_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_group_v2 *>(data)->zwp_tablet_pad_group_v2_done();
+    }
+
+    void zwp_tablet_pad_group_v2::zwp_tablet_pad_group_v2_mode_switch(uint32_t , uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_group_v2::handle_mode_switch(
+        void *data,
+        struct ::zwp_tablet_pad_group_v2 *object,
+        uint32_t time,
+        uint32_t serial,
+        uint32_t mode)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_group_v2 *>(data)->zwp_tablet_pad_group_v2_mode_switch(
+            time,
+            serial,
+            mode);
+    }
+
+    const struct zwp_tablet_pad_group_v2_listener zwp_tablet_pad_group_v2::m_zwp_tablet_pad_group_v2_listener = {
+        zwp_tablet_pad_group_v2::handle_buttons,
+        zwp_tablet_pad_group_v2::handle_ring,
+        zwp_tablet_pad_group_v2::handle_strip,
+        zwp_tablet_pad_group_v2::handle_modes,
+        zwp_tablet_pad_group_v2::handle_done,
+        zwp_tablet_pad_group_v2::handle_mode_switch,
+    };
+
+    void zwp_tablet_pad_group_v2::init_listener()
+    {
+        zwp_tablet_pad_group_v2_add_listener(m_zwp_tablet_pad_group_v2, &m_zwp_tablet_pad_group_v2_listener, this);
+    }
+
+    zwp_tablet_pad_v2::zwp_tablet_pad_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_tablet_pad_v2::zwp_tablet_pad_v2(struct ::zwp_tablet_pad_v2 *obj)
+        : m_zwp_tablet_pad_v2(obj)
+    {
+        init_listener();
+    }
+
+    zwp_tablet_pad_v2::zwp_tablet_pad_v2()
+        : m_zwp_tablet_pad_v2(nullptr)
+    {
+    }
+
+    zwp_tablet_pad_v2::~zwp_tablet_pad_v2()
+    {
+    }
+
+    void zwp_tablet_pad_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_tablet_pad_v2 = static_cast<struct ::zwp_tablet_pad_v2 *>(wlRegistryBind(registry, id, &zwp_tablet_pad_v2_interface, version));
+        init_listener();
+    }
+
+    void zwp_tablet_pad_v2::init(struct ::zwp_tablet_pad_v2 *obj)
+    {
+        m_zwp_tablet_pad_v2 = obj;
+        init_listener();
+    }
+
+    zwp_tablet_pad_v2 *zwp_tablet_pad_v2::fromObject(struct ::zwp_tablet_pad_v2 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_tablet_pad_v2_listener)
+            return nullptr;
+        return static_cast<zwp_tablet_pad_v2 *>(zwp_tablet_pad_v2_get_user_data(object));
+    }
+
+    bool zwp_tablet_pad_v2::isInitialized() const
+    {
+        return m_zwp_tablet_pad_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_tablet_pad_v2::interface()
+    {
+        return &::zwp_tablet_pad_v2_interface;
+    }
+
+    void zwp_tablet_pad_v2::set_feedback(uint32_t button, const QString &description, uint32_t serial)
+    {
+        zwp_tablet_pad_v2_set_feedback(
+            m_zwp_tablet_pad_v2,
+            button,
+            description.toUtf8().constData(),
+            serial);
+    }
+
+    void zwp_tablet_pad_v2::destroy()
+    {
+        zwp_tablet_pad_v2_destroy(
+            m_zwp_tablet_pad_v2);
+        m_zwp_tablet_pad_v2 = nullptr;
+    }
+
+    void zwp_tablet_pad_v2::zwp_tablet_pad_v2_group(struct ::zwp_tablet_pad_group_v2 *)
+    {
+    }
+
+    void zwp_tablet_pad_v2::handle_group(
+        void *data,
+        struct ::zwp_tablet_pad_v2 *object,
+        struct ::zwp_tablet_pad_group_v2 *pad_group)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_v2 *>(data)->zwp_tablet_pad_v2_group(
+            pad_group);
+    }
+
+    void zwp_tablet_pad_v2::zwp_tablet_pad_v2_path(const QString &)
+    {
+    }
+
+    void zwp_tablet_pad_v2::handle_path(
+        void *data,
+        struct ::zwp_tablet_pad_v2 *object,
+        const char *path)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_v2 *>(data)->zwp_tablet_pad_v2_path(
+            QString::fromUtf8(path));
+    }
+
+    void zwp_tablet_pad_v2::zwp_tablet_pad_v2_buttons(uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_v2::handle_buttons(
+        void *data,
+        struct ::zwp_tablet_pad_v2 *object,
+        uint32_t buttons)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_v2 *>(data)->zwp_tablet_pad_v2_buttons(
+            buttons);
+    }
+
+    void zwp_tablet_pad_v2::zwp_tablet_pad_v2_done()
+    {
+    }
+
+    void zwp_tablet_pad_v2::handle_done(
+        void *data,
+        struct ::zwp_tablet_pad_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_v2 *>(data)->zwp_tablet_pad_v2_done();
+    }
+
+    void zwp_tablet_pad_v2::zwp_tablet_pad_v2_button(uint32_t , uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_tablet_pad_v2::handle_button(
+        void *data,
+        struct ::zwp_tablet_pad_v2 *object,
+        uint32_t time,
+        uint32_t button,
+        uint32_t state)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_v2 *>(data)->zwp_tablet_pad_v2_button(
+            time,
+            button,
+            state);
+    }
+
+    void zwp_tablet_pad_v2::zwp_tablet_pad_v2_enter(uint32_t , struct ::zwp_tablet_v2 *, struct ::wl_surface *)
+    {
+    }
+
+    void zwp_tablet_pad_v2::handle_enter(
+        void *data,
+        struct ::zwp_tablet_pad_v2 *object,
+        uint32_t serial,
+        struct ::zwp_tablet_v2 *tablet,
+        struct ::wl_surface *surface)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_v2 *>(data)->zwp_tablet_pad_v2_enter(
+            serial,
+            tablet,
+            surface);
+    }
+
+    void zwp_tablet_pad_v2::zwp_tablet_pad_v2_leave(uint32_t , struct ::wl_surface *)
+    {
+    }
+
+    void zwp_tablet_pad_v2::handle_leave(
+        void *data,
+        struct ::zwp_tablet_pad_v2 *object,
+        uint32_t serial,
+        struct ::wl_surface *surface)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_v2 *>(data)->zwp_tablet_pad_v2_leave(
+            serial,
+            surface);
+    }
+
+    void zwp_tablet_pad_v2::zwp_tablet_pad_v2_removed()
+    {
+    }
+
+    void zwp_tablet_pad_v2::handle_removed(
+        void *data,
+        struct ::zwp_tablet_pad_v2 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_tablet_pad_v2 *>(data)->zwp_tablet_pad_v2_removed();
+    }
+
+    const struct zwp_tablet_pad_v2_listener zwp_tablet_pad_v2::m_zwp_tablet_pad_v2_listener = {
+        zwp_tablet_pad_v2::handle_group,
+        zwp_tablet_pad_v2::handle_path,
+        zwp_tablet_pad_v2::handle_buttons,
+        zwp_tablet_pad_v2::handle_done,
+        zwp_tablet_pad_v2::handle_button,
+        zwp_tablet_pad_v2::handle_enter,
+        zwp_tablet_pad_v2::handle_leave,
+        zwp_tablet_pad_v2::handle_removed,
+    };
+
+    void zwp_tablet_pad_v2::init_listener()
+    {
+        zwp_tablet_pad_v2_add_listener(m_zwp_tablet_pad_v2, &m_zwp_tablet_pad_v2_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-tablet-unstable-v2.h b/src/client/qwayland-tablet-unstable-v2.h
new file mode 100644
index 0000000000000000000000000000000000000000..c22455775bca80eb70e8860c898b20fb50e7ca2a
--- /dev/null
+++ a/qtwayland/src/client/qwayland-tablet-unstable-v2.h
@@ -0,0 +1,564 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/tablet-unstable-v2.xml
+
+#ifndef QT_WAYLAND_TABLET_UNSTABLE_V2
+#define QT_WAYLAND_TABLET_UNSTABLE_V2
+
+#include <QtWaylandClient/private/wayland-tablet-unstable-v2-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT zwp_tablet_manager_v2
+    {
+    public:
+        zwp_tablet_manager_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_tablet_manager_v2(struct ::zwp_tablet_manager_v2 *object);
+        zwp_tablet_manager_v2();
+
+        virtual ~zwp_tablet_manager_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_tablet_manager_v2 *object);
+
+        struct ::zwp_tablet_manager_v2 *object() { return m_zwp_tablet_manager_v2; }
+        const struct ::zwp_tablet_manager_v2 *object() const { return m_zwp_tablet_manager_v2; }
+        static zwp_tablet_manager_v2 *fromObject(struct ::zwp_tablet_manager_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        struct ::zwp_tablet_seat_v2 *get_tablet_seat(struct ::wl_seat *seat);
+        void destroy();
+
+    private:
+        struct ::zwp_tablet_manager_v2 *m_zwp_tablet_manager_v2;
+    };
+
+    class Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT zwp_tablet_seat_v2
+    {
+    public:
+        zwp_tablet_seat_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_tablet_seat_v2(struct ::zwp_tablet_seat_v2 *object);
+        zwp_tablet_seat_v2();
+
+        virtual ~zwp_tablet_seat_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_tablet_seat_v2 *object);
+
+        struct ::zwp_tablet_seat_v2 *object() { return m_zwp_tablet_seat_v2; }
+        const struct ::zwp_tablet_seat_v2 *object() const { return m_zwp_tablet_seat_v2; }
+        static zwp_tablet_seat_v2 *fromObject(struct ::zwp_tablet_seat_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+
+    protected:
+        virtual void zwp_tablet_seat_v2_tablet_added(struct ::zwp_tablet_v2 *id);
+        virtual void zwp_tablet_seat_v2_tool_added(struct ::zwp_tablet_tool_v2 *id);
+        virtual void zwp_tablet_seat_v2_pad_added(struct ::zwp_tablet_pad_v2 *id);
+
+    private:
+        void init_listener();
+        static const struct zwp_tablet_seat_v2_listener m_zwp_tablet_seat_v2_listener;
+        static void handle_tablet_added(
+            void *data,
+            struct ::zwp_tablet_seat_v2 *object,
+            struct ::zwp_tablet_v2 *id);
+        static void handle_tool_added(
+            void *data,
+            struct ::zwp_tablet_seat_v2 *object,
+            struct ::zwp_tablet_tool_v2 *id);
+        static void handle_pad_added(
+            void *data,
+            struct ::zwp_tablet_seat_v2 *object,
+            struct ::zwp_tablet_pad_v2 *id);
+        struct ::zwp_tablet_seat_v2 *m_zwp_tablet_seat_v2;
+    };
+
+    class Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT zwp_tablet_tool_v2
+    {
+    public:
+        zwp_tablet_tool_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_tablet_tool_v2(struct ::zwp_tablet_tool_v2 *object);
+        zwp_tablet_tool_v2();
+
+        virtual ~zwp_tablet_tool_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_tablet_tool_v2 *object);
+
+        struct ::zwp_tablet_tool_v2 *object() { return m_zwp_tablet_tool_v2; }
+        const struct ::zwp_tablet_tool_v2 *object() const { return m_zwp_tablet_tool_v2; }
+        static zwp_tablet_tool_v2 *fromObject(struct ::zwp_tablet_tool_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum type {
+            type_pen = 0x140, // Pen
+            type_eraser = 0x141, // Eraser
+            type_brush = 0x142, // Brush
+            type_pencil = 0x143, // Pencil
+            type_airbrush = 0x144, // Airbrush
+            type_finger = 0x145, // Finger
+            type_mouse = 0x146, // Mouse
+            type_lens = 0x147, // Lens
+        };
+
+        enum capability {
+            capability_tilt = 1, // Tilt axes
+            capability_pressure = 2, // Pressure axis
+            capability_distance = 3, // Distance axis
+            capability_rotation = 4, // Z-rotation axis
+            capability_slider = 5, // Slider axis
+            capability_wheel = 6, // Wheel axis
+        };
+
+        enum button_state {
+            button_state_released = 0, // button is not pressed
+            button_state_pressed = 1, // button is pressed
+        };
+
+        enum error {
+            error_role = 0, // given wl_surface has another role
+        };
+
+        void set_cursor(uint32_t serial, struct ::wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y);
+        void destroy();
+
+    protected:
+        virtual void zwp_tablet_tool_v2_type(uint32_t tool_type);
+        virtual void zwp_tablet_tool_v2_hardware_serial(uint32_t hardware_serial_hi, uint32_t hardware_serial_lo);
+        virtual void zwp_tablet_tool_v2_hardware_id_wacom(uint32_t hardware_id_hi, uint32_t hardware_id_lo);
+        virtual void zwp_tablet_tool_v2_capability(uint32_t capability);
+        virtual void zwp_tablet_tool_v2_done();
+        virtual void zwp_tablet_tool_v2_removed();
+        virtual void zwp_tablet_tool_v2_proximity_in(uint32_t serial, struct ::zwp_tablet_v2 *tablet, struct ::wl_surface *surface);
+        virtual void zwp_tablet_tool_v2_proximity_out();
+        virtual void zwp_tablet_tool_v2_down(uint32_t serial);
+        virtual void zwp_tablet_tool_v2_up();
+        virtual void zwp_tablet_tool_v2_motion(wl_fixed_t x, wl_fixed_t y);
+        virtual void zwp_tablet_tool_v2_pressure(uint32_t pressure);
+        virtual void zwp_tablet_tool_v2_distance(uint32_t distance);
+        virtual void zwp_tablet_tool_v2_tilt(wl_fixed_t tilt_x, wl_fixed_t tilt_y);
+        virtual void zwp_tablet_tool_v2_rotation(wl_fixed_t degrees);
+        virtual void zwp_tablet_tool_v2_slider(int32_t position);
+        virtual void zwp_tablet_tool_v2_wheel(wl_fixed_t degrees, int32_t clicks);
+        virtual void zwp_tablet_tool_v2_button(uint32_t serial, uint32_t button, uint32_t state);
+        virtual void zwp_tablet_tool_v2_frame(uint32_t time);
+
+    private:
+        void init_listener();
+        static const struct zwp_tablet_tool_v2_listener m_zwp_tablet_tool_v2_listener;
+        static void handle_type(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t tool_type);
+        static void handle_hardware_serial(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t hardware_serial_hi,
+            uint32_t hardware_serial_lo);
+        static void handle_hardware_id_wacom(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t hardware_id_hi,
+            uint32_t hardware_id_lo);
+        static void handle_capability(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t capability);
+        static void handle_done(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object);
+        static void handle_removed(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object);
+        static void handle_proximity_in(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t serial,
+            struct ::zwp_tablet_v2 *tablet,
+            struct ::wl_surface *surface);
+        static void handle_proximity_out(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object);
+        static void handle_down(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t serial);
+        static void handle_up(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object);
+        static void handle_motion(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            wl_fixed_t x,
+            wl_fixed_t y);
+        static void handle_pressure(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t pressure);
+        static void handle_distance(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t distance);
+        static void handle_tilt(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            wl_fixed_t tilt_x,
+            wl_fixed_t tilt_y);
+        static void handle_rotation(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            wl_fixed_t degrees);
+        static void handle_slider(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            int32_t position);
+        static void handle_wheel(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            wl_fixed_t degrees,
+            int32_t clicks);
+        static void handle_button(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t serial,
+            uint32_t button,
+            uint32_t state);
+        static void handle_frame(
+            void *data,
+            struct ::zwp_tablet_tool_v2 *object,
+            uint32_t time);
+        struct ::zwp_tablet_tool_v2 *m_zwp_tablet_tool_v2;
+    };
+
+    class Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT zwp_tablet_v2
+    {
+    public:
+        zwp_tablet_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_tablet_v2(struct ::zwp_tablet_v2 *object);
+        zwp_tablet_v2();
+
+        virtual ~zwp_tablet_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_tablet_v2 *object);
+
+        struct ::zwp_tablet_v2 *object() { return m_zwp_tablet_v2; }
+        const struct ::zwp_tablet_v2 *object() const { return m_zwp_tablet_v2; }
+        static zwp_tablet_v2 *fromObject(struct ::zwp_tablet_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+
+    protected:
+        virtual void zwp_tablet_v2_name(const QString &name);
+        virtual void zwp_tablet_v2_id(uint32_t vid, uint32_t pid);
+        virtual void zwp_tablet_v2_path(const QString &path);
+        virtual void zwp_tablet_v2_done();
+        virtual void zwp_tablet_v2_removed();
+
+    private:
+        void init_listener();
+        static const struct zwp_tablet_v2_listener m_zwp_tablet_v2_listener;
+        static void handle_name(
+            void *data,
+            struct ::zwp_tablet_v2 *object,
+            const char *name);
+        static void handle_id(
+            void *data,
+            struct ::zwp_tablet_v2 *object,
+            uint32_t vid,
+            uint32_t pid);
+        static void handle_path(
+            void *data,
+            struct ::zwp_tablet_v2 *object,
+            const char *path);
+        static void handle_done(
+            void *data,
+            struct ::zwp_tablet_v2 *object);
+        static void handle_removed(
+            void *data,
+            struct ::zwp_tablet_v2 *object);
+        struct ::zwp_tablet_v2 *m_zwp_tablet_v2;
+    };
+
+    class Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT zwp_tablet_pad_ring_v2
+    {
+    public:
+        zwp_tablet_pad_ring_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_tablet_pad_ring_v2(struct ::zwp_tablet_pad_ring_v2 *object);
+        zwp_tablet_pad_ring_v2();
+
+        virtual ~zwp_tablet_pad_ring_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_tablet_pad_ring_v2 *object);
+
+        struct ::zwp_tablet_pad_ring_v2 *object() { return m_zwp_tablet_pad_ring_v2; }
+        const struct ::zwp_tablet_pad_ring_v2 *object() const { return m_zwp_tablet_pad_ring_v2; }
+        static zwp_tablet_pad_ring_v2 *fromObject(struct ::zwp_tablet_pad_ring_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum source {
+            source_finger = 1, // finger
+        };
+
+        void set_feedback(const QString &description, uint32_t serial);
+        void destroy();
+
+    protected:
+        virtual void zwp_tablet_pad_ring_v2_source(uint32_t source);
+        virtual void zwp_tablet_pad_ring_v2_angle(wl_fixed_t degrees);
+        virtual void zwp_tablet_pad_ring_v2_stop();
+        virtual void zwp_tablet_pad_ring_v2_frame(uint32_t time);
+
+    private:
+        void init_listener();
+        static const struct zwp_tablet_pad_ring_v2_listener m_zwp_tablet_pad_ring_v2_listener;
+        static void handle_source(
+            void *data,
+            struct ::zwp_tablet_pad_ring_v2 *object,
+            uint32_t source);
+        static void handle_angle(
+            void *data,
+            struct ::zwp_tablet_pad_ring_v2 *object,
+            wl_fixed_t degrees);
+        static void handle_stop(
+            void *data,
+            struct ::zwp_tablet_pad_ring_v2 *object);
+        static void handle_frame(
+            void *data,
+            struct ::zwp_tablet_pad_ring_v2 *object,
+            uint32_t time);
+        struct ::zwp_tablet_pad_ring_v2 *m_zwp_tablet_pad_ring_v2;
+    };
+
+    class Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT zwp_tablet_pad_strip_v2
+    {
+    public:
+        zwp_tablet_pad_strip_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_tablet_pad_strip_v2(struct ::zwp_tablet_pad_strip_v2 *object);
+        zwp_tablet_pad_strip_v2();
+
+        virtual ~zwp_tablet_pad_strip_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_tablet_pad_strip_v2 *object);
+
+        struct ::zwp_tablet_pad_strip_v2 *object() { return m_zwp_tablet_pad_strip_v2; }
+        const struct ::zwp_tablet_pad_strip_v2 *object() const { return m_zwp_tablet_pad_strip_v2; }
+        static zwp_tablet_pad_strip_v2 *fromObject(struct ::zwp_tablet_pad_strip_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum source {
+            source_finger = 1, // finger
+        };
+
+        void set_feedback(const QString &description, uint32_t serial);
+        void destroy();
+
+    protected:
+        virtual void zwp_tablet_pad_strip_v2_source(uint32_t source);
+        virtual void zwp_tablet_pad_strip_v2_position(uint32_t position);
+        virtual void zwp_tablet_pad_strip_v2_stop();
+        virtual void zwp_tablet_pad_strip_v2_frame(uint32_t time);
+
+    private:
+        void init_listener();
+        static const struct zwp_tablet_pad_strip_v2_listener m_zwp_tablet_pad_strip_v2_listener;
+        static void handle_source(
+            void *data,
+            struct ::zwp_tablet_pad_strip_v2 *object,
+            uint32_t source);
+        static void handle_position(
+            void *data,
+            struct ::zwp_tablet_pad_strip_v2 *object,
+            uint32_t position);
+        static void handle_stop(
+            void *data,
+            struct ::zwp_tablet_pad_strip_v2 *object);
+        static void handle_frame(
+            void *data,
+            struct ::zwp_tablet_pad_strip_v2 *object,
+            uint32_t time);
+        struct ::zwp_tablet_pad_strip_v2 *m_zwp_tablet_pad_strip_v2;
+    };
+
+    class Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT zwp_tablet_pad_group_v2
+    {
+    public:
+        zwp_tablet_pad_group_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_tablet_pad_group_v2(struct ::zwp_tablet_pad_group_v2 *object);
+        zwp_tablet_pad_group_v2();
+
+        virtual ~zwp_tablet_pad_group_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_tablet_pad_group_v2 *object);
+
+        struct ::zwp_tablet_pad_group_v2 *object() { return m_zwp_tablet_pad_group_v2; }
+        const struct ::zwp_tablet_pad_group_v2 *object() const { return m_zwp_tablet_pad_group_v2; }
+        static zwp_tablet_pad_group_v2 *fromObject(struct ::zwp_tablet_pad_group_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+
+    protected:
+        virtual void zwp_tablet_pad_group_v2_buttons(wl_array *buttons);
+        virtual void zwp_tablet_pad_group_v2_ring(struct ::zwp_tablet_pad_ring_v2 *ring);
+        virtual void zwp_tablet_pad_group_v2_strip(struct ::zwp_tablet_pad_strip_v2 *strip);
+        virtual void zwp_tablet_pad_group_v2_modes(uint32_t modes);
+        virtual void zwp_tablet_pad_group_v2_done();
+        virtual void zwp_tablet_pad_group_v2_mode_switch(uint32_t time, uint32_t serial, uint32_t mode);
+
+    private:
+        void init_listener();
+        static const struct zwp_tablet_pad_group_v2_listener m_zwp_tablet_pad_group_v2_listener;
+        static void handle_buttons(
+            void *data,
+            struct ::zwp_tablet_pad_group_v2 *object,
+            wl_array *buttons);
+        static void handle_ring(
+            void *data,
+            struct ::zwp_tablet_pad_group_v2 *object,
+            struct ::zwp_tablet_pad_ring_v2 *ring);
+        static void handle_strip(
+            void *data,
+            struct ::zwp_tablet_pad_group_v2 *object,
+            struct ::zwp_tablet_pad_strip_v2 *strip);
+        static void handle_modes(
+            void *data,
+            struct ::zwp_tablet_pad_group_v2 *object,
+            uint32_t modes);
+        static void handle_done(
+            void *data,
+            struct ::zwp_tablet_pad_group_v2 *object);
+        static void handle_mode_switch(
+            void *data,
+            struct ::zwp_tablet_pad_group_v2 *object,
+            uint32_t time,
+            uint32_t serial,
+            uint32_t mode);
+        struct ::zwp_tablet_pad_group_v2 *m_zwp_tablet_pad_group_v2;
+    };
+
+    class Q_WAYLAND_CLIENT_TABLET_UNSTABLE_V2_EXPORT zwp_tablet_pad_v2
+    {
+    public:
+        zwp_tablet_pad_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_tablet_pad_v2(struct ::zwp_tablet_pad_v2 *object);
+        zwp_tablet_pad_v2();
+
+        virtual ~zwp_tablet_pad_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_tablet_pad_v2 *object);
+
+        struct ::zwp_tablet_pad_v2 *object() { return m_zwp_tablet_pad_v2; }
+        const struct ::zwp_tablet_pad_v2 *object() const { return m_zwp_tablet_pad_v2; }
+        static zwp_tablet_pad_v2 *fromObject(struct ::zwp_tablet_pad_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum button_state {
+            button_state_released = 0, // the button is not pressed
+            button_state_pressed = 1, // the button is pressed
+        };
+
+        void set_feedback(uint32_t button, const QString &description, uint32_t serial);
+        void destroy();
+
+    protected:
+        virtual void zwp_tablet_pad_v2_group(struct ::zwp_tablet_pad_group_v2 *pad_group);
+        virtual void zwp_tablet_pad_v2_path(const QString &path);
+        virtual void zwp_tablet_pad_v2_buttons(uint32_t buttons);
+        virtual void zwp_tablet_pad_v2_done();
+        virtual void zwp_tablet_pad_v2_button(uint32_t time, uint32_t button, uint32_t state);
+        virtual void zwp_tablet_pad_v2_enter(uint32_t serial, struct ::zwp_tablet_v2 *tablet, struct ::wl_surface *surface);
+        virtual void zwp_tablet_pad_v2_leave(uint32_t serial, struct ::wl_surface *surface);
+        virtual void zwp_tablet_pad_v2_removed();
+
+    private:
+        void init_listener();
+        static const struct zwp_tablet_pad_v2_listener m_zwp_tablet_pad_v2_listener;
+        static void handle_group(
+            void *data,
+            struct ::zwp_tablet_pad_v2 *object,
+            struct ::zwp_tablet_pad_group_v2 *pad_group);
+        static void handle_path(
+            void *data,
+            struct ::zwp_tablet_pad_v2 *object,
+            const char *path);
+        static void handle_buttons(
+            void *data,
+            struct ::zwp_tablet_pad_v2 *object,
+            uint32_t buttons);
+        static void handle_done(
+            void *data,
+            struct ::zwp_tablet_pad_v2 *object);
+        static void handle_button(
+            void *data,
+            struct ::zwp_tablet_pad_v2 *object,
+            uint32_t time,
+            uint32_t button,
+            uint32_t state);
+        static void handle_enter(
+            void *data,
+            struct ::zwp_tablet_pad_v2 *object,
+            uint32_t serial,
+            struct ::zwp_tablet_v2 *tablet,
+            struct ::wl_surface *surface);
+        static void handle_leave(
+            void *data,
+            struct ::zwp_tablet_pad_v2 *object,
+            uint32_t serial,
+            struct ::wl_surface *surface);
+        static void handle_removed(
+            void *data,
+            struct ::zwp_tablet_pad_v2 *object);
+        struct ::zwp_tablet_pad_v2 *m_zwp_tablet_pad_v2;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-text-input-unstable-v2.cpp b/src/client/qwayland-text-input-unstable-v2.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..042dae815d9adc453a7a8a1d9b4451827d6c6f88
--- /dev/null
+++ a/qtwayland/src/client/qwayland-text-input-unstable-v2.cpp
@@ -0,0 +1,473 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/text-input-unstable-v2.xml
+
+#include <QtWaylandClient/private/qwayland-text-input-unstable-v2.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    zwp_text_input_v2::zwp_text_input_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_text_input_v2::zwp_text_input_v2(struct ::zwp_text_input_v2 *obj)
+        : m_zwp_text_input_v2(obj)
+    {
+        init_listener();
+    }
+
+    zwp_text_input_v2::zwp_text_input_v2()
+        : m_zwp_text_input_v2(nullptr)
+    {
+    }
+
+    zwp_text_input_v2::~zwp_text_input_v2()
+    {
+    }
+
+    void zwp_text_input_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_text_input_v2 = static_cast<struct ::zwp_text_input_v2 *>(wlRegistryBind(registry, id, &zwp_text_input_v2_interface, version));
+        init_listener();
+    }
+
+    void zwp_text_input_v2::init(struct ::zwp_text_input_v2 *obj)
+    {
+        m_zwp_text_input_v2 = obj;
+        init_listener();
+    }
+
+    zwp_text_input_v2 *zwp_text_input_v2::fromObject(struct ::zwp_text_input_v2 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_text_input_v2_listener)
+            return nullptr;
+        return static_cast<zwp_text_input_v2 *>(zwp_text_input_v2_get_user_data(object));
+    }
+
+    bool zwp_text_input_v2::isInitialized() const
+    {
+        return m_zwp_text_input_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_text_input_v2::interface()
+    {
+        return &::zwp_text_input_v2_interface;
+    }
+
+    void zwp_text_input_v2::destroy()
+    {
+        zwp_text_input_v2_destroy(
+            m_zwp_text_input_v2);
+        m_zwp_text_input_v2 = nullptr;
+    }
+
+    void zwp_text_input_v2::enable(struct ::wl_surface *surface)
+    {
+        zwp_text_input_v2_enable(
+            m_zwp_text_input_v2,
+            surface);
+    }
+
+    void zwp_text_input_v2::disable(struct ::wl_surface *surface)
+    {
+        zwp_text_input_v2_disable(
+            m_zwp_text_input_v2,
+            surface);
+    }
+
+    void zwp_text_input_v2::show_input_panel()
+    {
+        zwp_text_input_v2_show_input_panel(
+            m_zwp_text_input_v2);
+    }
+
+    void zwp_text_input_v2::hide_input_panel()
+    {
+        zwp_text_input_v2_hide_input_panel(
+            m_zwp_text_input_v2);
+    }
+
+    void zwp_text_input_v2::set_surrounding_text(const QString &text, int32_t cursor, int32_t anchor)
+    {
+        zwp_text_input_v2_set_surrounding_text(
+            m_zwp_text_input_v2,
+            text.toUtf8().constData(),
+            cursor,
+            anchor);
+    }
+
+    void zwp_text_input_v2::set_content_type(uint32_t hint, uint32_t purpose)
+    {
+        zwp_text_input_v2_set_content_type(
+            m_zwp_text_input_v2,
+            hint,
+            purpose);
+    }
+
+    void zwp_text_input_v2::set_cursor_rectangle(int32_t x, int32_t y, int32_t width, int32_t height)
+    {
+        zwp_text_input_v2_set_cursor_rectangle(
+            m_zwp_text_input_v2,
+            x,
+            y,
+            width,
+            height);
+    }
+
+    void zwp_text_input_v2::set_preferred_language(const QString &language)
+    {
+        zwp_text_input_v2_set_preferred_language(
+            m_zwp_text_input_v2,
+            language.toUtf8().constData());
+    }
+
+    void zwp_text_input_v2::update_state(uint32_t serial, uint32_t reason)
+    {
+        zwp_text_input_v2_update_state(
+            m_zwp_text_input_v2,
+            serial,
+            reason);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_enter(uint32_t , struct ::wl_surface *)
+    {
+    }
+
+    void zwp_text_input_v2::handle_enter(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        uint32_t serial,
+        struct ::wl_surface *surface)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_enter(
+            serial,
+            surface);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_leave(uint32_t , struct ::wl_surface *)
+    {
+    }
+
+    void zwp_text_input_v2::handle_leave(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        uint32_t serial,
+        struct ::wl_surface *surface)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_leave(
+            serial,
+            surface);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_input_panel_state(uint32_t , int32_t , int32_t , int32_t , int32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_input_panel_state(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        uint32_t state,
+        int32_t x,
+        int32_t y,
+        int32_t width,
+        int32_t height)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_input_panel_state(
+            state,
+            x,
+            y,
+            width,
+            height);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_preedit_string(const QString &, const QString &)
+    {
+    }
+
+    void zwp_text_input_v2::handle_preedit_string(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        const char *text,
+        const char *commit)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_preedit_string(
+            QString::fromUtf8(text),
+            QString::fromUtf8(commit));
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_preedit_styling(uint32_t , uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_preedit_styling(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        uint32_t index,
+        uint32_t length,
+        uint32_t style)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_preedit_styling(
+            index,
+            length,
+            style);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_preedit_cursor(int32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_preedit_cursor(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        int32_t index)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_preedit_cursor(
+            index);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_commit_string(const QString &)
+    {
+    }
+
+    void zwp_text_input_v2::handle_commit_string(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        const char *text)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_commit_string(
+            QString::fromUtf8(text));
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_cursor_position(int32_t , int32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_cursor_position(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        int32_t index,
+        int32_t anchor)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_cursor_position(
+            index,
+            anchor);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_delete_surrounding_text(uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_delete_surrounding_text(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        uint32_t before_length,
+        uint32_t after_length)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_delete_surrounding_text(
+            before_length,
+            after_length);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_modifiers_map(wl_array *)
+    {
+    }
+
+    void zwp_text_input_v2::handle_modifiers_map(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        wl_array *map)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_modifiers_map(
+            map);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_keysym(uint32_t , uint32_t , uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_keysym(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        uint32_t time,
+        uint32_t sym,
+        uint32_t state,
+        uint32_t modifiers)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_keysym(
+            time,
+            sym,
+            state,
+            modifiers);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_language(const QString &)
+    {
+    }
+
+    void zwp_text_input_v2::handle_language(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        const char *language)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_language(
+            QString::fromUtf8(language));
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_text_direction(uint32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_text_direction(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        uint32_t direction)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_text_direction(
+            direction);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_configure_surrounding_text(int32_t , int32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_configure_surrounding_text(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        int32_t before_cursor,
+        int32_t after_cursor)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_configure_surrounding_text(
+            before_cursor,
+            after_cursor);
+    }
+
+    void zwp_text_input_v2::zwp_text_input_v2_input_method_changed(uint32_t , uint32_t )
+    {
+    }
+
+    void zwp_text_input_v2::handle_input_method_changed(
+        void *data,
+        struct ::zwp_text_input_v2 *object,
+        uint32_t serial,
+        uint32_t flags)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_text_input_v2 *>(data)->zwp_text_input_v2_input_method_changed(
+            serial,
+            flags);
+    }
+
+    const struct zwp_text_input_v2_listener zwp_text_input_v2::m_zwp_text_input_v2_listener = {
+        zwp_text_input_v2::handle_enter,
+        zwp_text_input_v2::handle_leave,
+        zwp_text_input_v2::handle_input_panel_state,
+        zwp_text_input_v2::handle_preedit_string,
+        zwp_text_input_v2::handle_preedit_styling,
+        zwp_text_input_v2::handle_preedit_cursor,
+        zwp_text_input_v2::handle_commit_string,
+        zwp_text_input_v2::handle_cursor_position,
+        zwp_text_input_v2::handle_delete_surrounding_text,
+        zwp_text_input_v2::handle_modifiers_map,
+        zwp_text_input_v2::handle_keysym,
+        zwp_text_input_v2::handle_language,
+        zwp_text_input_v2::handle_text_direction,
+        zwp_text_input_v2::handle_configure_surrounding_text,
+        zwp_text_input_v2::handle_input_method_changed,
+    };
+
+    void zwp_text_input_v2::init_listener()
+    {
+        zwp_text_input_v2_add_listener(m_zwp_text_input_v2, &m_zwp_text_input_v2_listener, this);
+    }
+
+    zwp_text_input_manager_v2::zwp_text_input_manager_v2(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_text_input_manager_v2::zwp_text_input_manager_v2(struct ::zwp_text_input_manager_v2 *obj)
+        : m_zwp_text_input_manager_v2(obj)
+    {
+    }
+
+    zwp_text_input_manager_v2::zwp_text_input_manager_v2()
+        : m_zwp_text_input_manager_v2(nullptr)
+    {
+    }
+
+    zwp_text_input_manager_v2::~zwp_text_input_manager_v2()
+    {
+    }
+
+    void zwp_text_input_manager_v2::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_text_input_manager_v2 = static_cast<struct ::zwp_text_input_manager_v2 *>(wlRegistryBind(registry, id, &zwp_text_input_manager_v2_interface, version));
+    }
+
+    void zwp_text_input_manager_v2::init(struct ::zwp_text_input_manager_v2 *obj)
+    {
+        m_zwp_text_input_manager_v2 = obj;
+    }
+
+    zwp_text_input_manager_v2 *zwp_text_input_manager_v2::fromObject(struct ::zwp_text_input_manager_v2 *object)
+    {
+        return static_cast<zwp_text_input_manager_v2 *>(zwp_text_input_manager_v2_get_user_data(object));
+    }
+
+    bool zwp_text_input_manager_v2::isInitialized() const
+    {
+        return m_zwp_text_input_manager_v2 != nullptr;
+    }
+
+    const struct wl_interface *zwp_text_input_manager_v2::interface()
+    {
+        return &::zwp_text_input_manager_v2_interface;
+    }
+
+    void zwp_text_input_manager_v2::destroy()
+    {
+        zwp_text_input_manager_v2_destroy(
+            m_zwp_text_input_manager_v2);
+        m_zwp_text_input_manager_v2 = nullptr;
+    }
+
+    struct ::zwp_text_input_v2 *zwp_text_input_manager_v2::get_text_input(struct ::wl_seat *seat)
+    {
+        return zwp_text_input_manager_v2_get_text_input(
+            m_zwp_text_input_manager_v2,
+            seat);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-text-input-unstable-v2.h b/src/client/qwayland-text-input-unstable-v2.h
new file mode 100644
index 0000000000000000000000000000000000000000..7a9667e0d43583f71b1c2dde8cc162f4e615bd54
--- /dev/null
+++ a/qtwayland/src/client/qwayland-text-input-unstable-v2.h
@@ -0,0 +1,246 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/text-input-unstable-v2.xml
+
+#ifndef QT_WAYLAND_TEXT_INPUT_UNSTABLE_V2
+#define QT_WAYLAND_TEXT_INPUT_UNSTABLE_V2
+
+#include <QtWaylandClient/private/wayland-text-input-unstable-v2-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_TEXT_INPUT_UNSTABLE_V2_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_TEXT_INPUT_UNSTABLE_V2_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_TEXT_INPUT_UNSTABLE_V2_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_TEXT_INPUT_UNSTABLE_V2_EXPORT zwp_text_input_v2
+    {
+    public:
+        zwp_text_input_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_text_input_v2(struct ::zwp_text_input_v2 *object);
+        zwp_text_input_v2();
+
+        virtual ~zwp_text_input_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_text_input_v2 *object);
+
+        struct ::zwp_text_input_v2 *object() { return m_zwp_text_input_v2; }
+        const struct ::zwp_text_input_v2 *object() const { return m_zwp_text_input_v2; }
+        static zwp_text_input_v2 *fromObject(struct ::zwp_text_input_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum content_hint {
+            content_hint_none = 0x0, // no special behaviour
+            content_hint_auto_completion = 0x1, // suggest word completions
+            content_hint_auto_correction = 0x2, // suggest word corrections
+            content_hint_auto_capitalization = 0x4, // switch to uppercase letters at the start of a sentence
+            content_hint_lowercase = 0x8, // prefer lowercase letters
+            content_hint_uppercase = 0x10, // prefer uppercase letters
+            content_hint_titlecase = 0x20, // prefer casing for titles and headings (can be language dependent)
+            content_hint_hidden_text = 0x40, // characters should be hidden
+            content_hint_sensitive_data = 0x80, // typed text should not be stored
+            content_hint_latin = 0x100, // just latin characters should be entered
+            content_hint_multiline = 0x200, // the text input is multiline
+        };
+
+        enum content_purpose {
+            content_purpose_normal = 0, // default input, allowing all characters
+            content_purpose_alpha = 1, // allow only alphabetic characters
+            content_purpose_digits = 2, // allow only digits
+            content_purpose_number = 3, // input a number (including decimal separator and sign)
+            content_purpose_phone = 4, // input a phone number
+            content_purpose_url = 5, // input an URL
+            content_purpose_email = 6, // input an email address
+            content_purpose_name = 7, // input a name of a person
+            content_purpose_password = 8, // input a password (combine with password or sensitive_data hint)
+            content_purpose_date = 9, // input a date
+            content_purpose_time = 10, // input a time
+            content_purpose_datetime = 11, // input a date and time
+            content_purpose_terminal = 12, // input for a terminal
+        };
+
+        enum update_state {
+            update_state_change = 0, // updated state because it changed
+            update_state_full = 1, // full state after enter or input_method_changed event
+            update_state_reset = 2, // full state after reset
+            update_state_enter = 3, // full state after switching focus to a different widget on client side
+        };
+
+        enum input_panel_visibility {
+            input_panel_visibility_hidden = 0, // the input panel (virtual keyboard) is hidden
+            input_panel_visibility_visible = 1, // the input panel (virtual keyboard) is visible
+        };
+
+        enum preedit_style {
+            preedit_style_default = 0, // default style for composing text
+            preedit_style_none = 1, // composing text should be shown the same as non-composing text
+            preedit_style_active = 2, // composing text might be bold
+            preedit_style_inactive = 3, // composing text might be cursive
+            preedit_style_highlight = 4, // composing text might have a different background color
+            preedit_style_underline = 5, // composing text might be underlined
+            preedit_style_selection = 6, // composing text should be shown the same as selected text
+            preedit_style_incorrect = 7, // composing text might be underlined with a red wavy line
+        };
+
+        enum text_direction {
+            text_direction_auto = 0, // automatic text direction based on text and language
+            text_direction_ltr = 1, // left-to-right
+            text_direction_rtl = 2, // right-to-left
+        };
+
+        void destroy();
+        void enable(struct ::wl_surface *surface);
+        void disable(struct ::wl_surface *surface);
+        void show_input_panel();
+        void hide_input_panel();
+        void set_surrounding_text(const QString &text, int32_t cursor, int32_t anchor);
+        void set_content_type(uint32_t hint, uint32_t purpose);
+        void set_cursor_rectangle(int32_t x, int32_t y, int32_t width, int32_t height);
+        void set_preferred_language(const QString &language);
+        void update_state(uint32_t serial, uint32_t reason);
+
+    protected:
+        virtual void zwp_text_input_v2_enter(uint32_t serial, struct ::wl_surface *surface);
+        virtual void zwp_text_input_v2_leave(uint32_t serial, struct ::wl_surface *surface);
+        virtual void zwp_text_input_v2_input_panel_state(uint32_t state, int32_t x, int32_t y, int32_t width, int32_t height);
+        virtual void zwp_text_input_v2_preedit_string(const QString &text, const QString &commit);
+        virtual void zwp_text_input_v2_preedit_styling(uint32_t index, uint32_t length, uint32_t style);
+        virtual void zwp_text_input_v2_preedit_cursor(int32_t index);
+        virtual void zwp_text_input_v2_commit_string(const QString &text);
+        virtual void zwp_text_input_v2_cursor_position(int32_t index, int32_t anchor);
+        virtual void zwp_text_input_v2_delete_surrounding_text(uint32_t before_length, uint32_t after_length);
+        virtual void zwp_text_input_v2_modifiers_map(wl_array *map);
+        virtual void zwp_text_input_v2_keysym(uint32_t time, uint32_t sym, uint32_t state, uint32_t modifiers);
+        virtual void zwp_text_input_v2_language(const QString &language);
+        virtual void zwp_text_input_v2_text_direction(uint32_t direction);
+        virtual void zwp_text_input_v2_configure_surrounding_text(int32_t before_cursor, int32_t after_cursor);
+        virtual void zwp_text_input_v2_input_method_changed(uint32_t serial, uint32_t flags);
+
+    private:
+        void init_listener();
+        static const struct zwp_text_input_v2_listener m_zwp_text_input_v2_listener;
+        static void handle_enter(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            uint32_t serial,
+            struct ::wl_surface *surface);
+        static void handle_leave(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            uint32_t serial,
+            struct ::wl_surface *surface);
+        static void handle_input_panel_state(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            uint32_t state,
+            int32_t x,
+            int32_t y,
+            int32_t width,
+            int32_t height);
+        static void handle_preedit_string(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            const char *text,
+            const char *commit);
+        static void handle_preedit_styling(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            uint32_t index,
+            uint32_t length,
+            uint32_t style);
+        static void handle_preedit_cursor(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            int32_t index);
+        static void handle_commit_string(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            const char *text);
+        static void handle_cursor_position(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            int32_t index,
+            int32_t anchor);
+        static void handle_delete_surrounding_text(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            uint32_t before_length,
+            uint32_t after_length);
+        static void handle_modifiers_map(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            wl_array *map);
+        static void handle_keysym(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            uint32_t time,
+            uint32_t sym,
+            uint32_t state,
+            uint32_t modifiers);
+        static void handle_language(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            const char *language);
+        static void handle_text_direction(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            uint32_t direction);
+        static void handle_configure_surrounding_text(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            int32_t before_cursor,
+            int32_t after_cursor);
+        static void handle_input_method_changed(
+            void *data,
+            struct ::zwp_text_input_v2 *object,
+            uint32_t serial,
+            uint32_t flags);
+        struct ::zwp_text_input_v2 *m_zwp_text_input_v2;
+    };
+
+    class Q_WAYLAND_CLIENT_TEXT_INPUT_UNSTABLE_V2_EXPORT zwp_text_input_manager_v2
+    {
+    public:
+        zwp_text_input_manager_v2(struct ::wl_registry *registry, int id, int version);
+        zwp_text_input_manager_v2(struct ::zwp_text_input_manager_v2 *object);
+        zwp_text_input_manager_v2();
+
+        virtual ~zwp_text_input_manager_v2();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_text_input_manager_v2 *object);
+
+        struct ::zwp_text_input_manager_v2 *object() { return m_zwp_text_input_manager_v2; }
+        const struct ::zwp_text_input_manager_v2 *object() const { return m_zwp_text_input_manager_v2; }
+        static zwp_text_input_manager_v2 *fromObject(struct ::zwp_text_input_manager_v2 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+        struct ::zwp_text_input_v2 *get_text_input(struct ::wl_seat *seat);
+
+    private:
+        struct ::zwp_text_input_manager_v2 *m_zwp_text_input_manager_v2;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-touch-extension.cpp b/src/client/qwayland-touch-extension.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..dd881526bd847c6ac5db159c44a880e227fa86ee
--- /dev/null
+++ a/qtwayland/src/client/qwayland-touch-extension.cpp
@@ -0,0 +1,145 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/touch-extension.xml
+
+#include <QtWaylandClient/private/qwayland-touch-extension.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    qt_touch_extension::qt_touch_extension(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    qt_touch_extension::qt_touch_extension(struct ::qt_touch_extension *obj)
+        : m_qt_touch_extension(obj)
+    {
+        init_listener();
+    }
+
+    qt_touch_extension::qt_touch_extension()
+        : m_qt_touch_extension(nullptr)
+    {
+    }
+
+    qt_touch_extension::~qt_touch_extension()
+    {
+    }
+
+    void qt_touch_extension::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_qt_touch_extension = static_cast<struct ::qt_touch_extension *>(wlRegistryBind(registry, id, &qt_touch_extension_interface, version));
+        init_listener();
+    }
+
+    void qt_touch_extension::init(struct ::qt_touch_extension *obj)
+    {
+        m_qt_touch_extension = obj;
+        init_listener();
+    }
+
+    qt_touch_extension *qt_touch_extension::fromObject(struct ::qt_touch_extension *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_qt_touch_extension_listener)
+            return nullptr;
+        return static_cast<qt_touch_extension *>(qt_touch_extension_get_user_data(object));
+    }
+
+    bool qt_touch_extension::isInitialized() const
+    {
+        return m_qt_touch_extension != nullptr;
+    }
+
+    const struct wl_interface *qt_touch_extension::interface()
+    {
+        return &::qt_touch_extension_interface;
+    }
+
+    void qt_touch_extension::dummy()
+    {
+        qt_touch_extension_dummy(
+            m_qt_touch_extension);
+    }
+
+    void qt_touch_extension::touch_extension_touch(uint32_t , uint32_t , uint32_t , int32_t , int32_t , int32_t , int32_t , int32_t , int32_t , uint32_t , int32_t , int32_t , uint32_t , wl_array *)
+    {
+    }
+
+    void qt_touch_extension::handle_touch(
+        void *data,
+        struct ::qt_touch_extension *object,
+        uint32_t time,
+        uint32_t id,
+        uint32_t state,
+        int32_t x,
+        int32_t y,
+        int32_t normalized_x,
+        int32_t normalized_y,
+        int32_t width,
+        int32_t height,
+        uint32_t pressure,
+        int32_t velocity_x,
+        int32_t velocity_y,
+        uint32_t flags,
+        wl_array *rawdata)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_touch_extension *>(data)->touch_extension_touch(
+            time,
+            id,
+            state,
+            x,
+            y,
+            normalized_x,
+            normalized_y,
+            width,
+            height,
+            pressure,
+            velocity_x,
+            velocity_y,
+            flags,
+            rawdata);
+    }
+
+    void qt_touch_extension::touch_extension_configure(uint32_t )
+    {
+    }
+
+    void qt_touch_extension::handle_configure(
+        void *data,
+        struct ::qt_touch_extension *object,
+        uint32_t flags)
+    {
+        Q_UNUSED(object);
+        static_cast<qt_touch_extension *>(data)->touch_extension_configure(
+            flags);
+    }
+
+    const struct qt_touch_extension_listener qt_touch_extension::m_qt_touch_extension_listener = {
+        qt_touch_extension::handle_touch,
+        qt_touch_extension::handle_configure,
+    };
+
+    void qt_touch_extension::init_listener()
+    {
+        qt_touch_extension_add_listener(m_qt_touch_extension, &m_qt_touch_extension_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-touch-extension.h b/src/client/qwayland-touch-extension.h
new file mode 100644
index 0000000000000000000000000000000000000000..01f31e54e7271384d6a243bac1a851a59086cfb9
--- /dev/null
+++ a/qtwayland/src/client/qwayland-touch-extension.h
@@ -0,0 +1,87 @@
+// This file was generated by qtwaylandscanner
+// source file is ../extensions/touch-extension.xml
+
+#ifndef QT_WAYLAND_TOUCH_EXTENSION
+#define QT_WAYLAND_TOUCH_EXTENSION
+
+#include <QtWaylandClient/private/wayland-touch-extension-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_TOUCH_EXTENSION_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_TOUCH_EXTENSION_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_TOUCH_EXTENSION_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_TOUCH_EXTENSION_EXPORT qt_touch_extension
+    {
+    public:
+        qt_touch_extension(struct ::wl_registry *registry, int id, int version);
+        qt_touch_extension(struct ::qt_touch_extension *object);
+        qt_touch_extension();
+
+        virtual ~qt_touch_extension();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::qt_touch_extension *object);
+
+        struct ::qt_touch_extension *object() { return m_qt_touch_extension; }
+        const struct ::qt_touch_extension *object() const { return m_qt_touch_extension; }
+        static qt_touch_extension *fromObject(struct ::qt_touch_extension *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum flags {
+            flags_mouse_from_touch = 0x1,
+        };
+
+        void dummy();
+
+    protected:
+        virtual void touch_extension_touch(uint32_t time, uint32_t id, uint32_t state, int32_t x, int32_t y, int32_t normalized_x, int32_t normalized_y, int32_t width, int32_t height, uint32_t pressure, int32_t velocity_x, int32_t velocity_y, uint32_t flags, wl_array *rawdata);
+        virtual void touch_extension_configure(uint32_t flags);
+
+    private:
+        void init_listener();
+        static const struct qt_touch_extension_listener m_qt_touch_extension_listener;
+        static void handle_touch(
+            void *data,
+            struct ::qt_touch_extension *object,
+            uint32_t time,
+            uint32_t id,
+            uint32_t state,
+            int32_t x,
+            int32_t y,
+            int32_t normalized_x,
+            int32_t normalized_y,
+            int32_t width,
+            int32_t height,
+            uint32_t pressure,
+            int32_t velocity_x,
+            int32_t velocity_y,
+            uint32_t flags,
+            wl_array *rawdata);
+        static void handle_configure(
+            void *data,
+            struct ::qt_touch_extension *object,
+            uint32_t flags);
+        struct ::qt_touch_extension *m_qt_touch_extension;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-wayland.cpp b/src/client/qwayland-wayland.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..13f2d82115f024473621846955df08e114673ca0
--- /dev/null
+++ a/qtwayland/src/client/qwayland-wayland.cpp
@@ -0,0 +1,2493 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/wayland.xml
+
+#include <QtWaylandClient/private/qwayland-wayland.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    wl_registry::wl_registry(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_registry::wl_registry(struct ::wl_registry *obj)
+        : m_wl_registry(obj)
+    {
+        init_listener();
+    }
+
+    wl_registry::wl_registry()
+        : m_wl_registry(nullptr)
+    {
+    }
+
+    wl_registry::~wl_registry()
+    {
+    }
+
+    void wl_registry::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_registry = static_cast<struct ::wl_registry *>(wlRegistryBind(registry, id, &wl_registry_interface, version));
+        init_listener();
+    }
+
+    void wl_registry::init(struct ::wl_registry *obj)
+    {
+        m_wl_registry = obj;
+        init_listener();
+    }
+
+    wl_registry *wl_registry::fromObject(struct ::wl_registry *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_registry_listener)
+            return nullptr;
+        return static_cast<wl_registry *>(wl_registry_get_user_data(object));
+    }
+
+    bool wl_registry::isInitialized() const
+    {
+        return m_wl_registry != nullptr;
+    }
+
+    const struct wl_interface *wl_registry::interface()
+    {
+        return &::wl_registry_interface;
+    }
+
+    void *wl_registry::bind(uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+    {
+        return wl_registry_bind(
+            m_wl_registry,
+            name,
+            interface,
+            version);
+    }
+
+    void wl_registry::registry_global(uint32_t , const QString &, uint32_t )
+    {
+    }
+
+    void wl_registry::handle_global(
+        void *data,
+        struct ::wl_registry *object,
+        uint32_t name,
+        const char *interface,
+        uint32_t version)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_registry *>(data)->registry_global(
+            name,
+            QString::fromUtf8(interface),
+            version);
+    }
+
+    void wl_registry::registry_global_remove(uint32_t )
+    {
+    }
+
+    void wl_registry::handle_global_remove(
+        void *data,
+        struct ::wl_registry *object,
+        uint32_t name)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_registry *>(data)->registry_global_remove(
+            name);
+    }
+
+    const struct wl_registry_listener wl_registry::m_wl_registry_listener = {
+        wl_registry::handle_global,
+        wl_registry::handle_global_remove,
+    };
+
+    void wl_registry::init_listener()
+    {
+        wl_registry_add_listener(m_wl_registry, &m_wl_registry_listener, this);
+    }
+
+    wl_callback::wl_callback(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_callback::wl_callback(struct ::wl_callback *obj)
+        : m_wl_callback(obj)
+    {
+        init_listener();
+    }
+
+    wl_callback::wl_callback()
+        : m_wl_callback(nullptr)
+    {
+    }
+
+    wl_callback::~wl_callback()
+    {
+    }
+
+    void wl_callback::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_callback = static_cast<struct ::wl_callback *>(wlRegistryBind(registry, id, &wl_callback_interface, version));
+        init_listener();
+    }
+
+    void wl_callback::init(struct ::wl_callback *obj)
+    {
+        m_wl_callback = obj;
+        init_listener();
+    }
+
+    wl_callback *wl_callback::fromObject(struct ::wl_callback *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_callback_listener)
+            return nullptr;
+        return static_cast<wl_callback *>(wl_callback_get_user_data(object));
+    }
+
+    bool wl_callback::isInitialized() const
+    {
+        return m_wl_callback != nullptr;
+    }
+
+    const struct wl_interface *wl_callback::interface()
+    {
+        return &::wl_callback_interface;
+    }
+
+    void wl_callback::callback_done(uint32_t )
+    {
+    }
+
+    void wl_callback::handle_done(
+        void *data,
+        struct ::wl_callback *object,
+        uint32_t callback_data)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_callback *>(data)->callback_done(
+            callback_data);
+    }
+
+    const struct wl_callback_listener wl_callback::m_wl_callback_listener = {
+        wl_callback::handle_done,
+    };
+
+    void wl_callback::init_listener()
+    {
+        wl_callback_add_listener(m_wl_callback, &m_wl_callback_listener, this);
+    }
+
+    wl_compositor::wl_compositor(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_compositor::wl_compositor(struct ::wl_compositor *obj)
+        : m_wl_compositor(obj)
+    {
+    }
+
+    wl_compositor::wl_compositor()
+        : m_wl_compositor(nullptr)
+    {
+    }
+
+    wl_compositor::~wl_compositor()
+    {
+    }
+
+    void wl_compositor::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_compositor = static_cast<struct ::wl_compositor *>(wlRegistryBind(registry, id, &wl_compositor_interface, version));
+    }
+
+    void wl_compositor::init(struct ::wl_compositor *obj)
+    {
+        m_wl_compositor = obj;
+    }
+
+    wl_compositor *wl_compositor::fromObject(struct ::wl_compositor *object)
+    {
+        return static_cast<wl_compositor *>(wl_compositor_get_user_data(object));
+    }
+
+    bool wl_compositor::isInitialized() const
+    {
+        return m_wl_compositor != nullptr;
+    }
+
+    const struct wl_interface *wl_compositor::interface()
+    {
+        return &::wl_compositor_interface;
+    }
+
+    struct ::wl_surface *wl_compositor::create_surface()
+    {
+        return wl_compositor_create_surface(
+            m_wl_compositor);
+    }
+
+    struct ::wl_region *wl_compositor::create_region()
+    {
+        return wl_compositor_create_region(
+            m_wl_compositor);
+    }
+
+    wl_shm_pool::wl_shm_pool(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_shm_pool::wl_shm_pool(struct ::wl_shm_pool *obj)
+        : m_wl_shm_pool(obj)
+    {
+    }
+
+    wl_shm_pool::wl_shm_pool()
+        : m_wl_shm_pool(nullptr)
+    {
+    }
+
+    wl_shm_pool::~wl_shm_pool()
+    {
+    }
+
+    void wl_shm_pool::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_shm_pool = static_cast<struct ::wl_shm_pool *>(wlRegistryBind(registry, id, &wl_shm_pool_interface, version));
+    }
+
+    void wl_shm_pool::init(struct ::wl_shm_pool *obj)
+    {
+        m_wl_shm_pool = obj;
+    }
+
+    wl_shm_pool *wl_shm_pool::fromObject(struct ::wl_shm_pool *object)
+    {
+        return static_cast<wl_shm_pool *>(wl_shm_pool_get_user_data(object));
+    }
+
+    bool wl_shm_pool::isInitialized() const
+    {
+        return m_wl_shm_pool != nullptr;
+    }
+
+    const struct wl_interface *wl_shm_pool::interface()
+    {
+        return &::wl_shm_pool_interface;
+    }
+
+    struct ::wl_buffer *wl_shm_pool::create_buffer(int32_t offset, int32_t width, int32_t height, int32_t stride, uint32_t format)
+    {
+        return wl_shm_pool_create_buffer(
+            m_wl_shm_pool,
+            offset,
+            width,
+            height,
+            stride,
+            format);
+    }
+
+    void wl_shm_pool::destroy()
+    {
+        wl_shm_pool_destroy(
+            m_wl_shm_pool);
+        m_wl_shm_pool = nullptr;
+    }
+
+    void wl_shm_pool::resize(int32_t size)
+    {
+        wl_shm_pool_resize(
+            m_wl_shm_pool,
+            size);
+    }
+
+    wl_shm::wl_shm(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_shm::wl_shm(struct ::wl_shm *obj)
+        : m_wl_shm(obj)
+    {
+        init_listener();
+    }
+
+    wl_shm::wl_shm()
+        : m_wl_shm(nullptr)
+    {
+    }
+
+    wl_shm::~wl_shm()
+    {
+    }
+
+    void wl_shm::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_shm = static_cast<struct ::wl_shm *>(wlRegistryBind(registry, id, &wl_shm_interface, version));
+        init_listener();
+    }
+
+    void wl_shm::init(struct ::wl_shm *obj)
+    {
+        m_wl_shm = obj;
+        init_listener();
+    }
+
+    wl_shm *wl_shm::fromObject(struct ::wl_shm *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_shm_listener)
+            return nullptr;
+        return static_cast<wl_shm *>(wl_shm_get_user_data(object));
+    }
+
+    bool wl_shm::isInitialized() const
+    {
+        return m_wl_shm != nullptr;
+    }
+
+    const struct wl_interface *wl_shm::interface()
+    {
+        return &::wl_shm_interface;
+    }
+
+    struct ::wl_shm_pool *wl_shm::create_pool(int32_t fd, int32_t size)
+    {
+        return wl_shm_create_pool(
+            m_wl_shm,
+            fd,
+            size);
+    }
+
+    void wl_shm::shm_format(uint32_t )
+    {
+    }
+
+    void wl_shm::handle_format(
+        void *data,
+        struct ::wl_shm *object,
+        uint32_t format)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_shm *>(data)->shm_format(
+            format);
+    }
+
+    const struct wl_shm_listener wl_shm::m_wl_shm_listener = {
+        wl_shm::handle_format,
+    };
+
+    void wl_shm::init_listener()
+    {
+        wl_shm_add_listener(m_wl_shm, &m_wl_shm_listener, this);
+    }
+
+    wl_buffer::wl_buffer(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_buffer::wl_buffer(struct ::wl_buffer *obj)
+        : m_wl_buffer(obj)
+    {
+        init_listener();
+    }
+
+    wl_buffer::wl_buffer()
+        : m_wl_buffer(nullptr)
+    {
+    }
+
+    wl_buffer::~wl_buffer()
+    {
+    }
+
+    void wl_buffer::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_buffer = static_cast<struct ::wl_buffer *>(wlRegistryBind(registry, id, &wl_buffer_interface, version));
+        init_listener();
+    }
+
+    void wl_buffer::init(struct ::wl_buffer *obj)
+    {
+        m_wl_buffer = obj;
+        init_listener();
+    }
+
+    wl_buffer *wl_buffer::fromObject(struct ::wl_buffer *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_buffer_listener)
+            return nullptr;
+        return static_cast<wl_buffer *>(wl_buffer_get_user_data(object));
+    }
+
+    bool wl_buffer::isInitialized() const
+    {
+        return m_wl_buffer != nullptr;
+    }
+
+    const struct wl_interface *wl_buffer::interface()
+    {
+        return &::wl_buffer_interface;
+    }
+
+    void wl_buffer::destroy()
+    {
+        wl_buffer_destroy(
+            m_wl_buffer);
+        m_wl_buffer = nullptr;
+    }
+
+    void wl_buffer::buffer_release()
+    {
+    }
+
+    void wl_buffer::handle_release(
+        void *data,
+        struct ::wl_buffer *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_buffer *>(data)->buffer_release();
+    }
+
+    const struct wl_buffer_listener wl_buffer::m_wl_buffer_listener = {
+        wl_buffer::handle_release,
+    };
+
+    void wl_buffer::init_listener()
+    {
+        wl_buffer_add_listener(m_wl_buffer, &m_wl_buffer_listener, this);
+    }
+
+    wl_data_offer::wl_data_offer(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_data_offer::wl_data_offer(struct ::wl_data_offer *obj)
+        : m_wl_data_offer(obj)
+    {
+        init_listener();
+    }
+
+    wl_data_offer::wl_data_offer()
+        : m_wl_data_offer(nullptr)
+    {
+    }
+
+    wl_data_offer::~wl_data_offer()
+    {
+    }
+
+    void wl_data_offer::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_data_offer = static_cast<struct ::wl_data_offer *>(wlRegistryBind(registry, id, &wl_data_offer_interface, version));
+        init_listener();
+    }
+
+    void wl_data_offer::init(struct ::wl_data_offer *obj)
+    {
+        m_wl_data_offer = obj;
+        init_listener();
+    }
+
+    wl_data_offer *wl_data_offer::fromObject(struct ::wl_data_offer *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_data_offer_listener)
+            return nullptr;
+        return static_cast<wl_data_offer *>(wl_data_offer_get_user_data(object));
+    }
+
+    bool wl_data_offer::isInitialized() const
+    {
+        return m_wl_data_offer != nullptr;
+    }
+
+    const struct wl_interface *wl_data_offer::interface()
+    {
+        return &::wl_data_offer_interface;
+    }
+
+    void wl_data_offer::accept(uint32_t serial, const QString &mime_type)
+    {
+        wl_data_offer_accept(
+            m_wl_data_offer,
+            serial,
+            mime_type.toUtf8().constData());
+    }
+
+    void wl_data_offer::receive(const QString &mime_type, int32_t fd)
+    {
+        wl_data_offer_receive(
+            m_wl_data_offer,
+            mime_type.toUtf8().constData(),
+            fd);
+    }
+
+    void wl_data_offer::destroy()
+    {
+        wl_data_offer_destroy(
+            m_wl_data_offer);
+        m_wl_data_offer = nullptr;
+    }
+
+    void wl_data_offer::finish()
+    {
+        wl_data_offer_finish(
+            m_wl_data_offer);
+    }
+
+    void wl_data_offer::set_actions(uint32_t dnd_actions, uint32_t preferred_action)
+    {
+        wl_data_offer_set_actions(
+            m_wl_data_offer,
+            dnd_actions,
+            preferred_action);
+    }
+
+    void wl_data_offer::data_offer_offer(const QString &)
+    {
+    }
+
+    void wl_data_offer::handle_offer(
+        void *data,
+        struct ::wl_data_offer *object,
+        const char *mime_type)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_offer *>(data)->data_offer_offer(
+            QString::fromUtf8(mime_type));
+    }
+
+    void wl_data_offer::data_offer_source_actions(uint32_t )
+    {
+    }
+
+    void wl_data_offer::handle_source_actions(
+        void *data,
+        struct ::wl_data_offer *object,
+        uint32_t source_actions)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_offer *>(data)->data_offer_source_actions(
+            source_actions);
+    }
+
+    void wl_data_offer::data_offer_action(uint32_t )
+    {
+    }
+
+    void wl_data_offer::handle_action(
+        void *data,
+        struct ::wl_data_offer *object,
+        uint32_t dnd_action)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_offer *>(data)->data_offer_action(
+            dnd_action);
+    }
+
+    const struct wl_data_offer_listener wl_data_offer::m_wl_data_offer_listener = {
+        wl_data_offer::handle_offer,
+        wl_data_offer::handle_source_actions,
+        wl_data_offer::handle_action,
+    };
+
+    void wl_data_offer::init_listener()
+    {
+        wl_data_offer_add_listener(m_wl_data_offer, &m_wl_data_offer_listener, this);
+    }
+
+    wl_data_source::wl_data_source(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_data_source::wl_data_source(struct ::wl_data_source *obj)
+        : m_wl_data_source(obj)
+    {
+        init_listener();
+    }
+
+    wl_data_source::wl_data_source()
+        : m_wl_data_source(nullptr)
+    {
+    }
+
+    wl_data_source::~wl_data_source()
+    {
+    }
+
+    void wl_data_source::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_data_source = static_cast<struct ::wl_data_source *>(wlRegistryBind(registry, id, &wl_data_source_interface, version));
+        init_listener();
+    }
+
+    void wl_data_source::init(struct ::wl_data_source *obj)
+    {
+        m_wl_data_source = obj;
+        init_listener();
+    }
+
+    wl_data_source *wl_data_source::fromObject(struct ::wl_data_source *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_data_source_listener)
+            return nullptr;
+        return static_cast<wl_data_source *>(wl_data_source_get_user_data(object));
+    }
+
+    bool wl_data_source::isInitialized() const
+    {
+        return m_wl_data_source != nullptr;
+    }
+
+    const struct wl_interface *wl_data_source::interface()
+    {
+        return &::wl_data_source_interface;
+    }
+
+    void wl_data_source::offer(const QString &mime_type)
+    {
+        wl_data_source_offer(
+            m_wl_data_source,
+            mime_type.toUtf8().constData());
+    }
+
+    void wl_data_source::destroy()
+    {
+        wl_data_source_destroy(
+            m_wl_data_source);
+        m_wl_data_source = nullptr;
+    }
+
+    void wl_data_source::set_actions(uint32_t dnd_actions)
+    {
+        wl_data_source_set_actions(
+            m_wl_data_source,
+            dnd_actions);
+    }
+
+    void wl_data_source::data_source_target(const QString &)
+    {
+    }
+
+    void wl_data_source::handle_target(
+        void *data,
+        struct ::wl_data_source *object,
+        const char *mime_type)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_source *>(data)->data_source_target(
+            QString::fromUtf8(mime_type));
+    }
+
+    void wl_data_source::data_source_send(const QString &, int32_t )
+    {
+    }
+
+    void wl_data_source::handle_send(
+        void *data,
+        struct ::wl_data_source *object,
+        const char *mime_type,
+        int32_t fd)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_source *>(data)->data_source_send(
+            QString::fromUtf8(mime_type),
+            fd);
+    }
+
+    void wl_data_source::data_source_cancelled()
+    {
+    }
+
+    void wl_data_source::handle_cancelled(
+        void *data,
+        struct ::wl_data_source *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_source *>(data)->data_source_cancelled();
+    }
+
+    void wl_data_source::data_source_dnd_drop_performed()
+    {
+    }
+
+    void wl_data_source::handle_dnd_drop_performed(
+        void *data,
+        struct ::wl_data_source *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_source *>(data)->data_source_dnd_drop_performed();
+    }
+
+    void wl_data_source::data_source_dnd_finished()
+    {
+    }
+
+    void wl_data_source::handle_dnd_finished(
+        void *data,
+        struct ::wl_data_source *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_source *>(data)->data_source_dnd_finished();
+    }
+
+    void wl_data_source::data_source_action(uint32_t )
+    {
+    }
+
+    void wl_data_source::handle_action(
+        void *data,
+        struct ::wl_data_source *object,
+        uint32_t dnd_action)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_source *>(data)->data_source_action(
+            dnd_action);
+    }
+
+    const struct wl_data_source_listener wl_data_source::m_wl_data_source_listener = {
+        wl_data_source::handle_target,
+        wl_data_source::handle_send,
+        wl_data_source::handle_cancelled,
+        wl_data_source::handle_dnd_drop_performed,
+        wl_data_source::handle_dnd_finished,
+        wl_data_source::handle_action,
+    };
+
+    void wl_data_source::init_listener()
+    {
+        wl_data_source_add_listener(m_wl_data_source, &m_wl_data_source_listener, this);
+    }
+
+    wl_data_device::wl_data_device(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_data_device::wl_data_device(struct ::wl_data_device *obj)
+        : m_wl_data_device(obj)
+    {
+        init_listener();
+    }
+
+    wl_data_device::wl_data_device()
+        : m_wl_data_device(nullptr)
+    {
+    }
+
+    wl_data_device::~wl_data_device()
+    {
+    }
+
+    void wl_data_device::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_data_device = static_cast<struct ::wl_data_device *>(wlRegistryBind(registry, id, &wl_data_device_interface, version));
+        init_listener();
+    }
+
+    void wl_data_device::init(struct ::wl_data_device *obj)
+    {
+        m_wl_data_device = obj;
+        init_listener();
+    }
+
+    wl_data_device *wl_data_device::fromObject(struct ::wl_data_device *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_data_device_listener)
+            return nullptr;
+        return static_cast<wl_data_device *>(wl_data_device_get_user_data(object));
+    }
+
+    bool wl_data_device::isInitialized() const
+    {
+        return m_wl_data_device != nullptr;
+    }
+
+    const struct wl_interface *wl_data_device::interface()
+    {
+        return &::wl_data_device_interface;
+    }
+
+    void wl_data_device::start_drag(struct ::wl_data_source *source, struct ::wl_surface *origin, struct ::wl_surface *icon, uint32_t serial)
+    {
+        wl_data_device_start_drag(
+            m_wl_data_device,
+            source,
+            origin,
+            icon,
+            serial);
+    }
+
+    void wl_data_device::set_selection(struct ::wl_data_source *source, uint32_t serial)
+    {
+        wl_data_device_set_selection(
+            m_wl_data_device,
+            source,
+            serial);
+    }
+
+    void wl_data_device::release()
+    {
+        wl_data_device_release(
+            m_wl_data_device);
+        m_wl_data_device = nullptr;
+    }
+
+    void wl_data_device::data_device_data_offer(struct ::wl_data_offer *)
+    {
+    }
+
+    void wl_data_device::handle_data_offer(
+        void *data,
+        struct ::wl_data_device *object,
+        struct ::wl_data_offer *id)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_device *>(data)->data_device_data_offer(
+            id);
+    }
+
+    void wl_data_device::data_device_enter(uint32_t , struct ::wl_surface *, wl_fixed_t , wl_fixed_t , struct ::wl_data_offer *)
+    {
+    }
+
+    void wl_data_device::handle_enter(
+        void *data,
+        struct ::wl_data_device *object,
+        uint32_t serial,
+        struct ::wl_surface *surface,
+        wl_fixed_t x,
+        wl_fixed_t y,
+        struct ::wl_data_offer *id)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_device *>(data)->data_device_enter(
+            serial,
+            surface,
+            x,
+            y,
+            id);
+    }
+
+    void wl_data_device::data_device_leave()
+    {
+    }
+
+    void wl_data_device::handle_leave(
+        void *data,
+        struct ::wl_data_device *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_device *>(data)->data_device_leave();
+    }
+
+    void wl_data_device::data_device_motion(uint32_t , wl_fixed_t , wl_fixed_t )
+    {
+    }
+
+    void wl_data_device::handle_motion(
+        void *data,
+        struct ::wl_data_device *object,
+        uint32_t time,
+        wl_fixed_t x,
+        wl_fixed_t y)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_device *>(data)->data_device_motion(
+            time,
+            x,
+            y);
+    }
+
+    void wl_data_device::data_device_drop()
+    {
+    }
+
+    void wl_data_device::handle_drop(
+        void *data,
+        struct ::wl_data_device *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_device *>(data)->data_device_drop();
+    }
+
+    void wl_data_device::data_device_selection(struct ::wl_data_offer *)
+    {
+    }
+
+    void wl_data_device::handle_selection(
+        void *data,
+        struct ::wl_data_device *object,
+        struct ::wl_data_offer *id)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_data_device *>(data)->data_device_selection(
+            id);
+    }
+
+    const struct wl_data_device_listener wl_data_device::m_wl_data_device_listener = {
+        wl_data_device::handle_data_offer,
+        wl_data_device::handle_enter,
+        wl_data_device::handle_leave,
+        wl_data_device::handle_motion,
+        wl_data_device::handle_drop,
+        wl_data_device::handle_selection,
+    };
+
+    void wl_data_device::init_listener()
+    {
+        wl_data_device_add_listener(m_wl_data_device, &m_wl_data_device_listener, this);
+    }
+
+    wl_data_device_manager::wl_data_device_manager(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_data_device_manager::wl_data_device_manager(struct ::wl_data_device_manager *obj)
+        : m_wl_data_device_manager(obj)
+    {
+    }
+
+    wl_data_device_manager::wl_data_device_manager()
+        : m_wl_data_device_manager(nullptr)
+    {
+    }
+
+    wl_data_device_manager::~wl_data_device_manager()
+    {
+    }
+
+    void wl_data_device_manager::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_data_device_manager = static_cast<struct ::wl_data_device_manager *>(wlRegistryBind(registry, id, &wl_data_device_manager_interface, version));
+    }
+
+    void wl_data_device_manager::init(struct ::wl_data_device_manager *obj)
+    {
+        m_wl_data_device_manager = obj;
+    }
+
+    wl_data_device_manager *wl_data_device_manager::fromObject(struct ::wl_data_device_manager *object)
+    {
+        return static_cast<wl_data_device_manager *>(wl_data_device_manager_get_user_data(object));
+    }
+
+    bool wl_data_device_manager::isInitialized() const
+    {
+        return m_wl_data_device_manager != nullptr;
+    }
+
+    const struct wl_interface *wl_data_device_manager::interface()
+    {
+        return &::wl_data_device_manager_interface;
+    }
+
+    struct ::wl_data_source *wl_data_device_manager::create_data_source()
+    {
+        return wl_data_device_manager_create_data_source(
+            m_wl_data_device_manager);
+    }
+
+    struct ::wl_data_device *wl_data_device_manager::get_data_device(struct ::wl_seat *seat)
+    {
+        return wl_data_device_manager_get_data_device(
+            m_wl_data_device_manager,
+            seat);
+    }
+
+    wl_shell::wl_shell(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_shell::wl_shell(struct ::wl_shell *obj)
+        : m_wl_shell(obj)
+    {
+    }
+
+    wl_shell::wl_shell()
+        : m_wl_shell(nullptr)
+    {
+    }
+
+    wl_shell::~wl_shell()
+    {
+    }
+
+    void wl_shell::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_shell = static_cast<struct ::wl_shell *>(wlRegistryBind(registry, id, &wl_shell_interface, version));
+    }
+
+    void wl_shell::init(struct ::wl_shell *obj)
+    {
+        m_wl_shell = obj;
+    }
+
+    wl_shell *wl_shell::fromObject(struct ::wl_shell *object)
+    {
+        return static_cast<wl_shell *>(wl_shell_get_user_data(object));
+    }
+
+    bool wl_shell::isInitialized() const
+    {
+        return m_wl_shell != nullptr;
+    }
+
+    const struct wl_interface *wl_shell::interface()
+    {
+        return &::wl_shell_interface;
+    }
+
+    struct ::wl_shell_surface *wl_shell::get_shell_surface(struct ::wl_surface *surface)
+    {
+        return wl_shell_get_shell_surface(
+            m_wl_shell,
+            surface);
+    }
+
+    wl_shell_surface::wl_shell_surface(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_shell_surface::wl_shell_surface(struct ::wl_shell_surface *obj)
+        : m_wl_shell_surface(obj)
+    {
+        init_listener();
+    }
+
+    wl_shell_surface::wl_shell_surface()
+        : m_wl_shell_surface(nullptr)
+    {
+    }
+
+    wl_shell_surface::~wl_shell_surface()
+    {
+    }
+
+    void wl_shell_surface::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_shell_surface = static_cast<struct ::wl_shell_surface *>(wlRegistryBind(registry, id, &wl_shell_surface_interface, version));
+        init_listener();
+    }
+
+    void wl_shell_surface::init(struct ::wl_shell_surface *obj)
+    {
+        m_wl_shell_surface = obj;
+        init_listener();
+    }
+
+    wl_shell_surface *wl_shell_surface::fromObject(struct ::wl_shell_surface *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_shell_surface_listener)
+            return nullptr;
+        return static_cast<wl_shell_surface *>(wl_shell_surface_get_user_data(object));
+    }
+
+    bool wl_shell_surface::isInitialized() const
+    {
+        return m_wl_shell_surface != nullptr;
+    }
+
+    const struct wl_interface *wl_shell_surface::interface()
+    {
+        return &::wl_shell_surface_interface;
+    }
+
+    void wl_shell_surface::pong(uint32_t serial)
+    {
+        wl_shell_surface_pong(
+            m_wl_shell_surface,
+            serial);
+    }
+
+    void wl_shell_surface::move(struct ::wl_seat *seat, uint32_t serial)
+    {
+        wl_shell_surface_move(
+            m_wl_shell_surface,
+            seat,
+            serial);
+    }
+
+    void wl_shell_surface::resize(struct ::wl_seat *seat, uint32_t serial, uint32_t edges)
+    {
+        wl_shell_surface_resize(
+            m_wl_shell_surface,
+            seat,
+            serial,
+            edges);
+    }
+
+    void wl_shell_surface::set_toplevel()
+    {
+        wl_shell_surface_set_toplevel(
+            m_wl_shell_surface);
+    }
+
+    void wl_shell_surface::set_transient(struct ::wl_surface *parent, int32_t x, int32_t y, uint32_t flags)
+    {
+        wl_shell_surface_set_transient(
+            m_wl_shell_surface,
+            parent,
+            x,
+            y,
+            flags);
+    }
+
+    void wl_shell_surface::set_fullscreen(uint32_t method, uint32_t framerate, struct ::wl_output *output)
+    {
+        wl_shell_surface_set_fullscreen(
+            m_wl_shell_surface,
+            method,
+            framerate,
+            output);
+    }
+
+    void wl_shell_surface::set_popup(struct ::wl_seat *seat, uint32_t serial, struct ::wl_surface *parent, int32_t x, int32_t y, uint32_t flags)
+    {
+        wl_shell_surface_set_popup(
+            m_wl_shell_surface,
+            seat,
+            serial,
+            parent,
+            x,
+            y,
+            flags);
+    }
+
+    void wl_shell_surface::set_maximized(struct ::wl_output *output)
+    {
+        wl_shell_surface_set_maximized(
+            m_wl_shell_surface,
+            output);
+    }
+
+    void wl_shell_surface::set_title(const QString &title)
+    {
+        wl_shell_surface_set_title(
+            m_wl_shell_surface,
+            title.toUtf8().constData());
+    }
+
+    void wl_shell_surface::set_class(const QString &class_)
+    {
+        wl_shell_surface_set_class(
+            m_wl_shell_surface,
+            class_.toUtf8().constData());
+    }
+
+    void wl_shell_surface::shell_surface_ping(uint32_t )
+    {
+    }
+
+    void wl_shell_surface::handle_ping(
+        void *data,
+        struct ::wl_shell_surface *object,
+        uint32_t serial)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_shell_surface *>(data)->shell_surface_ping(
+            serial);
+    }
+
+    void wl_shell_surface::shell_surface_configure(uint32_t , int32_t , int32_t )
+    {
+    }
+
+    void wl_shell_surface::handle_configure(
+        void *data,
+        struct ::wl_shell_surface *object,
+        uint32_t edges,
+        int32_t width,
+        int32_t height)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_shell_surface *>(data)->shell_surface_configure(
+            edges,
+            width,
+            height);
+    }
+
+    void wl_shell_surface::shell_surface_popup_done()
+    {
+    }
+
+    void wl_shell_surface::handle_popup_done(
+        void *data,
+        struct ::wl_shell_surface *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_shell_surface *>(data)->shell_surface_popup_done();
+    }
+
+    const struct wl_shell_surface_listener wl_shell_surface::m_wl_shell_surface_listener = {
+        wl_shell_surface::handle_ping,
+        wl_shell_surface::handle_configure,
+        wl_shell_surface::handle_popup_done,
+    };
+
+    void wl_shell_surface::init_listener()
+    {
+        wl_shell_surface_add_listener(m_wl_shell_surface, &m_wl_shell_surface_listener, this);
+    }
+
+    wl_surface::wl_surface(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_surface::wl_surface(struct ::wl_surface *obj)
+        : m_wl_surface(obj)
+    {
+        init_listener();
+    }
+
+    wl_surface::wl_surface()
+        : m_wl_surface(nullptr)
+    {
+    }
+
+    wl_surface::~wl_surface()
+    {
+    }
+
+    void wl_surface::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_surface = static_cast<struct ::wl_surface *>(wlRegistryBind(registry, id, &wl_surface_interface, version));
+        init_listener();
+    }
+
+    void wl_surface::init(struct ::wl_surface *obj)
+    {
+        m_wl_surface = obj;
+        init_listener();
+    }
+
+    wl_surface *wl_surface::fromObject(struct ::wl_surface *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_surface_listener)
+            return nullptr;
+        return static_cast<wl_surface *>(wl_surface_get_user_data(object));
+    }
+
+    bool wl_surface::isInitialized() const
+    {
+        return m_wl_surface != nullptr;
+    }
+
+    const struct wl_interface *wl_surface::interface()
+    {
+        return &::wl_surface_interface;
+    }
+
+    void wl_surface::destroy()
+    {
+        wl_surface_destroy(
+            m_wl_surface);
+        m_wl_surface = nullptr;
+    }
+
+    void wl_surface::attach(struct ::wl_buffer *buffer, int32_t x, int32_t y)
+    {
+        wl_surface_attach(
+            m_wl_surface,
+            buffer,
+            x,
+            y);
+    }
+
+    void wl_surface::damage(int32_t x, int32_t y, int32_t width, int32_t height)
+    {
+        wl_surface_damage(
+            m_wl_surface,
+            x,
+            y,
+            width,
+            height);
+    }
+
+    struct ::wl_callback *wl_surface::frame()
+    {
+        return wl_surface_frame(
+            m_wl_surface);
+    }
+
+    void wl_surface::set_opaque_region(struct ::wl_region *region)
+    {
+        wl_surface_set_opaque_region(
+            m_wl_surface,
+            region);
+    }
+
+    void wl_surface::set_input_region(struct ::wl_region *region)
+    {
+        wl_surface_set_input_region(
+            m_wl_surface,
+            region);
+    }
+
+    void wl_surface::commit()
+    {
+        wl_surface_commit(
+            m_wl_surface);
+    }
+
+    void wl_surface::set_buffer_transform(int32_t transform)
+    {
+        wl_surface_set_buffer_transform(
+            m_wl_surface,
+            transform);
+    }
+
+    void wl_surface::set_buffer_scale(int32_t scale)
+    {
+        wl_surface_set_buffer_scale(
+            m_wl_surface,
+            scale);
+    }
+
+    void wl_surface::damage_buffer(int32_t x, int32_t y, int32_t width, int32_t height)
+    {
+        wl_surface_damage_buffer(
+            m_wl_surface,
+            x,
+            y,
+            width,
+            height);
+    }
+
+    void wl_surface::surface_enter(struct ::wl_output *)
+    {
+    }
+
+    void wl_surface::handle_enter(
+        void *data,
+        struct ::wl_surface *object,
+        struct ::wl_output *output)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_surface *>(data)->surface_enter(
+            output);
+    }
+
+    void wl_surface::surface_leave(struct ::wl_output *)
+    {
+    }
+
+    void wl_surface::handle_leave(
+        void *data,
+        struct ::wl_surface *object,
+        struct ::wl_output *output)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_surface *>(data)->surface_leave(
+            output);
+    }
+
+    const struct wl_surface_listener wl_surface::m_wl_surface_listener = {
+        wl_surface::handle_enter,
+        wl_surface::handle_leave,
+    };
+
+    void wl_surface::init_listener()
+    {
+        wl_surface_add_listener(m_wl_surface, &m_wl_surface_listener, this);
+    }
+
+    wl_seat::wl_seat(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_seat::wl_seat(struct ::wl_seat *obj)
+        : m_wl_seat(obj)
+    {
+        init_listener();
+    }
+
+    wl_seat::wl_seat()
+        : m_wl_seat(nullptr)
+    {
+    }
+
+    wl_seat::~wl_seat()
+    {
+    }
+
+    void wl_seat::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_seat = static_cast<struct ::wl_seat *>(wlRegistryBind(registry, id, &wl_seat_interface, version));
+        init_listener();
+    }
+
+    void wl_seat::init(struct ::wl_seat *obj)
+    {
+        m_wl_seat = obj;
+        init_listener();
+    }
+
+    wl_seat *wl_seat::fromObject(struct ::wl_seat *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_seat_listener)
+            return nullptr;
+        return static_cast<wl_seat *>(wl_seat_get_user_data(object));
+    }
+
+    bool wl_seat::isInitialized() const
+    {
+        return m_wl_seat != nullptr;
+    }
+
+    const struct wl_interface *wl_seat::interface()
+    {
+        return &::wl_seat_interface;
+    }
+
+    struct ::wl_pointer *wl_seat::get_pointer()
+    {
+        return wl_seat_get_pointer(
+            m_wl_seat);
+    }
+
+    struct ::wl_keyboard *wl_seat::get_keyboard()
+    {
+        return wl_seat_get_keyboard(
+            m_wl_seat);
+    }
+
+    struct ::wl_touch *wl_seat::get_touch()
+    {
+        return wl_seat_get_touch(
+            m_wl_seat);
+    }
+
+    void wl_seat::release()
+    {
+        wl_seat_release(
+            m_wl_seat);
+        m_wl_seat = nullptr;
+    }
+
+    void wl_seat::seat_capabilities(uint32_t )
+    {
+    }
+
+    void wl_seat::handle_capabilities(
+        void *data,
+        struct ::wl_seat *object,
+        uint32_t capabilities)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_seat *>(data)->seat_capabilities(
+            capabilities);
+    }
+
+    void wl_seat::seat_name(const QString &)
+    {
+    }
+
+    void wl_seat::handle_name(
+        void *data,
+        struct ::wl_seat *object,
+        const char *name)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_seat *>(data)->seat_name(
+            QString::fromUtf8(name));
+    }
+
+    const struct wl_seat_listener wl_seat::m_wl_seat_listener = {
+        wl_seat::handle_capabilities,
+        wl_seat::handle_name,
+    };
+
+    void wl_seat::init_listener()
+    {
+        wl_seat_add_listener(m_wl_seat, &m_wl_seat_listener, this);
+    }
+
+    wl_pointer::wl_pointer(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_pointer::wl_pointer(struct ::wl_pointer *obj)
+        : m_wl_pointer(obj)
+    {
+        init_listener();
+    }
+
+    wl_pointer::wl_pointer()
+        : m_wl_pointer(nullptr)
+    {
+    }
+
+    wl_pointer::~wl_pointer()
+    {
+    }
+
+    void wl_pointer::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_pointer = static_cast<struct ::wl_pointer *>(wlRegistryBind(registry, id, &wl_pointer_interface, version));
+        init_listener();
+    }
+
+    void wl_pointer::init(struct ::wl_pointer *obj)
+    {
+        m_wl_pointer = obj;
+        init_listener();
+    }
+
+    wl_pointer *wl_pointer::fromObject(struct ::wl_pointer *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_pointer_listener)
+            return nullptr;
+        return static_cast<wl_pointer *>(wl_pointer_get_user_data(object));
+    }
+
+    bool wl_pointer::isInitialized() const
+    {
+        return m_wl_pointer != nullptr;
+    }
+
+    const struct wl_interface *wl_pointer::interface()
+    {
+        return &::wl_pointer_interface;
+    }
+
+    void wl_pointer::set_cursor(uint32_t serial, struct ::wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
+    {
+        wl_pointer_set_cursor(
+            m_wl_pointer,
+            serial,
+            surface,
+            hotspot_x,
+            hotspot_y);
+    }
+
+    void wl_pointer::release()
+    {
+        wl_pointer_release(
+            m_wl_pointer);
+        m_wl_pointer = nullptr;
+    }
+
+    void wl_pointer::pointer_enter(uint32_t , struct ::wl_surface *, wl_fixed_t , wl_fixed_t )
+    {
+    }
+
+    void wl_pointer::handle_enter(
+        void *data,
+        struct ::wl_pointer *object,
+        uint32_t serial,
+        struct ::wl_surface *surface,
+        wl_fixed_t surface_x,
+        wl_fixed_t surface_y)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_enter(
+            serial,
+            surface,
+            surface_x,
+            surface_y);
+    }
+
+    void wl_pointer::pointer_leave(uint32_t , struct ::wl_surface *)
+    {
+    }
+
+    void wl_pointer::handle_leave(
+        void *data,
+        struct ::wl_pointer *object,
+        uint32_t serial,
+        struct ::wl_surface *surface)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_leave(
+            serial,
+            surface);
+    }
+
+    void wl_pointer::pointer_motion(uint32_t , wl_fixed_t , wl_fixed_t )
+    {
+    }
+
+    void wl_pointer::handle_motion(
+        void *data,
+        struct ::wl_pointer *object,
+        uint32_t time,
+        wl_fixed_t surface_x,
+        wl_fixed_t surface_y)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_motion(
+            time,
+            surface_x,
+            surface_y);
+    }
+
+    void wl_pointer::pointer_button(uint32_t , uint32_t , uint32_t , uint32_t )
+    {
+    }
+
+    void wl_pointer::handle_button(
+        void *data,
+        struct ::wl_pointer *object,
+        uint32_t serial,
+        uint32_t time,
+        uint32_t button,
+        uint32_t state)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_button(
+            serial,
+            time,
+            button,
+            state);
+    }
+
+    void wl_pointer::pointer_axis(uint32_t , uint32_t , wl_fixed_t )
+    {
+    }
+
+    void wl_pointer::handle_axis(
+        void *data,
+        struct ::wl_pointer *object,
+        uint32_t time,
+        uint32_t axis,
+        wl_fixed_t value)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_axis(
+            time,
+            axis,
+            value);
+    }
+
+    void wl_pointer::pointer_frame()
+    {
+    }
+
+    void wl_pointer::handle_frame(
+        void *data,
+        struct ::wl_pointer *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_frame();
+    }
+
+    void wl_pointer::pointer_axis_source(uint32_t )
+    {
+    }
+
+    void wl_pointer::handle_axis_source(
+        void *data,
+        struct ::wl_pointer *object,
+        uint32_t axis_source)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_axis_source(
+            axis_source);
+    }
+
+    void wl_pointer::pointer_axis_stop(uint32_t , uint32_t )
+    {
+    }
+
+    void wl_pointer::handle_axis_stop(
+        void *data,
+        struct ::wl_pointer *object,
+        uint32_t time,
+        uint32_t axis)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_axis_stop(
+            time,
+            axis);
+    }
+
+    void wl_pointer::pointer_axis_discrete(uint32_t , int32_t )
+    {
+    }
+
+    void wl_pointer::handle_axis_discrete(
+        void *data,
+        struct ::wl_pointer *object,
+        uint32_t axis,
+        int32_t discrete)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_pointer *>(data)->pointer_axis_discrete(
+            axis,
+            discrete);
+    }
+
+    const struct wl_pointer_listener wl_pointer::m_wl_pointer_listener = {
+        wl_pointer::handle_enter,
+        wl_pointer::handle_leave,
+        wl_pointer::handle_motion,
+        wl_pointer::handle_button,
+        wl_pointer::handle_axis,
+        wl_pointer::handle_frame,
+        wl_pointer::handle_axis_source,
+        wl_pointer::handle_axis_stop,
+        wl_pointer::handle_axis_discrete,
+    };
+
+    void wl_pointer::init_listener()
+    {
+        wl_pointer_add_listener(m_wl_pointer, &m_wl_pointer_listener, this);
+    }
+
+    wl_keyboard::wl_keyboard(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_keyboard::wl_keyboard(struct ::wl_keyboard *obj)
+        : m_wl_keyboard(obj)
+    {
+        init_listener();
+    }
+
+    wl_keyboard::wl_keyboard()
+        : m_wl_keyboard(nullptr)
+    {
+    }
+
+    wl_keyboard::~wl_keyboard()
+    {
+    }
+
+    void wl_keyboard::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_keyboard = static_cast<struct ::wl_keyboard *>(wlRegistryBind(registry, id, &wl_keyboard_interface, version));
+        init_listener();
+    }
+
+    void wl_keyboard::init(struct ::wl_keyboard *obj)
+    {
+        m_wl_keyboard = obj;
+        init_listener();
+    }
+
+    wl_keyboard *wl_keyboard::fromObject(struct ::wl_keyboard *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_keyboard_listener)
+            return nullptr;
+        return static_cast<wl_keyboard *>(wl_keyboard_get_user_data(object));
+    }
+
+    bool wl_keyboard::isInitialized() const
+    {
+        return m_wl_keyboard != nullptr;
+    }
+
+    const struct wl_interface *wl_keyboard::interface()
+    {
+        return &::wl_keyboard_interface;
+    }
+
+    void wl_keyboard::release()
+    {
+        wl_keyboard_release(
+            m_wl_keyboard);
+        m_wl_keyboard = nullptr;
+    }
+
+    void wl_keyboard::keyboard_keymap(uint32_t , int32_t , uint32_t )
+    {
+    }
+
+    void wl_keyboard::handle_keymap(
+        void *data,
+        struct ::wl_keyboard *object,
+        uint32_t format,
+        int32_t fd,
+        uint32_t size)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_keyboard *>(data)->keyboard_keymap(
+            format,
+            fd,
+            size);
+    }
+
+    void wl_keyboard::keyboard_enter(uint32_t , struct ::wl_surface *, wl_array *)
+    {
+    }
+
+    void wl_keyboard::handle_enter(
+        void *data,
+        struct ::wl_keyboard *object,
+        uint32_t serial,
+        struct ::wl_surface *surface,
+        wl_array *keys)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_keyboard *>(data)->keyboard_enter(
+            serial,
+            surface,
+            keys);
+    }
+
+    void wl_keyboard::keyboard_leave(uint32_t , struct ::wl_surface *)
+    {
+    }
+
+    void wl_keyboard::handle_leave(
+        void *data,
+        struct ::wl_keyboard *object,
+        uint32_t serial,
+        struct ::wl_surface *surface)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_keyboard *>(data)->keyboard_leave(
+            serial,
+            surface);
+    }
+
+    void wl_keyboard::keyboard_key(uint32_t , uint32_t , uint32_t , uint32_t )
+    {
+    }
+
+    void wl_keyboard::handle_key(
+        void *data,
+        struct ::wl_keyboard *object,
+        uint32_t serial,
+        uint32_t time,
+        uint32_t key,
+        uint32_t state)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_keyboard *>(data)->keyboard_key(
+            serial,
+            time,
+            key,
+            state);
+    }
+
+    void wl_keyboard::keyboard_modifiers(uint32_t , uint32_t , uint32_t , uint32_t , uint32_t )
+    {
+    }
+
+    void wl_keyboard::handle_modifiers(
+        void *data,
+        struct ::wl_keyboard *object,
+        uint32_t serial,
+        uint32_t mods_depressed,
+        uint32_t mods_latched,
+        uint32_t mods_locked,
+        uint32_t group)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_keyboard *>(data)->keyboard_modifiers(
+            serial,
+            mods_depressed,
+            mods_latched,
+            mods_locked,
+            group);
+    }
+
+    void wl_keyboard::keyboard_repeat_info(int32_t , int32_t )
+    {
+    }
+
+    void wl_keyboard::handle_repeat_info(
+        void *data,
+        struct ::wl_keyboard *object,
+        int32_t rate,
+        int32_t delay)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_keyboard *>(data)->keyboard_repeat_info(
+            rate,
+            delay);
+    }
+
+    const struct wl_keyboard_listener wl_keyboard::m_wl_keyboard_listener = {
+        wl_keyboard::handle_keymap,
+        wl_keyboard::handle_enter,
+        wl_keyboard::handle_leave,
+        wl_keyboard::handle_key,
+        wl_keyboard::handle_modifiers,
+        wl_keyboard::handle_repeat_info,
+    };
+
+    void wl_keyboard::init_listener()
+    {
+        wl_keyboard_add_listener(m_wl_keyboard, &m_wl_keyboard_listener, this);
+    }
+
+    wl_touch::wl_touch(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_touch::wl_touch(struct ::wl_touch *obj)
+        : m_wl_touch(obj)
+    {
+        init_listener();
+    }
+
+    wl_touch::wl_touch()
+        : m_wl_touch(nullptr)
+    {
+    }
+
+    wl_touch::~wl_touch()
+    {
+    }
+
+    void wl_touch::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_touch = static_cast<struct ::wl_touch *>(wlRegistryBind(registry, id, &wl_touch_interface, version));
+        init_listener();
+    }
+
+    void wl_touch::init(struct ::wl_touch *obj)
+    {
+        m_wl_touch = obj;
+        init_listener();
+    }
+
+    wl_touch *wl_touch::fromObject(struct ::wl_touch *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_touch_listener)
+            return nullptr;
+        return static_cast<wl_touch *>(wl_touch_get_user_data(object));
+    }
+
+    bool wl_touch::isInitialized() const
+    {
+        return m_wl_touch != nullptr;
+    }
+
+    const struct wl_interface *wl_touch::interface()
+    {
+        return &::wl_touch_interface;
+    }
+
+    void wl_touch::release()
+    {
+        wl_touch_release(
+            m_wl_touch);
+        m_wl_touch = nullptr;
+    }
+
+    void wl_touch::touch_down(uint32_t , uint32_t , struct ::wl_surface *, int32_t , wl_fixed_t , wl_fixed_t )
+    {
+    }
+
+    void wl_touch::handle_down(
+        void *data,
+        struct ::wl_touch *object,
+        uint32_t serial,
+        uint32_t time,
+        struct ::wl_surface *surface,
+        int32_t id,
+        wl_fixed_t x,
+        wl_fixed_t y)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_touch *>(data)->touch_down(
+            serial,
+            time,
+            surface,
+            id,
+            x,
+            y);
+    }
+
+    void wl_touch::touch_up(uint32_t , uint32_t , int32_t )
+    {
+    }
+
+    void wl_touch::handle_up(
+        void *data,
+        struct ::wl_touch *object,
+        uint32_t serial,
+        uint32_t time,
+        int32_t id)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_touch *>(data)->touch_up(
+            serial,
+            time,
+            id);
+    }
+
+    void wl_touch::touch_motion(uint32_t , int32_t , wl_fixed_t , wl_fixed_t )
+    {
+    }
+
+    void wl_touch::handle_motion(
+        void *data,
+        struct ::wl_touch *object,
+        uint32_t time,
+        int32_t id,
+        wl_fixed_t x,
+        wl_fixed_t y)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_touch *>(data)->touch_motion(
+            time,
+            id,
+            x,
+            y);
+    }
+
+    void wl_touch::touch_frame()
+    {
+    }
+
+    void wl_touch::handle_frame(
+        void *data,
+        struct ::wl_touch *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_touch *>(data)->touch_frame();
+    }
+
+    void wl_touch::touch_cancel()
+    {
+    }
+
+    void wl_touch::handle_cancel(
+        void *data,
+        struct ::wl_touch *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_touch *>(data)->touch_cancel();
+    }
+
+    void wl_touch::touch_shape(int32_t , wl_fixed_t , wl_fixed_t )
+    {
+    }
+
+    void wl_touch::handle_shape(
+        void *data,
+        struct ::wl_touch *object,
+        int32_t id,
+        wl_fixed_t major,
+        wl_fixed_t minor)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_touch *>(data)->touch_shape(
+            id,
+            major,
+            minor);
+    }
+
+    void wl_touch::touch_orientation(int32_t , wl_fixed_t )
+    {
+    }
+
+    void wl_touch::handle_orientation(
+        void *data,
+        struct ::wl_touch *object,
+        int32_t id,
+        wl_fixed_t orientation)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_touch *>(data)->touch_orientation(
+            id,
+            orientation);
+    }
+
+    const struct wl_touch_listener wl_touch::m_wl_touch_listener = {
+        wl_touch::handle_down,
+        wl_touch::handle_up,
+        wl_touch::handle_motion,
+        wl_touch::handle_frame,
+        wl_touch::handle_cancel,
+        wl_touch::handle_shape,
+        wl_touch::handle_orientation,
+    };
+
+    void wl_touch::init_listener()
+    {
+        wl_touch_add_listener(m_wl_touch, &m_wl_touch_listener, this);
+    }
+
+    wl_output::wl_output(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_output::wl_output(struct ::wl_output *obj)
+        : m_wl_output(obj)
+    {
+        init_listener();
+    }
+
+    wl_output::wl_output()
+        : m_wl_output(nullptr)
+    {
+    }
+
+    wl_output::~wl_output()
+    {
+    }
+
+    void wl_output::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_output = static_cast<struct ::wl_output *>(wlRegistryBind(registry, id, &wl_output_interface, version));
+        init_listener();
+    }
+
+    void wl_output::init(struct ::wl_output *obj)
+    {
+        m_wl_output = obj;
+        init_listener();
+    }
+
+    wl_output *wl_output::fromObject(struct ::wl_output *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_wl_output_listener)
+            return nullptr;
+        return static_cast<wl_output *>(wl_output_get_user_data(object));
+    }
+
+    bool wl_output::isInitialized() const
+    {
+        return m_wl_output != nullptr;
+    }
+
+    const struct wl_interface *wl_output::interface()
+    {
+        return &::wl_output_interface;
+    }
+
+    void wl_output::release()
+    {
+        wl_output_release(
+            m_wl_output);
+        m_wl_output = nullptr;
+    }
+
+    void wl_output::output_geometry(int32_t , int32_t , int32_t , int32_t , int32_t , const QString &, const QString &, int32_t )
+    {
+    }
+
+    void wl_output::handle_geometry(
+        void *data,
+        struct ::wl_output *object,
+        int32_t x,
+        int32_t y,
+        int32_t physical_width,
+        int32_t physical_height,
+        int32_t subpixel,
+        const char *make,
+        const char *model,
+        int32_t transform)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_output *>(data)->output_geometry(
+            x,
+            y,
+            physical_width,
+            physical_height,
+            subpixel,
+            QString::fromUtf8(make),
+            QString::fromUtf8(model),
+            transform);
+    }
+
+    void wl_output::output_mode(uint32_t , int32_t , int32_t , int32_t )
+    {
+    }
+
+    void wl_output::handle_mode(
+        void *data,
+        struct ::wl_output *object,
+        uint32_t flags,
+        int32_t width,
+        int32_t height,
+        int32_t refresh)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_output *>(data)->output_mode(
+            flags,
+            width,
+            height,
+            refresh);
+    }
+
+    void wl_output::output_done()
+    {
+    }
+
+    void wl_output::handle_done(
+        void *data,
+        struct ::wl_output *object)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_output *>(data)->output_done();
+    }
+
+    void wl_output::output_scale(int32_t )
+    {
+    }
+
+    void wl_output::handle_scale(
+        void *data,
+        struct ::wl_output *object,
+        int32_t factor)
+    {
+        Q_UNUSED(object);
+        static_cast<wl_output *>(data)->output_scale(
+            factor);
+    }
+
+    const struct wl_output_listener wl_output::m_wl_output_listener = {
+        wl_output::handle_geometry,
+        wl_output::handle_mode,
+        wl_output::handle_done,
+        wl_output::handle_scale,
+    };
+
+    void wl_output::init_listener()
+    {
+        wl_output_add_listener(m_wl_output, &m_wl_output_listener, this);
+    }
+
+    wl_region::wl_region(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_region::wl_region(struct ::wl_region *obj)
+        : m_wl_region(obj)
+    {
+    }
+
+    wl_region::wl_region()
+        : m_wl_region(nullptr)
+    {
+    }
+
+    wl_region::~wl_region()
+    {
+    }
+
+    void wl_region::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_region = static_cast<struct ::wl_region *>(wlRegistryBind(registry, id, &wl_region_interface, version));
+    }
+
+    void wl_region::init(struct ::wl_region *obj)
+    {
+        m_wl_region = obj;
+    }
+
+    wl_region *wl_region::fromObject(struct ::wl_region *object)
+    {
+        return static_cast<wl_region *>(wl_region_get_user_data(object));
+    }
+
+    bool wl_region::isInitialized() const
+    {
+        return m_wl_region != nullptr;
+    }
+
+    const struct wl_interface *wl_region::interface()
+    {
+        return &::wl_region_interface;
+    }
+
+    void wl_region::destroy()
+    {
+        wl_region_destroy(
+            m_wl_region);
+        m_wl_region = nullptr;
+    }
+
+    void wl_region::add(int32_t x, int32_t y, int32_t width, int32_t height)
+    {
+        wl_region_add(
+            m_wl_region,
+            x,
+            y,
+            width,
+            height);
+    }
+
+    void wl_region::subtract(int32_t x, int32_t y, int32_t width, int32_t height)
+    {
+        wl_region_subtract(
+            m_wl_region,
+            x,
+            y,
+            width,
+            height);
+    }
+
+    wl_subcompositor::wl_subcompositor(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_subcompositor::wl_subcompositor(struct ::wl_subcompositor *obj)
+        : m_wl_subcompositor(obj)
+    {
+    }
+
+    wl_subcompositor::wl_subcompositor()
+        : m_wl_subcompositor(nullptr)
+    {
+    }
+
+    wl_subcompositor::~wl_subcompositor()
+    {
+    }
+
+    void wl_subcompositor::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_subcompositor = static_cast<struct ::wl_subcompositor *>(wlRegistryBind(registry, id, &wl_subcompositor_interface, version));
+    }
+
+    void wl_subcompositor::init(struct ::wl_subcompositor *obj)
+    {
+        m_wl_subcompositor = obj;
+    }
+
+    wl_subcompositor *wl_subcompositor::fromObject(struct ::wl_subcompositor *object)
+    {
+        return static_cast<wl_subcompositor *>(wl_subcompositor_get_user_data(object));
+    }
+
+    bool wl_subcompositor::isInitialized() const
+    {
+        return m_wl_subcompositor != nullptr;
+    }
+
+    const struct wl_interface *wl_subcompositor::interface()
+    {
+        return &::wl_subcompositor_interface;
+    }
+
+    void wl_subcompositor::destroy()
+    {
+        wl_subcompositor_destroy(
+            m_wl_subcompositor);
+        m_wl_subcompositor = nullptr;
+    }
+
+    struct ::wl_subsurface *wl_subcompositor::get_subsurface(struct ::wl_surface *surface, struct ::wl_surface *parent)
+    {
+        return wl_subcompositor_get_subsurface(
+            m_wl_subcompositor,
+            surface,
+            parent);
+    }
+
+    wl_subsurface::wl_subsurface(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    wl_subsurface::wl_subsurface(struct ::wl_subsurface *obj)
+        : m_wl_subsurface(obj)
+    {
+    }
+
+    wl_subsurface::wl_subsurface()
+        : m_wl_subsurface(nullptr)
+    {
+    }
+
+    wl_subsurface::~wl_subsurface()
+    {
+    }
+
+    void wl_subsurface::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_wl_subsurface = static_cast<struct ::wl_subsurface *>(wlRegistryBind(registry, id, &wl_subsurface_interface, version));
+    }
+
+    void wl_subsurface::init(struct ::wl_subsurface *obj)
+    {
+        m_wl_subsurface = obj;
+    }
+
+    wl_subsurface *wl_subsurface::fromObject(struct ::wl_subsurface *object)
+    {
+        return static_cast<wl_subsurface *>(wl_subsurface_get_user_data(object));
+    }
+
+    bool wl_subsurface::isInitialized() const
+    {
+        return m_wl_subsurface != nullptr;
+    }
+
+    const struct wl_interface *wl_subsurface::interface()
+    {
+        return &::wl_subsurface_interface;
+    }
+
+    void wl_subsurface::destroy()
+    {
+        wl_subsurface_destroy(
+            m_wl_subsurface);
+        m_wl_subsurface = nullptr;
+    }
+
+    void wl_subsurface::set_position(int32_t x, int32_t y)
+    {
+        wl_subsurface_set_position(
+            m_wl_subsurface,
+            x,
+            y);
+    }
+
+    void wl_subsurface::place_above(struct ::wl_surface *sibling)
+    {
+        wl_subsurface_place_above(
+            m_wl_subsurface,
+            sibling);
+    }
+
+    void wl_subsurface::place_below(struct ::wl_surface *sibling)
+    {
+        wl_subsurface_place_below(
+            m_wl_subsurface,
+            sibling);
+    }
+
+    void wl_subsurface::set_sync()
+    {
+        wl_subsurface_set_sync(
+            m_wl_subsurface);
+    }
+
+    void wl_subsurface::set_desync()
+    {
+        wl_subsurface_set_desync(
+            m_wl_subsurface);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-wayland.h b/src/client/qwayland-wayland.h
new file mode 100644
index 0000000000000000000000000000000000000000..2046912184ba34ab57be60ddffd13b2326525080
--- /dev/null
+++ a/qtwayland/src/client/qwayland-wayland.h
@@ -0,0 +1,1178 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/wayland.xml
+
+#ifndef QT_WAYLAND_WAYLAND
+#define QT_WAYLAND_WAYLAND
+
+#include <QtWaylandClient/private/wayland-wayland-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_WAYLAND_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_WAYLAND_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_WAYLAND_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_registry
+    {
+    public:
+        wl_registry(struct ::wl_registry *registry, int id, int version);
+        wl_registry(struct ::wl_registry *object);
+        wl_registry();
+
+        virtual ~wl_registry();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_registry *object);
+
+        struct ::wl_registry *object() { return m_wl_registry; }
+        const struct ::wl_registry *object() const { return m_wl_registry; }
+        static wl_registry *fromObject(struct ::wl_registry *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void *bind(uint32_t name, const struct ::wl_interface *interface, uint32_t version);
+
+    protected:
+        virtual void registry_global(uint32_t name, const QString &interface, uint32_t version);
+        virtual void registry_global_remove(uint32_t name);
+
+    private:
+        void init_listener();
+        static const struct wl_registry_listener m_wl_registry_listener;
+        static void handle_global(
+            void *data,
+            struct ::wl_registry *object,
+            uint32_t name,
+            const char *interface,
+            uint32_t version);
+        static void handle_global_remove(
+            void *data,
+            struct ::wl_registry *object,
+            uint32_t name);
+        struct ::wl_registry *m_wl_registry;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_callback
+    {
+    public:
+        wl_callback(struct ::wl_registry *registry, int id, int version);
+        wl_callback(struct ::wl_callback *object);
+        wl_callback();
+
+        virtual ~wl_callback();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_callback *object);
+
+        struct ::wl_callback *object() { return m_wl_callback; }
+        const struct ::wl_callback *object() const { return m_wl_callback; }
+        static wl_callback *fromObject(struct ::wl_callback *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+    protected:
+        virtual void callback_done(uint32_t callback_data);
+
+    private:
+        void init_listener();
+        static const struct wl_callback_listener m_wl_callback_listener;
+        static void handle_done(
+            void *data,
+            struct ::wl_callback *object,
+            uint32_t callback_data);
+        struct ::wl_callback *m_wl_callback;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_compositor
+    {
+    public:
+        wl_compositor(struct ::wl_registry *registry, int id, int version);
+        wl_compositor(struct ::wl_compositor *object);
+        wl_compositor();
+
+        virtual ~wl_compositor();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_compositor *object);
+
+        struct ::wl_compositor *object() { return m_wl_compositor; }
+        const struct ::wl_compositor *object() const { return m_wl_compositor; }
+        static wl_compositor *fromObject(struct ::wl_compositor *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        struct ::wl_surface *create_surface();
+        struct ::wl_region *create_region();
+
+    private:
+        struct ::wl_compositor *m_wl_compositor;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_shm_pool
+    {
+    public:
+        wl_shm_pool(struct ::wl_registry *registry, int id, int version);
+        wl_shm_pool(struct ::wl_shm_pool *object);
+        wl_shm_pool();
+
+        virtual ~wl_shm_pool();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_shm_pool *object);
+
+        struct ::wl_shm_pool *object() { return m_wl_shm_pool; }
+        const struct ::wl_shm_pool *object() const { return m_wl_shm_pool; }
+        static wl_shm_pool *fromObject(struct ::wl_shm_pool *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        struct ::wl_buffer *create_buffer(int32_t offset, int32_t width, int32_t height, int32_t stride, uint32_t format);
+        void destroy();
+        void resize(int32_t size);
+
+    private:
+        struct ::wl_shm_pool *m_wl_shm_pool;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_shm
+    {
+    public:
+        wl_shm(struct ::wl_registry *registry, int id, int version);
+        wl_shm(struct ::wl_shm *object);
+        wl_shm();
+
+        virtual ~wl_shm();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_shm *object);
+
+        struct ::wl_shm *object() { return m_wl_shm; }
+        const struct ::wl_shm *object() const { return m_wl_shm; }
+        static wl_shm *fromObject(struct ::wl_shm *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_invalid_format = 0, // buffer format is not known
+            error_invalid_stride = 1, // invalid size or stride during pool or buffer creation
+            error_invalid_fd = 2, // mmapping the file descriptor failed
+        };
+
+        enum format {
+            format_argb8888 = 0, // 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
+            format_xrgb8888 = 1, // 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
+            format_c8 = 0x20203843, // 8-bit color index format, [7:0] C
+            format_rgb332 = 0x38424752, // 8-bit RGB format, [7:0] R:G:B 3:3:2
+            format_bgr233 = 0x38524742, // 8-bit BGR format, [7:0] B:G:R 2:3:3
+            format_xrgb4444 = 0x32315258, // 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
+            format_xbgr4444 = 0x32314258, // 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
+            format_rgbx4444 = 0x32315852, // 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
+            format_bgrx4444 = 0x32315842, // 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
+            format_argb4444 = 0x32315241, // 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
+            format_abgr4444 = 0x32314241, // 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
+            format_rgba4444 = 0x32314152, // 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
+            format_bgra4444 = 0x32314142, // 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
+            format_xrgb1555 = 0x35315258, // 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
+            format_xbgr1555 = 0x35314258, // 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
+            format_rgbx5551 = 0x35315852, // 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
+            format_bgrx5551 = 0x35315842, // 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
+            format_argb1555 = 0x35315241, // 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
+            format_abgr1555 = 0x35314241, // 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
+            format_rgba5551 = 0x35314152, // 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
+            format_bgra5551 = 0x35314142, // 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
+            format_rgb565 = 0x36314752, // 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
+            format_bgr565 = 0x36314742, // 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
+            format_rgb888 = 0x34324752, // 24-bit RGB format, [23:0] R:G:B little endian
+            format_bgr888 = 0x34324742, // 24-bit BGR format, [23:0] B:G:R little endian
+            format_xbgr8888 = 0x34324258, // 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
+            format_rgbx8888 = 0x34325852, // 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
+            format_bgrx8888 = 0x34325842, // 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
+            format_abgr8888 = 0x34324241, // 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
+            format_rgba8888 = 0x34324152, // 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
+            format_bgra8888 = 0x34324142, // 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
+            format_xrgb2101010 = 0x30335258, // 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
+            format_xbgr2101010 = 0x30334258, // 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
+            format_rgbx1010102 = 0x30335852, // 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
+            format_bgrx1010102 = 0x30335842, // 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
+            format_argb2101010 = 0x30335241, // 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
+            format_abgr2101010 = 0x30334241, // 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
+            format_rgba1010102 = 0x30334152, // 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
+            format_bgra1010102 = 0x30334142, // 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
+            format_yuyv = 0x56595559, // packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
+            format_yvyu = 0x55595659, // packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
+            format_uyvy = 0x59565955, // packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
+            format_vyuy = 0x59555956, // packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
+            format_ayuv = 0x56555941, // packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
+            format_nv12 = 0x3231564e, // 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
+            format_nv21 = 0x3132564e, // 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
+            format_nv16 = 0x3631564e, // 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
+            format_nv61 = 0x3136564e, // 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
+            format_yuv410 = 0x39565559, // 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
+            format_yvu410 = 0x39555659, // 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
+            format_yuv411 = 0x31315559, // 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
+            format_yvu411 = 0x31315659, // 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
+            format_yuv420 = 0x32315559, // 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
+            format_yvu420 = 0x32315659, // 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
+            format_yuv422 = 0x36315559, // 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
+            format_yvu422 = 0x36315659, // 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
+            format_yuv444 = 0x34325559, // 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
+            format_yvu444 = 0x34325659, // 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
+        };
+
+        struct ::wl_shm_pool *create_pool(int32_t fd, int32_t size);
+
+    protected:
+        virtual void shm_format(uint32_t format);
+
+    private:
+        void init_listener();
+        static const struct wl_shm_listener m_wl_shm_listener;
+        static void handle_format(
+            void *data,
+            struct ::wl_shm *object,
+            uint32_t format);
+        struct ::wl_shm *m_wl_shm;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_buffer
+    {
+    public:
+        wl_buffer(struct ::wl_registry *registry, int id, int version);
+        wl_buffer(struct ::wl_buffer *object);
+        wl_buffer();
+
+        virtual ~wl_buffer();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_buffer *object);
+
+        struct ::wl_buffer *object() { return m_wl_buffer; }
+        const struct ::wl_buffer *object() const { return m_wl_buffer; }
+        static wl_buffer *fromObject(struct ::wl_buffer *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+
+    protected:
+        virtual void buffer_release();
+
+    private:
+        void init_listener();
+        static const struct wl_buffer_listener m_wl_buffer_listener;
+        static void handle_release(
+            void *data,
+            struct ::wl_buffer *object);
+        struct ::wl_buffer *m_wl_buffer;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_data_offer
+    {
+    public:
+        wl_data_offer(struct ::wl_registry *registry, int id, int version);
+        wl_data_offer(struct ::wl_data_offer *object);
+        wl_data_offer();
+
+        virtual ~wl_data_offer();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_data_offer *object);
+
+        struct ::wl_data_offer *object() { return m_wl_data_offer; }
+        const struct ::wl_data_offer *object() const { return m_wl_data_offer; }
+        static wl_data_offer *fromObject(struct ::wl_data_offer *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_invalid_finish = 0, // finish request was called untimely
+            error_invalid_action_mask = 1, // action mask contains invalid values
+            error_invalid_action = 2, // action argument has an invalid value
+            error_invalid_offer = 3, // offer doesn't accept this request
+        };
+
+        void accept(uint32_t serial, const QString &mime_type);
+        void receive(const QString &mime_type, int32_t fd);
+        void destroy();
+        void finish();
+        void set_actions(uint32_t dnd_actions, uint32_t preferred_action);
+
+    protected:
+        virtual void data_offer_offer(const QString &mime_type);
+        virtual void data_offer_source_actions(uint32_t source_actions);
+        virtual void data_offer_action(uint32_t dnd_action);
+
+    private:
+        void init_listener();
+        static const struct wl_data_offer_listener m_wl_data_offer_listener;
+        static void handle_offer(
+            void *data,
+            struct ::wl_data_offer *object,
+            const char *mime_type);
+        static void handle_source_actions(
+            void *data,
+            struct ::wl_data_offer *object,
+            uint32_t source_actions);
+        static void handle_action(
+            void *data,
+            struct ::wl_data_offer *object,
+            uint32_t dnd_action);
+        struct ::wl_data_offer *m_wl_data_offer;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_data_source
+    {
+    public:
+        wl_data_source(struct ::wl_registry *registry, int id, int version);
+        wl_data_source(struct ::wl_data_source *object);
+        wl_data_source();
+
+        virtual ~wl_data_source();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_data_source *object);
+
+        struct ::wl_data_source *object() { return m_wl_data_source; }
+        const struct ::wl_data_source *object() const { return m_wl_data_source; }
+        static wl_data_source *fromObject(struct ::wl_data_source *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_invalid_action_mask = 0, // action mask contains invalid values
+            error_invalid_source = 1, // source doesn't accept this request
+        };
+
+        void offer(const QString &mime_type);
+        void destroy();
+        void set_actions(uint32_t dnd_actions);
+
+    protected:
+        virtual void data_source_target(const QString &mime_type);
+        virtual void data_source_send(const QString &mime_type, int32_t fd);
+        virtual void data_source_cancelled();
+        virtual void data_source_dnd_drop_performed();
+        virtual void data_source_dnd_finished();
+        virtual void data_source_action(uint32_t dnd_action);
+
+    private:
+        void init_listener();
+        static const struct wl_data_source_listener m_wl_data_source_listener;
+        static void handle_target(
+            void *data,
+            struct ::wl_data_source *object,
+            const char *mime_type);
+        static void handle_send(
+            void *data,
+            struct ::wl_data_source *object,
+            const char *mime_type,
+            int32_t fd);
+        static void handle_cancelled(
+            void *data,
+            struct ::wl_data_source *object);
+        static void handle_dnd_drop_performed(
+            void *data,
+            struct ::wl_data_source *object);
+        static void handle_dnd_finished(
+            void *data,
+            struct ::wl_data_source *object);
+        static void handle_action(
+            void *data,
+            struct ::wl_data_source *object,
+            uint32_t dnd_action);
+        struct ::wl_data_source *m_wl_data_source;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_data_device
+    {
+    public:
+        wl_data_device(struct ::wl_registry *registry, int id, int version);
+        wl_data_device(struct ::wl_data_device *object);
+        wl_data_device();
+
+        virtual ~wl_data_device();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_data_device *object);
+
+        struct ::wl_data_device *object() { return m_wl_data_device; }
+        const struct ::wl_data_device *object() const { return m_wl_data_device; }
+        static wl_data_device *fromObject(struct ::wl_data_device *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_role = 0, // given wl_surface has another role
+        };
+
+        void start_drag(struct ::wl_data_source *source, struct ::wl_surface *origin, struct ::wl_surface *icon, uint32_t serial);
+        void set_selection(struct ::wl_data_source *source, uint32_t serial);
+        void release();
+
+    protected:
+        virtual void data_device_data_offer(struct ::wl_data_offer *id);
+        virtual void data_device_enter(uint32_t serial, struct ::wl_surface *surface, wl_fixed_t x, wl_fixed_t y, struct ::wl_data_offer *id);
+        virtual void data_device_leave();
+        virtual void data_device_motion(uint32_t time, wl_fixed_t x, wl_fixed_t y);
+        virtual void data_device_drop();
+        virtual void data_device_selection(struct ::wl_data_offer *id);
+
+    private:
+        void init_listener();
+        static const struct wl_data_device_listener m_wl_data_device_listener;
+        static void handle_data_offer(
+            void *data,
+            struct ::wl_data_device *object,
+            struct ::wl_data_offer *id);
+        static void handle_enter(
+            void *data,
+            struct ::wl_data_device *object,
+            uint32_t serial,
+            struct ::wl_surface *surface,
+            wl_fixed_t x,
+            wl_fixed_t y,
+            struct ::wl_data_offer *id);
+        static void handle_leave(
+            void *data,
+            struct ::wl_data_device *object);
+        static void handle_motion(
+            void *data,
+            struct ::wl_data_device *object,
+            uint32_t time,
+            wl_fixed_t x,
+            wl_fixed_t y);
+        static void handle_drop(
+            void *data,
+            struct ::wl_data_device *object);
+        static void handle_selection(
+            void *data,
+            struct ::wl_data_device *object,
+            struct ::wl_data_offer *id);
+        struct ::wl_data_device *m_wl_data_device;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_data_device_manager
+    {
+    public:
+        wl_data_device_manager(struct ::wl_registry *registry, int id, int version);
+        wl_data_device_manager(struct ::wl_data_device_manager *object);
+        wl_data_device_manager();
+
+        virtual ~wl_data_device_manager();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_data_device_manager *object);
+
+        struct ::wl_data_device_manager *object() { return m_wl_data_device_manager; }
+        const struct ::wl_data_device_manager *object() const { return m_wl_data_device_manager; }
+        static wl_data_device_manager *fromObject(struct ::wl_data_device_manager *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum dnd_action {
+            dnd_action_none = 0, // no action
+            dnd_action_copy = 1, // copy action
+            dnd_action_move = 2, // move action
+            dnd_action_ask = 4, // ask action
+        };
+
+        struct ::wl_data_source *create_data_source();
+        struct ::wl_data_device *get_data_device(struct ::wl_seat *seat);
+
+    private:
+        struct ::wl_data_device_manager *m_wl_data_device_manager;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_shell
+    {
+    public:
+        wl_shell(struct ::wl_registry *registry, int id, int version);
+        wl_shell(struct ::wl_shell *object);
+        wl_shell();
+
+        virtual ~wl_shell();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_shell *object);
+
+        struct ::wl_shell *object() { return m_wl_shell; }
+        const struct ::wl_shell *object() const { return m_wl_shell; }
+        static wl_shell *fromObject(struct ::wl_shell *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_role = 0, // given wl_surface has another role
+        };
+
+        struct ::wl_shell_surface *get_shell_surface(struct ::wl_surface *surface);
+
+    private:
+        struct ::wl_shell *m_wl_shell;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_shell_surface
+    {
+    public:
+        wl_shell_surface(struct ::wl_registry *registry, int id, int version);
+        wl_shell_surface(struct ::wl_shell_surface *object);
+        wl_shell_surface();
+
+        virtual ~wl_shell_surface();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_shell_surface *object);
+
+        struct ::wl_shell_surface *object() { return m_wl_shell_surface; }
+        const struct ::wl_shell_surface *object() const { return m_wl_shell_surface; }
+        static wl_shell_surface *fromObject(struct ::wl_shell_surface *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum resize {
+            resize_none = 0, // no edge
+            resize_top = 1, // top edge
+            resize_bottom = 2, // bottom edge
+            resize_left = 4, // left edge
+            resize_top_left = 5, // top and left edges
+            resize_bottom_left = 6, // bottom and left edges
+            resize_right = 8, // right edge
+            resize_top_right = 9, // top and right edges
+            resize_bottom_right = 10, // bottom and right edges
+        };
+
+        enum transient {
+            transient_inactive = 0x1, // do not set keyboard focus
+        };
+
+        enum fullscreen_method {
+            fullscreen_method_default = 0, // no preference, apply default policy
+            fullscreen_method_scale = 1, // scale, preserve the surface's aspect ratio and center on output
+            fullscreen_method_driver = 2, // switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
+            fullscreen_method_fill = 3, // no upscaling, center on output and add black borders to compensate size mismatch
+        };
+
+        void pong(uint32_t serial);
+        void move(struct ::wl_seat *seat, uint32_t serial);
+        void resize(struct ::wl_seat *seat, uint32_t serial, uint32_t edges);
+        void set_toplevel();
+        void set_transient(struct ::wl_surface *parent, int32_t x, int32_t y, uint32_t flags);
+        void set_fullscreen(uint32_t method, uint32_t framerate, struct ::wl_output *output);
+        void set_popup(struct ::wl_seat *seat, uint32_t serial, struct ::wl_surface *parent, int32_t x, int32_t y, uint32_t flags);
+        void set_maximized(struct ::wl_output *output);
+        void set_title(const QString &title);
+        void set_class(const QString &class_);
+
+    protected:
+        virtual void shell_surface_ping(uint32_t serial);
+        virtual void shell_surface_configure(uint32_t edges, int32_t width, int32_t height);
+        virtual void shell_surface_popup_done();
+
+    private:
+        void init_listener();
+        static const struct wl_shell_surface_listener m_wl_shell_surface_listener;
+        static void handle_ping(
+            void *data,
+            struct ::wl_shell_surface *object,
+            uint32_t serial);
+        static void handle_configure(
+            void *data,
+            struct ::wl_shell_surface *object,
+            uint32_t edges,
+            int32_t width,
+            int32_t height);
+        static void handle_popup_done(
+            void *data,
+            struct ::wl_shell_surface *object);
+        struct ::wl_shell_surface *m_wl_shell_surface;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_surface
+    {
+    public:
+        wl_surface(struct ::wl_registry *registry, int id, int version);
+        wl_surface(struct ::wl_surface *object);
+        wl_surface();
+
+        virtual ~wl_surface();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_surface *object);
+
+        struct ::wl_surface *object() { return m_wl_surface; }
+        const struct ::wl_surface *object() const { return m_wl_surface; }
+        static wl_surface *fromObject(struct ::wl_surface *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_invalid_scale = 0, // buffer scale value is invalid
+            error_invalid_transform = 1, // buffer transform value is invalid
+        };
+
+        void destroy();
+        void attach(struct ::wl_buffer *buffer, int32_t x, int32_t y);
+        void damage(int32_t x, int32_t y, int32_t width, int32_t height);
+        struct ::wl_callback *frame();
+        void set_opaque_region(struct ::wl_region *region);
+        void set_input_region(struct ::wl_region *region);
+        void commit();
+        void set_buffer_transform(int32_t transform);
+        void set_buffer_scale(int32_t scale);
+        void damage_buffer(int32_t x, int32_t y, int32_t width, int32_t height);
+
+    protected:
+        virtual void surface_enter(struct ::wl_output *output);
+        virtual void surface_leave(struct ::wl_output *output);
+
+    private:
+        void init_listener();
+        static const struct wl_surface_listener m_wl_surface_listener;
+        static void handle_enter(
+            void *data,
+            struct ::wl_surface *object,
+            struct ::wl_output *output);
+        static void handle_leave(
+            void *data,
+            struct ::wl_surface *object,
+            struct ::wl_output *output);
+        struct ::wl_surface *m_wl_surface;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_seat
+    {
+    public:
+        wl_seat(struct ::wl_registry *registry, int id, int version);
+        wl_seat(struct ::wl_seat *object);
+        wl_seat();
+
+        virtual ~wl_seat();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_seat *object);
+
+        struct ::wl_seat *object() { return m_wl_seat; }
+        const struct ::wl_seat *object() const { return m_wl_seat; }
+        static wl_seat *fromObject(struct ::wl_seat *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum capability {
+            capability_pointer = 1, // the seat has pointer devices
+            capability_keyboard = 2, // the seat has one or more keyboards
+            capability_touch = 4, // the seat has touch devices
+        };
+
+        struct ::wl_pointer *get_pointer();
+        struct ::wl_keyboard *get_keyboard();
+        struct ::wl_touch *get_touch();
+        void release();
+
+    protected:
+        virtual void seat_capabilities(uint32_t capabilities);
+        virtual void seat_name(const QString &name);
+
+    private:
+        void init_listener();
+        static const struct wl_seat_listener m_wl_seat_listener;
+        static void handle_capabilities(
+            void *data,
+            struct ::wl_seat *object,
+            uint32_t capabilities);
+        static void handle_name(
+            void *data,
+            struct ::wl_seat *object,
+            const char *name);
+        struct ::wl_seat *m_wl_seat;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_pointer
+    {
+    public:
+        wl_pointer(struct ::wl_registry *registry, int id, int version);
+        wl_pointer(struct ::wl_pointer *object);
+        wl_pointer();
+
+        virtual ~wl_pointer();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_pointer *object);
+
+        struct ::wl_pointer *object() { return m_wl_pointer; }
+        const struct ::wl_pointer *object() const { return m_wl_pointer; }
+        static wl_pointer *fromObject(struct ::wl_pointer *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_role = 0, // given wl_surface has another role
+        };
+
+        enum button_state {
+            button_state_released = 0, // the button is not pressed
+            button_state_pressed = 1, // the button is pressed
+        };
+
+        enum axis {
+            axis_vertical_scroll = 0, // vertical axis
+            axis_horizontal_scroll = 1, // horizontal axis
+        };
+
+        enum axis_source {
+            axis_source_wheel = 0, // a physical wheel rotation
+            axis_source_finger = 1, // finger on a touch surface
+            axis_source_continuous = 2, // continuous coordinate space
+            axis_source_wheel_tilt = 3, // a physical wheel tilt
+        };
+
+        void set_cursor(uint32_t serial, struct ::wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y);
+        void release();
+
+    protected:
+        virtual void pointer_enter(uint32_t serial, struct ::wl_surface *surface, wl_fixed_t surface_x, wl_fixed_t surface_y);
+        virtual void pointer_leave(uint32_t serial, struct ::wl_surface *surface);
+        virtual void pointer_motion(uint32_t time, wl_fixed_t surface_x, wl_fixed_t surface_y);
+        virtual void pointer_button(uint32_t serial, uint32_t time, uint32_t button, uint32_t state);
+        virtual void pointer_axis(uint32_t time, uint32_t axis, wl_fixed_t value);
+        virtual void pointer_frame();
+        virtual void pointer_axis_source(uint32_t axis_source);
+        virtual void pointer_axis_stop(uint32_t time, uint32_t axis);
+        virtual void pointer_axis_discrete(uint32_t axis, int32_t discrete);
+
+    private:
+        void init_listener();
+        static const struct wl_pointer_listener m_wl_pointer_listener;
+        static void handle_enter(
+            void *data,
+            struct ::wl_pointer *object,
+            uint32_t serial,
+            struct ::wl_surface *surface,
+            wl_fixed_t surface_x,
+            wl_fixed_t surface_y);
+        static void handle_leave(
+            void *data,
+            struct ::wl_pointer *object,
+            uint32_t serial,
+            struct ::wl_surface *surface);
+        static void handle_motion(
+            void *data,
+            struct ::wl_pointer *object,
+            uint32_t time,
+            wl_fixed_t surface_x,
+            wl_fixed_t surface_y);
+        static void handle_button(
+            void *data,
+            struct ::wl_pointer *object,
+            uint32_t serial,
+            uint32_t time,
+            uint32_t button,
+            uint32_t state);
+        static void handle_axis(
+            void *data,
+            struct ::wl_pointer *object,
+            uint32_t time,
+            uint32_t axis,
+            wl_fixed_t value);
+        static void handle_frame(
+            void *data,
+            struct ::wl_pointer *object);
+        static void handle_axis_source(
+            void *data,
+            struct ::wl_pointer *object,
+            uint32_t axis_source);
+        static void handle_axis_stop(
+            void *data,
+            struct ::wl_pointer *object,
+            uint32_t time,
+            uint32_t axis);
+        static void handle_axis_discrete(
+            void *data,
+            struct ::wl_pointer *object,
+            uint32_t axis,
+            int32_t discrete);
+        struct ::wl_pointer *m_wl_pointer;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_keyboard
+    {
+    public:
+        wl_keyboard(struct ::wl_registry *registry, int id, int version);
+        wl_keyboard(struct ::wl_keyboard *object);
+        wl_keyboard();
+
+        virtual ~wl_keyboard();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_keyboard *object);
+
+        struct ::wl_keyboard *object() { return m_wl_keyboard; }
+        const struct ::wl_keyboard *object() const { return m_wl_keyboard; }
+        static wl_keyboard *fromObject(struct ::wl_keyboard *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum keymap_format {
+            keymap_format_no_keymap = 0, // no keymap; client must understand how to interpret the raw keycode
+            keymap_format_xkb_v1 = 1, // libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
+        };
+
+        enum key_state {
+            key_state_released = 0, // key is not pressed
+            key_state_pressed = 1, // key is pressed
+        };
+
+        void release();
+
+    protected:
+        virtual void keyboard_keymap(uint32_t format, int32_t fd, uint32_t size);
+        virtual void keyboard_enter(uint32_t serial, struct ::wl_surface *surface, wl_array *keys);
+        virtual void keyboard_leave(uint32_t serial, struct ::wl_surface *surface);
+        virtual void keyboard_key(uint32_t serial, uint32_t time, uint32_t key, uint32_t state);
+        virtual void keyboard_modifiers(uint32_t serial, uint32_t mods_depressed, uint32_t mods_latched, uint32_t mods_locked, uint32_t group);
+        virtual void keyboard_repeat_info(int32_t rate, int32_t delay);
+
+    private:
+        void init_listener();
+        static const struct wl_keyboard_listener m_wl_keyboard_listener;
+        static void handle_keymap(
+            void *data,
+            struct ::wl_keyboard *object,
+            uint32_t format,
+            int32_t fd,
+            uint32_t size);
+        static void handle_enter(
+            void *data,
+            struct ::wl_keyboard *object,
+            uint32_t serial,
+            struct ::wl_surface *surface,
+            wl_array *keys);
+        static void handle_leave(
+            void *data,
+            struct ::wl_keyboard *object,
+            uint32_t serial,
+            struct ::wl_surface *surface);
+        static void handle_key(
+            void *data,
+            struct ::wl_keyboard *object,
+            uint32_t serial,
+            uint32_t time,
+            uint32_t key,
+            uint32_t state);
+        static void handle_modifiers(
+            void *data,
+            struct ::wl_keyboard *object,
+            uint32_t serial,
+            uint32_t mods_depressed,
+            uint32_t mods_latched,
+            uint32_t mods_locked,
+            uint32_t group);
+        static void handle_repeat_info(
+            void *data,
+            struct ::wl_keyboard *object,
+            int32_t rate,
+            int32_t delay);
+        struct ::wl_keyboard *m_wl_keyboard;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_touch
+    {
+    public:
+        wl_touch(struct ::wl_registry *registry, int id, int version);
+        wl_touch(struct ::wl_touch *object);
+        wl_touch();
+
+        virtual ~wl_touch();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_touch *object);
+
+        struct ::wl_touch *object() { return m_wl_touch; }
+        const struct ::wl_touch *object() const { return m_wl_touch; }
+        static wl_touch *fromObject(struct ::wl_touch *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void release();
+
+    protected:
+        virtual void touch_down(uint32_t serial, uint32_t time, struct ::wl_surface *surface, int32_t id, wl_fixed_t x, wl_fixed_t y);
+        virtual void touch_up(uint32_t serial, uint32_t time, int32_t id);
+        virtual void touch_motion(uint32_t time, int32_t id, wl_fixed_t x, wl_fixed_t y);
+        virtual void touch_frame();
+        virtual void touch_cancel();
+        virtual void touch_shape(int32_t id, wl_fixed_t major, wl_fixed_t minor);
+        virtual void touch_orientation(int32_t id, wl_fixed_t orientation);
+
+    private:
+        void init_listener();
+        static const struct wl_touch_listener m_wl_touch_listener;
+        static void handle_down(
+            void *data,
+            struct ::wl_touch *object,
+            uint32_t serial,
+            uint32_t time,
+            struct ::wl_surface *surface,
+            int32_t id,
+            wl_fixed_t x,
+            wl_fixed_t y);
+        static void handle_up(
+            void *data,
+            struct ::wl_touch *object,
+            uint32_t serial,
+            uint32_t time,
+            int32_t id);
+        static void handle_motion(
+            void *data,
+            struct ::wl_touch *object,
+            uint32_t time,
+            int32_t id,
+            wl_fixed_t x,
+            wl_fixed_t y);
+        static void handle_frame(
+            void *data,
+            struct ::wl_touch *object);
+        static void handle_cancel(
+            void *data,
+            struct ::wl_touch *object);
+        static void handle_shape(
+            void *data,
+            struct ::wl_touch *object,
+            int32_t id,
+            wl_fixed_t major,
+            wl_fixed_t minor);
+        static void handle_orientation(
+            void *data,
+            struct ::wl_touch *object,
+            int32_t id,
+            wl_fixed_t orientation);
+        struct ::wl_touch *m_wl_touch;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_output
+    {
+    public:
+        wl_output(struct ::wl_registry *registry, int id, int version);
+        wl_output(struct ::wl_output *object);
+        wl_output();
+
+        virtual ~wl_output();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_output *object);
+
+        struct ::wl_output *object() { return m_wl_output; }
+        const struct ::wl_output *object() const { return m_wl_output; }
+        static wl_output *fromObject(struct ::wl_output *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum subpixel {
+            subpixel_unknown = 0, // unknown geometry
+            subpixel_none = 1, // no geometry
+            subpixel_horizontal_rgb = 2, // horizontal RGB
+            subpixel_horizontal_bgr = 3, // horizontal BGR
+            subpixel_vertical_rgb = 4, // vertical RGB
+            subpixel_vertical_bgr = 5, // vertical BGR
+        };
+
+        enum transform {
+            transform_normal = 0, // no transform
+            transform_90 = 1, // 90 degrees counter-clockwise
+            transform_180 = 2, // 180 degrees counter-clockwise
+            transform_270 = 3, // 270 degrees counter-clockwise
+            transform_flipped = 4, // 180 degree flip around a vertical axis
+            transform_flipped_90 = 5, // flip and rotate 90 degrees counter-clockwise
+            transform_flipped_180 = 6, // flip and rotate 180 degrees counter-clockwise
+            transform_flipped_270 = 7, // flip and rotate 270 degrees counter-clockwise
+        };
+
+        enum mode {
+            mode_current = 0x1, // indicates this is the current mode
+            mode_preferred = 0x2, // indicates this is the preferred mode
+        };
+
+        void release();
+
+    protected:
+        virtual void output_geometry(int32_t x, int32_t y, int32_t physical_width, int32_t physical_height, int32_t subpixel, const QString &make, const QString &model, int32_t transform);
+        virtual void output_mode(uint32_t flags, int32_t width, int32_t height, int32_t refresh);
+        virtual void output_done();
+        virtual void output_scale(int32_t factor);
+
+    private:
+        void init_listener();
+        static const struct wl_output_listener m_wl_output_listener;
+        static void handle_geometry(
+            void *data,
+            struct ::wl_output *object,
+            int32_t x,
+            int32_t y,
+            int32_t physical_width,
+            int32_t physical_height,
+            int32_t subpixel,
+            const char *make,
+            const char *model,
+            int32_t transform);
+        static void handle_mode(
+            void *data,
+            struct ::wl_output *object,
+            uint32_t flags,
+            int32_t width,
+            int32_t height,
+            int32_t refresh);
+        static void handle_done(
+            void *data,
+            struct ::wl_output *object);
+        static void handle_scale(
+            void *data,
+            struct ::wl_output *object,
+            int32_t factor);
+        struct ::wl_output *m_wl_output;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_region
+    {
+    public:
+        wl_region(struct ::wl_registry *registry, int id, int version);
+        wl_region(struct ::wl_region *object);
+        wl_region();
+
+        virtual ~wl_region();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_region *object);
+
+        struct ::wl_region *object() { return m_wl_region; }
+        const struct ::wl_region *object() const { return m_wl_region; }
+        static wl_region *fromObject(struct ::wl_region *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+        void add(int32_t x, int32_t y, int32_t width, int32_t height);
+        void subtract(int32_t x, int32_t y, int32_t width, int32_t height);
+
+    private:
+        struct ::wl_region *m_wl_region;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_subcompositor
+    {
+    public:
+        wl_subcompositor(struct ::wl_registry *registry, int id, int version);
+        wl_subcompositor(struct ::wl_subcompositor *object);
+        wl_subcompositor();
+
+        virtual ~wl_subcompositor();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_subcompositor *object);
+
+        struct ::wl_subcompositor *object() { return m_wl_subcompositor; }
+        const struct ::wl_subcompositor *object() const { return m_wl_subcompositor; }
+        static wl_subcompositor *fromObject(struct ::wl_subcompositor *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_bad_surface = 0, // the to-be sub-surface is invalid
+        };
+
+        void destroy();
+        struct ::wl_subsurface *get_subsurface(struct ::wl_surface *surface, struct ::wl_surface *parent);
+
+    private:
+        struct ::wl_subcompositor *m_wl_subcompositor;
+    };
+
+    class Q_WAYLAND_CLIENT_WAYLAND_EXPORT wl_subsurface
+    {
+    public:
+        wl_subsurface(struct ::wl_registry *registry, int id, int version);
+        wl_subsurface(struct ::wl_subsurface *object);
+        wl_subsurface();
+
+        virtual ~wl_subsurface();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::wl_subsurface *object);
+
+        struct ::wl_subsurface *object() { return m_wl_subsurface; }
+        const struct ::wl_subsurface *object() const { return m_wl_subsurface; }
+        static wl_subsurface *fromObject(struct ::wl_subsurface *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_bad_surface = 0, // wl_surface is not a sibling or the parent
+        };
+
+        void destroy();
+        void set_position(int32_t x, int32_t y);
+        void place_above(struct ::wl_surface *sibling);
+        void place_below(struct ::wl_surface *sibling);
+        void set_sync();
+        void set_desync();
+
+    private:
+        struct ::wl_subsurface *m_wl_subsurface;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-wp-primary-selection-unstable-v1.cpp b/src/client/qwayland-wp-primary-selection-unstable-v1.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..ba0b56d171fbac646d1f462fb6e3d5a37b44cc88
--- /dev/null
+++ a/qtwayland/src/client/qwayland-wp-primary-selection-unstable-v1.cpp
@@ -0,0 +1,380 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/wp-primary-selection-unstable-v1.xml
+
+#include <QtWaylandClient/private/qwayland-wp-primary-selection-unstable-v1.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    zwp_primary_selection_device_manager_v1::zwp_primary_selection_device_manager_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_primary_selection_device_manager_v1::zwp_primary_selection_device_manager_v1(struct ::zwp_primary_selection_device_manager_v1 *obj)
+        : m_zwp_primary_selection_device_manager_v1(obj)
+    {
+    }
+
+    zwp_primary_selection_device_manager_v1::zwp_primary_selection_device_manager_v1()
+        : m_zwp_primary_selection_device_manager_v1(nullptr)
+    {
+    }
+
+    zwp_primary_selection_device_manager_v1::~zwp_primary_selection_device_manager_v1()
+    {
+    }
+
+    void zwp_primary_selection_device_manager_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_primary_selection_device_manager_v1 = static_cast<struct ::zwp_primary_selection_device_manager_v1 *>(wlRegistryBind(registry, id, &zwp_primary_selection_device_manager_v1_interface, version));
+    }
+
+    void zwp_primary_selection_device_manager_v1::init(struct ::zwp_primary_selection_device_manager_v1 *obj)
+    {
+        m_zwp_primary_selection_device_manager_v1 = obj;
+    }
+
+    zwp_primary_selection_device_manager_v1 *zwp_primary_selection_device_manager_v1::fromObject(struct ::zwp_primary_selection_device_manager_v1 *object)
+    {
+        return static_cast<zwp_primary_selection_device_manager_v1 *>(zwp_primary_selection_device_manager_v1_get_user_data(object));
+    }
+
+    bool zwp_primary_selection_device_manager_v1::isInitialized() const
+    {
+        return m_zwp_primary_selection_device_manager_v1 != nullptr;
+    }
+
+    const struct wl_interface *zwp_primary_selection_device_manager_v1::interface()
+    {
+        return &::zwp_primary_selection_device_manager_v1_interface;
+    }
+
+    struct ::zwp_primary_selection_source_v1 *zwp_primary_selection_device_manager_v1::create_source()
+    {
+        return zwp_primary_selection_device_manager_v1_create_source(
+            m_zwp_primary_selection_device_manager_v1);
+    }
+
+    struct ::zwp_primary_selection_device_v1 *zwp_primary_selection_device_manager_v1::get_device(struct ::wl_seat *seat)
+    {
+        return zwp_primary_selection_device_manager_v1_get_device(
+            m_zwp_primary_selection_device_manager_v1,
+            seat);
+    }
+
+    void zwp_primary_selection_device_manager_v1::destroy()
+    {
+        zwp_primary_selection_device_manager_v1_destroy(
+            m_zwp_primary_selection_device_manager_v1);
+        m_zwp_primary_selection_device_manager_v1 = nullptr;
+    }
+
+    zwp_primary_selection_device_v1::zwp_primary_selection_device_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_primary_selection_device_v1::zwp_primary_selection_device_v1(struct ::zwp_primary_selection_device_v1 *obj)
+        : m_zwp_primary_selection_device_v1(obj)
+    {
+        init_listener();
+    }
+
+    zwp_primary_selection_device_v1::zwp_primary_selection_device_v1()
+        : m_zwp_primary_selection_device_v1(nullptr)
+    {
+    }
+
+    zwp_primary_selection_device_v1::~zwp_primary_selection_device_v1()
+    {
+    }
+
+    void zwp_primary_selection_device_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_primary_selection_device_v1 = static_cast<struct ::zwp_primary_selection_device_v1 *>(wlRegistryBind(registry, id, &zwp_primary_selection_device_v1_interface, version));
+        init_listener();
+    }
+
+    void zwp_primary_selection_device_v1::init(struct ::zwp_primary_selection_device_v1 *obj)
+    {
+        m_zwp_primary_selection_device_v1 = obj;
+        init_listener();
+    }
+
+    zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1::fromObject(struct ::zwp_primary_selection_device_v1 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_primary_selection_device_v1_listener)
+            return nullptr;
+        return static_cast<zwp_primary_selection_device_v1 *>(zwp_primary_selection_device_v1_get_user_data(object));
+    }
+
+    bool zwp_primary_selection_device_v1::isInitialized() const
+    {
+        return m_zwp_primary_selection_device_v1 != nullptr;
+    }
+
+    const struct wl_interface *zwp_primary_selection_device_v1::interface()
+    {
+        return &::zwp_primary_selection_device_v1_interface;
+    }
+
+    void zwp_primary_selection_device_v1::set_selection(struct ::zwp_primary_selection_source_v1 *source, uint32_t serial)
+    {
+        zwp_primary_selection_device_v1_set_selection(
+            m_zwp_primary_selection_device_v1,
+            source,
+            serial);
+    }
+
+    void zwp_primary_selection_device_v1::destroy()
+    {
+        zwp_primary_selection_device_v1_destroy(
+            m_zwp_primary_selection_device_v1);
+        m_zwp_primary_selection_device_v1 = nullptr;
+    }
+
+    void zwp_primary_selection_device_v1::zwp_primary_selection_device_v1_data_offer(struct ::zwp_primary_selection_offer_v1 *)
+    {
+    }
+
+    void zwp_primary_selection_device_v1::handle_data_offer(
+        void *data,
+        struct ::zwp_primary_selection_device_v1 *object,
+        struct ::zwp_primary_selection_offer_v1 *offer)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_primary_selection_device_v1 *>(data)->zwp_primary_selection_device_v1_data_offer(
+            offer);
+    }
+
+    void zwp_primary_selection_device_v1::zwp_primary_selection_device_v1_selection(struct ::zwp_primary_selection_offer_v1 *)
+    {
+    }
+
+    void zwp_primary_selection_device_v1::handle_selection(
+        void *data,
+        struct ::zwp_primary_selection_device_v1 *object,
+        struct ::zwp_primary_selection_offer_v1 *id)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_primary_selection_device_v1 *>(data)->zwp_primary_selection_device_v1_selection(
+            id);
+    }
+
+    const struct zwp_primary_selection_device_v1_listener zwp_primary_selection_device_v1::m_zwp_primary_selection_device_v1_listener = {
+        zwp_primary_selection_device_v1::handle_data_offer,
+        zwp_primary_selection_device_v1::handle_selection,
+    };
+
+    void zwp_primary_selection_device_v1::init_listener()
+    {
+        zwp_primary_selection_device_v1_add_listener(m_zwp_primary_selection_device_v1, &m_zwp_primary_selection_device_v1_listener, this);
+    }
+
+    zwp_primary_selection_offer_v1::zwp_primary_selection_offer_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_primary_selection_offer_v1::zwp_primary_selection_offer_v1(struct ::zwp_primary_selection_offer_v1 *obj)
+        : m_zwp_primary_selection_offer_v1(obj)
+    {
+        init_listener();
+    }
+
+    zwp_primary_selection_offer_v1::zwp_primary_selection_offer_v1()
+        : m_zwp_primary_selection_offer_v1(nullptr)
+    {
+    }
+
+    zwp_primary_selection_offer_v1::~zwp_primary_selection_offer_v1()
+    {
+    }
+
+    void zwp_primary_selection_offer_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_primary_selection_offer_v1 = static_cast<struct ::zwp_primary_selection_offer_v1 *>(wlRegistryBind(registry, id, &zwp_primary_selection_offer_v1_interface, version));
+        init_listener();
+    }
+
+    void zwp_primary_selection_offer_v1::init(struct ::zwp_primary_selection_offer_v1 *obj)
+    {
+        m_zwp_primary_selection_offer_v1 = obj;
+        init_listener();
+    }
+
+    zwp_primary_selection_offer_v1 *zwp_primary_selection_offer_v1::fromObject(struct ::zwp_primary_selection_offer_v1 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_primary_selection_offer_v1_listener)
+            return nullptr;
+        return static_cast<zwp_primary_selection_offer_v1 *>(zwp_primary_selection_offer_v1_get_user_data(object));
+    }
+
+    bool zwp_primary_selection_offer_v1::isInitialized() const
+    {
+        return m_zwp_primary_selection_offer_v1 != nullptr;
+    }
+
+    const struct wl_interface *zwp_primary_selection_offer_v1::interface()
+    {
+        return &::zwp_primary_selection_offer_v1_interface;
+    }
+
+    void zwp_primary_selection_offer_v1::receive(const QString &mime_type, int32_t fd)
+    {
+        zwp_primary_selection_offer_v1_receive(
+            m_zwp_primary_selection_offer_v1,
+            mime_type.toUtf8().constData(),
+            fd);
+    }
+
+    void zwp_primary_selection_offer_v1::destroy()
+    {
+        zwp_primary_selection_offer_v1_destroy(
+            m_zwp_primary_selection_offer_v1);
+        m_zwp_primary_selection_offer_v1 = nullptr;
+    }
+
+    void zwp_primary_selection_offer_v1::zwp_primary_selection_offer_v1_offer(const QString &)
+    {
+    }
+
+    void zwp_primary_selection_offer_v1::handle_offer(
+        void *data,
+        struct ::zwp_primary_selection_offer_v1 *object,
+        const char *mime_type)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_primary_selection_offer_v1 *>(data)->zwp_primary_selection_offer_v1_offer(
+            QString::fromUtf8(mime_type));
+    }
+
+    const struct zwp_primary_selection_offer_v1_listener zwp_primary_selection_offer_v1::m_zwp_primary_selection_offer_v1_listener = {
+        zwp_primary_selection_offer_v1::handle_offer,
+    };
+
+    void zwp_primary_selection_offer_v1::init_listener()
+    {
+        zwp_primary_selection_offer_v1_add_listener(m_zwp_primary_selection_offer_v1, &m_zwp_primary_selection_offer_v1_listener, this);
+    }
+
+    zwp_primary_selection_source_v1::zwp_primary_selection_source_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zwp_primary_selection_source_v1::zwp_primary_selection_source_v1(struct ::zwp_primary_selection_source_v1 *obj)
+        : m_zwp_primary_selection_source_v1(obj)
+    {
+        init_listener();
+    }
+
+    zwp_primary_selection_source_v1::zwp_primary_selection_source_v1()
+        : m_zwp_primary_selection_source_v1(nullptr)
+    {
+    }
+
+    zwp_primary_selection_source_v1::~zwp_primary_selection_source_v1()
+    {
+    }
+
+    void zwp_primary_selection_source_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zwp_primary_selection_source_v1 = static_cast<struct ::zwp_primary_selection_source_v1 *>(wlRegistryBind(registry, id, &zwp_primary_selection_source_v1_interface, version));
+        init_listener();
+    }
+
+    void zwp_primary_selection_source_v1::init(struct ::zwp_primary_selection_source_v1 *obj)
+    {
+        m_zwp_primary_selection_source_v1 = obj;
+        init_listener();
+    }
+
+    zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1::fromObject(struct ::zwp_primary_selection_source_v1 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zwp_primary_selection_source_v1_listener)
+            return nullptr;
+        return static_cast<zwp_primary_selection_source_v1 *>(zwp_primary_selection_source_v1_get_user_data(object));
+    }
+
+    bool zwp_primary_selection_source_v1::isInitialized() const
+    {
+        return m_zwp_primary_selection_source_v1 != nullptr;
+    }
+
+    const struct wl_interface *zwp_primary_selection_source_v1::interface()
+    {
+        return &::zwp_primary_selection_source_v1_interface;
+    }
+
+    void zwp_primary_selection_source_v1::offer(const QString &mime_type)
+    {
+        zwp_primary_selection_source_v1_offer(
+            m_zwp_primary_selection_source_v1,
+            mime_type.toUtf8().constData());
+    }
+
+    void zwp_primary_selection_source_v1::destroy()
+    {
+        zwp_primary_selection_source_v1_destroy(
+            m_zwp_primary_selection_source_v1);
+        m_zwp_primary_selection_source_v1 = nullptr;
+    }
+
+    void zwp_primary_selection_source_v1::zwp_primary_selection_source_v1_send(const QString &, int32_t )
+    {
+    }
+
+    void zwp_primary_selection_source_v1::handle_send(
+        void *data,
+        struct ::zwp_primary_selection_source_v1 *object,
+        const char *mime_type,
+        int32_t fd)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_primary_selection_source_v1 *>(data)->zwp_primary_selection_source_v1_send(
+            QString::fromUtf8(mime_type),
+            fd);
+    }
+
+    void zwp_primary_selection_source_v1::zwp_primary_selection_source_v1_cancelled()
+    {
+    }
+
+    void zwp_primary_selection_source_v1::handle_cancelled(
+        void *data,
+        struct ::zwp_primary_selection_source_v1 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zwp_primary_selection_source_v1 *>(data)->zwp_primary_selection_source_v1_cancelled();
+    }
+
+    const struct zwp_primary_selection_source_v1_listener zwp_primary_selection_source_v1::m_zwp_primary_selection_source_v1_listener = {
+        zwp_primary_selection_source_v1::handle_send,
+        zwp_primary_selection_source_v1::handle_cancelled,
+    };
+
+    void zwp_primary_selection_source_v1::init_listener()
+    {
+        zwp_primary_selection_source_v1_add_listener(m_zwp_primary_selection_source_v1, &m_zwp_primary_selection_source_v1_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-wp-primary-selection-unstable-v1.h b/src/client/qwayland-wp-primary-selection-unstable-v1.h
new file mode 100644
index 0000000000000000000000000000000000000000..2152a9470c303799671a43cb7eb00e56a688fd15
--- /dev/null
+++ a/qtwayland/src/client/qwayland-wp-primary-selection-unstable-v1.h
@@ -0,0 +1,176 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/wp-primary-selection-unstable-v1.xml
+
+#ifndef QT_WAYLAND_WP_PRIMARY_SELECTION_UNSTABLE_V1
+#define QT_WAYLAND_WP_PRIMARY_SELECTION_UNSTABLE_V1
+
+#include <QtWaylandClient/private/wayland-wp-primary-selection-unstable-v1-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_WP_PRIMARY_SELECTION_UNSTABLE_V1_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_WP_PRIMARY_SELECTION_UNSTABLE_V1_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_WP_PRIMARY_SELECTION_UNSTABLE_V1_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_WP_PRIMARY_SELECTION_UNSTABLE_V1_EXPORT zwp_primary_selection_device_manager_v1
+    {
+    public:
+        zwp_primary_selection_device_manager_v1(struct ::wl_registry *registry, int id, int version);
+        zwp_primary_selection_device_manager_v1(struct ::zwp_primary_selection_device_manager_v1 *object);
+        zwp_primary_selection_device_manager_v1();
+
+        virtual ~zwp_primary_selection_device_manager_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_primary_selection_device_manager_v1 *object);
+
+        struct ::zwp_primary_selection_device_manager_v1 *object() { return m_zwp_primary_selection_device_manager_v1; }
+        const struct ::zwp_primary_selection_device_manager_v1 *object() const { return m_zwp_primary_selection_device_manager_v1; }
+        static zwp_primary_selection_device_manager_v1 *fromObject(struct ::zwp_primary_selection_device_manager_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        struct ::zwp_primary_selection_source_v1 *create_source();
+        struct ::zwp_primary_selection_device_v1 *get_device(struct ::wl_seat *seat);
+        void destroy();
+
+    private:
+        struct ::zwp_primary_selection_device_manager_v1 *m_zwp_primary_selection_device_manager_v1;
+    };
+
+    class Q_WAYLAND_CLIENT_WP_PRIMARY_SELECTION_UNSTABLE_V1_EXPORT zwp_primary_selection_device_v1
+    {
+    public:
+        zwp_primary_selection_device_v1(struct ::wl_registry *registry, int id, int version);
+        zwp_primary_selection_device_v1(struct ::zwp_primary_selection_device_v1 *object);
+        zwp_primary_selection_device_v1();
+
+        virtual ~zwp_primary_selection_device_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_primary_selection_device_v1 *object);
+
+        struct ::zwp_primary_selection_device_v1 *object() { return m_zwp_primary_selection_device_v1; }
+        const struct ::zwp_primary_selection_device_v1 *object() const { return m_zwp_primary_selection_device_v1; }
+        static zwp_primary_selection_device_v1 *fromObject(struct ::zwp_primary_selection_device_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void set_selection(struct ::zwp_primary_selection_source_v1 *source, uint32_t serial);
+        void destroy();
+
+    protected:
+        virtual void zwp_primary_selection_device_v1_data_offer(struct ::zwp_primary_selection_offer_v1 *offer);
+        virtual void zwp_primary_selection_device_v1_selection(struct ::zwp_primary_selection_offer_v1 *id);
+
+    private:
+        void init_listener();
+        static const struct zwp_primary_selection_device_v1_listener m_zwp_primary_selection_device_v1_listener;
+        static void handle_data_offer(
+            void *data,
+            struct ::zwp_primary_selection_device_v1 *object,
+            struct ::zwp_primary_selection_offer_v1 *offer);
+        static void handle_selection(
+            void *data,
+            struct ::zwp_primary_selection_device_v1 *object,
+            struct ::zwp_primary_selection_offer_v1 *id);
+        struct ::zwp_primary_selection_device_v1 *m_zwp_primary_selection_device_v1;
+    };
+
+    class Q_WAYLAND_CLIENT_WP_PRIMARY_SELECTION_UNSTABLE_V1_EXPORT zwp_primary_selection_offer_v1
+    {
+    public:
+        zwp_primary_selection_offer_v1(struct ::wl_registry *registry, int id, int version);
+        zwp_primary_selection_offer_v1(struct ::zwp_primary_selection_offer_v1 *object);
+        zwp_primary_selection_offer_v1();
+
+        virtual ~zwp_primary_selection_offer_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_primary_selection_offer_v1 *object);
+
+        struct ::zwp_primary_selection_offer_v1 *object() { return m_zwp_primary_selection_offer_v1; }
+        const struct ::zwp_primary_selection_offer_v1 *object() const { return m_zwp_primary_selection_offer_v1; }
+        static zwp_primary_selection_offer_v1 *fromObject(struct ::zwp_primary_selection_offer_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void receive(const QString &mime_type, int32_t fd);
+        void destroy();
+
+    protected:
+        virtual void zwp_primary_selection_offer_v1_offer(const QString &mime_type);
+
+    private:
+        void init_listener();
+        static const struct zwp_primary_selection_offer_v1_listener m_zwp_primary_selection_offer_v1_listener;
+        static void handle_offer(
+            void *data,
+            struct ::zwp_primary_selection_offer_v1 *object,
+            const char *mime_type);
+        struct ::zwp_primary_selection_offer_v1 *m_zwp_primary_selection_offer_v1;
+    };
+
+    class Q_WAYLAND_CLIENT_WP_PRIMARY_SELECTION_UNSTABLE_V1_EXPORT zwp_primary_selection_source_v1
+    {
+    public:
+        zwp_primary_selection_source_v1(struct ::wl_registry *registry, int id, int version);
+        zwp_primary_selection_source_v1(struct ::zwp_primary_selection_source_v1 *object);
+        zwp_primary_selection_source_v1();
+
+        virtual ~zwp_primary_selection_source_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zwp_primary_selection_source_v1 *object);
+
+        struct ::zwp_primary_selection_source_v1 *object() { return m_zwp_primary_selection_source_v1; }
+        const struct ::zwp_primary_selection_source_v1 *object() const { return m_zwp_primary_selection_source_v1; }
+        static zwp_primary_selection_source_v1 *fromObject(struct ::zwp_primary_selection_source_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void offer(const QString &mime_type);
+        void destroy();
+
+    protected:
+        virtual void zwp_primary_selection_source_v1_send(const QString &mime_type, int32_t fd);
+        virtual void zwp_primary_selection_source_v1_cancelled();
+
+    private:
+        void init_listener();
+        static const struct zwp_primary_selection_source_v1_listener m_zwp_primary_selection_source_v1_listener;
+        static void handle_send(
+            void *data,
+            struct ::zwp_primary_selection_source_v1 *object,
+            const char *mime_type,
+            int32_t fd);
+        static void handle_cancelled(
+            void *data,
+            struct ::zwp_primary_selection_source_v1 *object);
+        struct ::zwp_primary_selection_source_v1 *m_zwp_primary_selection_source_v1;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwayland-xdg-output-unstable-v1.cpp b/src/client/qwayland-xdg-output-unstable-v1.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..d33a512edd15f6f73fff43bf69bea197f0acbbb7
--- /dev/null
+++ a/qtwayland/src/client/qwayland-xdg-output-unstable-v1.cpp
@@ -0,0 +1,225 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/xdg-output-unstable-v1.xml
+
+#include <QtWaylandClient/private/qwayland-xdg-output-unstable-v1.h>
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    zxdg_output_manager_v1::zxdg_output_manager_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zxdg_output_manager_v1::zxdg_output_manager_v1(struct ::zxdg_output_manager_v1 *obj)
+        : m_zxdg_output_manager_v1(obj)
+    {
+    }
+
+    zxdg_output_manager_v1::zxdg_output_manager_v1()
+        : m_zxdg_output_manager_v1(nullptr)
+    {
+    }
+
+    zxdg_output_manager_v1::~zxdg_output_manager_v1()
+    {
+    }
+
+    void zxdg_output_manager_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zxdg_output_manager_v1 = static_cast<struct ::zxdg_output_manager_v1 *>(wlRegistryBind(registry, id, &zxdg_output_manager_v1_interface, version));
+    }
+
+    void zxdg_output_manager_v1::init(struct ::zxdg_output_manager_v1 *obj)
+    {
+        m_zxdg_output_manager_v1 = obj;
+    }
+
+    zxdg_output_manager_v1 *zxdg_output_manager_v1::fromObject(struct ::zxdg_output_manager_v1 *object)
+    {
+        return static_cast<zxdg_output_manager_v1 *>(zxdg_output_manager_v1_get_user_data(object));
+    }
+
+    bool zxdg_output_manager_v1::isInitialized() const
+    {
+        return m_zxdg_output_manager_v1 != nullptr;
+    }
+
+    const struct wl_interface *zxdg_output_manager_v1::interface()
+    {
+        return &::zxdg_output_manager_v1_interface;
+    }
+
+    void zxdg_output_manager_v1::destroy()
+    {
+        zxdg_output_manager_v1_destroy(
+            m_zxdg_output_manager_v1);
+        m_zxdg_output_manager_v1 = nullptr;
+    }
+
+    struct ::zxdg_output_v1 *zxdg_output_manager_v1::get_xdg_output(struct ::wl_output *output)
+    {
+        return zxdg_output_manager_v1_get_xdg_output(
+            m_zxdg_output_manager_v1,
+            output);
+    }
+
+    zxdg_output_v1::zxdg_output_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zxdg_output_v1::zxdg_output_v1(struct ::zxdg_output_v1 *obj)
+        : m_zxdg_output_v1(obj)
+    {
+        init_listener();
+    }
+
+    zxdg_output_v1::zxdg_output_v1()
+        : m_zxdg_output_v1(nullptr)
+    {
+    }
+
+    zxdg_output_v1::~zxdg_output_v1()
+    {
+    }
+
+    void zxdg_output_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zxdg_output_v1 = static_cast<struct ::zxdg_output_v1 *>(wlRegistryBind(registry, id, &zxdg_output_v1_interface, version));
+        init_listener();
+    }
+
+    void zxdg_output_v1::init(struct ::zxdg_output_v1 *obj)
+    {
+        m_zxdg_output_v1 = obj;
+        init_listener();
+    }
+
+    zxdg_output_v1 *zxdg_output_v1::fromObject(struct ::zxdg_output_v1 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zxdg_output_v1_listener)
+            return nullptr;
+        return static_cast<zxdg_output_v1 *>(zxdg_output_v1_get_user_data(object));
+    }
+
+    bool zxdg_output_v1::isInitialized() const
+    {
+        return m_zxdg_output_v1 != nullptr;
+    }
+
+    const struct wl_interface *zxdg_output_v1::interface()
+    {
+        return &::zxdg_output_v1_interface;
+    }
+
+    void zxdg_output_v1::destroy()
+    {
+        zxdg_output_v1_destroy(
+            m_zxdg_output_v1);
+        m_zxdg_output_v1 = nullptr;
+    }
+
+    void zxdg_output_v1::zxdg_output_v1_logical_position(int32_t , int32_t )
+    {
+    }
+
+    void zxdg_output_v1::handle_logical_position(
+        void *data,
+        struct ::zxdg_output_v1 *object,
+        int32_t x,
+        int32_t y)
+    {
+        Q_UNUSED(object);
+        static_cast<zxdg_output_v1 *>(data)->zxdg_output_v1_logical_position(
+            x,
+            y);
+    }
+
+    void zxdg_output_v1::zxdg_output_v1_logical_size(int32_t , int32_t )
+    {
+    }
+
+    void zxdg_output_v1::handle_logical_size(
+        void *data,
+        struct ::zxdg_output_v1 *object,
+        int32_t width,
+        int32_t height)
+    {
+        Q_UNUSED(object);
+        static_cast<zxdg_output_v1 *>(data)->zxdg_output_v1_logical_size(
+            width,
+            height);
+    }
+
+    void zxdg_output_v1::zxdg_output_v1_done()
+    {
+    }
+
+    void zxdg_output_v1::handle_done(
+        void *data,
+        struct ::zxdg_output_v1 *object)
+    {
+        Q_UNUSED(object);
+        static_cast<zxdg_output_v1 *>(data)->zxdg_output_v1_done();
+    }
+
+    void zxdg_output_v1::zxdg_output_v1_name(const QString &)
+    {
+    }
+
+    void zxdg_output_v1::handle_name(
+        void *data,
+        struct ::zxdg_output_v1 *object,
+        const char *name)
+    {
+        Q_UNUSED(object);
+        static_cast<zxdg_output_v1 *>(data)->zxdg_output_v1_name(
+            QString::fromUtf8(name));
+    }
+
+    void zxdg_output_v1::zxdg_output_v1_description(const QString &)
+    {
+    }
+
+    void zxdg_output_v1::handle_description(
+        void *data,
+        struct ::zxdg_output_v1 *object,
+        const char *description)
+    {
+        Q_UNUSED(object);
+        static_cast<zxdg_output_v1 *>(data)->zxdg_output_v1_description(
+            QString::fromUtf8(description));
+    }
+
+    const struct zxdg_output_v1_listener zxdg_output_v1::m_zxdg_output_v1_listener = {
+        zxdg_output_v1::handle_logical_position,
+        zxdg_output_v1::handle_logical_size,
+        zxdg_output_v1::handle_done,
+        zxdg_output_v1::handle_name,
+        zxdg_output_v1::handle_description,
+    };
+
+    void zxdg_output_v1::init_listener()
+    {
+        zxdg_output_v1_add_listener(m_zxdg_output_v1, &m_zxdg_output_v1_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/client/qwayland-xdg-output-unstable-v1.h b/src/client/qwayland-xdg-output-unstable-v1.h
new file mode 100644
index 0000000000000000000000000000000000000000..3d9bbe67a322e04d1936cfd2c911237b76ec0e07
--- /dev/null
+++ a/qtwayland/src/client/qwayland-xdg-output-unstable-v1.h
@@ -0,0 +1,113 @@
+// This file was generated by qtwaylandscanner
+// source file is ../3rdparty/protocol/xdg-output-unstable-v1.xml
+
+#ifndef QT_WAYLAND_XDG_OUTPUT_UNSTABLE_V1
+#define QT_WAYLAND_XDG_OUTPUT_UNSTABLE_V1
+
+#include <QtWaylandClient/private/wayland-xdg-output-unstable-v1-client-protocol.h>
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+#if !defined(Q_WAYLAND_CLIENT_XDG_OUTPUT_UNSTABLE_V1_EXPORT)
+#  if defined(QT_SHARED)
+#    define Q_WAYLAND_CLIENT_XDG_OUTPUT_UNSTABLE_V1_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_WAYLAND_CLIENT_XDG_OUTPUT_UNSTABLE_V1_EXPORT
+#  endif
+#endif
+
+namespace QtWayland {
+    class Q_WAYLAND_CLIENT_XDG_OUTPUT_UNSTABLE_V1_EXPORT zxdg_output_manager_v1
+    {
+    public:
+        zxdg_output_manager_v1(struct ::wl_registry *registry, int id, int version);
+        zxdg_output_manager_v1(struct ::zxdg_output_manager_v1 *object);
+        zxdg_output_manager_v1();
+
+        virtual ~zxdg_output_manager_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zxdg_output_manager_v1 *object);
+
+        struct ::zxdg_output_manager_v1 *object() { return m_zxdg_output_manager_v1; }
+        const struct ::zxdg_output_manager_v1 *object() const { return m_zxdg_output_manager_v1; }
+        static zxdg_output_manager_v1 *fromObject(struct ::zxdg_output_manager_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+        struct ::zxdg_output_v1 *get_xdg_output(struct ::wl_output *output);
+
+    private:
+        struct ::zxdg_output_manager_v1 *m_zxdg_output_manager_v1;
+    };
+
+    class Q_WAYLAND_CLIENT_XDG_OUTPUT_UNSTABLE_V1_EXPORT zxdg_output_v1
+    {
+    public:
+        zxdg_output_v1(struct ::wl_registry *registry, int id, int version);
+        zxdg_output_v1(struct ::zxdg_output_v1 *object);
+        zxdg_output_v1();
+
+        virtual ~zxdg_output_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zxdg_output_v1 *object);
+
+        struct ::zxdg_output_v1 *object() { return m_zxdg_output_v1; }
+        const struct ::zxdg_output_v1 *object() const { return m_zxdg_output_v1; }
+        static zxdg_output_v1 *fromObject(struct ::zxdg_output_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+
+    protected:
+        virtual void zxdg_output_v1_logical_position(int32_t x, int32_t y);
+        virtual void zxdg_output_v1_logical_size(int32_t width, int32_t height);
+        virtual void zxdg_output_v1_done();
+        virtual void zxdg_output_v1_name(const QString &name);
+        virtual void zxdg_output_v1_description(const QString &description);
+
+    private:
+        void init_listener();
+        static const struct zxdg_output_v1_listener m_zxdg_output_v1_listener;
+        static void handle_logical_position(
+            void *data,
+            struct ::zxdg_output_v1 *object,
+            int32_t x,
+            int32_t y);
+        static void handle_logical_size(
+            void *data,
+            struct ::zxdg_output_v1 *object,
+            int32_t width,
+            int32_t height);
+        static void handle_done(
+            void *data,
+            struct ::zxdg_output_v1 *object);
+        static void handle_name(
+            void *data,
+            struct ::zxdg_output_v1 *object,
+            const char *name);
+        static void handle_description(
+            void *data,
+            struct ::zxdg_output_v1 *object,
+            const char *description);
+        struct ::zxdg_output_v1 *m_zxdg_output_v1;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/client/qwaylandcursor.cpp b/src/client/qwaylandcursor.cpp
index e4eca9d4ef1ce8863d63bcc92b7e975ac2585cd6..0f328b018d023a097f86900ae6bd5f42b50f268e 100644
--- a/qtwayland/src/client/qwaylandcursor.cpp
+++ a/qtwayland/src/client/qwaylandcursor.cpp
@@ -46,7 +46,7 @@
 #include <QtGui/QImageReader>
 #include <QDebug>
 
-#include <wayland-cursor.h>
+#include <wayland_cursor-so_wrap.h>
 
 #include <algorithm>
 
diff --git a/src/client/qwaylanddisplay.cpp b/src/client/qwaylanddisplay.cpp
index 8a6d5db1d7a83fdea9a0edd33617bc14230a2255..5d2b8aaa6c71dc808f9232ecd3abc8124d138618 100644
--- a/qtwayland/src/client/qwaylanddisplay.cpp
+++ a/qtwayland/src/client/qwaylanddisplay.cpp
@@ -57,7 +57,7 @@
 #include "qwaylandprimaryselectionv1_p.h"
 #endif // QT_CONFIG(wayland_client_primary_selection)
 #if QT_CONFIG(cursor)
-#include <wayland-cursor.h>
+#include <wayland_cursor-so_wrap.h>
 #endif
 #include "qwaylandhardwareintegration_p.h"
 #include "qwaylandinputcontext_p.h"
diff --git a/src/client/qwaylandinputcontext_p.h b/src/client/qwaylandinputcontext_p.h
index 50db634470d9745c274f914083ac775202680b1b..4fc02932f099de9457c88ff4905c0656b93e8f89 100644
--- a/qtwayland/src/client/qwaylandinputcontext_p.h
+++ a/qtwayland/src/client/qwaylandinputcontext_p.h
@@ -63,7 +63,7 @@
 #include <qwaylandinputmethodeventbuilder_p.h>
 #include <qtwaylandclientglobal_p.h>
 #if QT_CONFIG(xkbcommon)
-#include <xkbcommon/xkbcommon-compose.h>
+#include <xkbcommon-so_wrap.h>
 #endif
 
 struct wl_callback;
diff --git a/src/client/qwaylandinputdevice.cpp b/src/client/qwaylandinputdevice.cpp
index b0e9692bd5a80db57e3e2f0ece26b2f07ee1270f..91c455eb4ba9fe551143c0bb5e0620613a80e1f6 100644
--- a/qtwayland/src/client/qwaylandinputdevice.cpp
+++ a/qtwayland/src/client/qwaylandinputdevice.cpp
@@ -71,7 +71,7 @@
 #include <sys/mman.h>
 
 #if QT_CONFIG(cursor)
-#include <wayland-cursor.h>
+#include <wayland_cursor-so_wrap.h>
 #endif
 
 #include <QtGui/QGuiApplication>
diff --git a/src/client/wayland-hardware-integration-client-protocol.h b/src/client/wayland-hardware-integration-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..91ce5ee0d180b93d41cf5726d9a3cf4b4fb19e8c
--- /dev/null
+++ a/qtwayland/src/client/wayland-hardware-integration-client-protocol.h
@@ -0,0 +1,149 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef HARDWARE_INTEGRATION_CLIENT_PROTOCOL_H
+#define HARDWARE_INTEGRATION_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_hardware_integration The hardware_integration protocol
+ * @section page_ifaces_hardware_integration Interfaces
+ * - @subpage page_iface_qt_hardware_integration - compostors communicates supported buffer sharing extensions
+ * @section page_copyright_hardware_integration Copyright
+ * <pre>
+ *
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ * </pre>
+ */
+struct qt_hardware_integration;
+
+#ifndef QT_HARDWARE_INTEGRATION_INTERFACE
+#define QT_HARDWARE_INTEGRATION_INTERFACE
+/**
+ * @page page_iface_qt_hardware_integration qt_hardware_integration
+ * @section page_iface_qt_hardware_integration_desc Description
+ *
+ * Using this protocol the compositor can signal to clients which buffer sharing extensions
+ * the client should use
+ * @section page_iface_qt_hardware_integration_api API
+ * See @ref iface_qt_hardware_integration.
+ */
+/**
+ * @defgroup iface_qt_hardware_integration The qt_hardware_integration interface
+ *
+ * Using this protocol the compositor can signal to clients which buffer sharing extensions
+ * the client should use
+ */
+extern const struct wl_interface qt_hardware_integration_interface;
+#endif
+
+/**
+ * @ingroup iface_qt_hardware_integration
+ * @struct qt_hardware_integration_listener
+ */
+struct qt_hardware_integration_listener {
+	/**
+	 */
+	void (*client_backend)(void *data,
+			       struct qt_hardware_integration *qt_hardware_integration,
+			       const char *name);
+	/**
+	 */
+	void (*server_backend)(void *data,
+			       struct qt_hardware_integration *qt_hardware_integration,
+			       const char *name);
+};
+
+/**
+ * @ingroup iface_qt_hardware_integration
+ */
+static inline int
+qt_hardware_integration_add_listener(struct qt_hardware_integration *qt_hardware_integration,
+				     const struct qt_hardware_integration_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) qt_hardware_integration,
+				     (void (**)(void)) listener, data);
+}
+
+/**
+ * @ingroup iface_qt_hardware_integration
+ */
+#define QT_HARDWARE_INTEGRATION_CLIENT_BACKEND_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_hardware_integration
+ */
+#define QT_HARDWARE_INTEGRATION_SERVER_BACKEND_SINCE_VERSION 1
+
+
+/** @ingroup iface_qt_hardware_integration */
+static inline void
+qt_hardware_integration_set_user_data(struct qt_hardware_integration *qt_hardware_integration, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) qt_hardware_integration, user_data);
+}
+
+/** @ingroup iface_qt_hardware_integration */
+static inline void *
+qt_hardware_integration_get_user_data(struct qt_hardware_integration *qt_hardware_integration)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) qt_hardware_integration);
+}
+
+static inline uint32_t
+qt_hardware_integration_get_version(struct qt_hardware_integration *qt_hardware_integration)
+{
+	return wl_proxy_get_version((struct wl_proxy *) qt_hardware_integration);
+}
+
+/** @ingroup iface_qt_hardware_integration */
+static inline void
+qt_hardware_integration_destroy(struct qt_hardware_integration *qt_hardware_integration)
+{
+	wl_proxy_destroy((struct wl_proxy *) qt_hardware_integration);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-hardware-integration-protocol.c b/src/client/wayland-hardware-integration-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..a0de171846bbdeef80a82133615872c570015a8d
--- /dev/null
+++ a/qtwayland/src/client/wayland-hardware-integration-protocol.c
@@ -0,0 +1,60 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+
+static const struct wl_interface *hardware_integration_types[] = {
+	NULL,
+};
+
+static const struct wl_message qt_hardware_integration_events[] = {
+	{ "client_backend", "s", hardware_integration_types + 0 },
+	{ "server_backend", "s", hardware_integration_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface qt_hardware_integration_interface = {
+	"qt_hardware_integration", 1,
+	0, NULL,
+	2, qt_hardware_integration_events,
+};
+
diff --git a/src/client/wayland-qt-key-unstable-v1-client-protocol.h b/src/client/wayland-qt-key-unstable-v1-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..20440d3b460b0001894db528261164bb84a5a48f
--- /dev/null
+++ a/qtwayland/src/client/wayland-qt-key-unstable-v1-client-protocol.h
@@ -0,0 +1,173 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef QT_KEY_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define QT_KEY_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_qt_key_unstable_v1 The qt_key_unstable_v1 protocol
+ * @section page_ifaces_qt_key_unstable_v1 Interfaces
+ * - @subpage page_iface_zqt_key_v1 - send serialized QKeyEvents
+ * @section page_copyright_qt_key_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright (C) 2018 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ * </pre>
+ */
+struct wl_surface;
+struct zqt_key_v1;
+
+#ifndef ZQT_KEY_V1_INTERFACE
+#define ZQT_KEY_V1_INTERFACE
+/**
+ * @page page_iface_zqt_key_v1 zqt_key_v1
+ * @section page_iface_zqt_key_v1_desc Description
+ *
+ * This protocol is independent of the Wayland seat concept. Its
+ * intention is to let a QKeyEvent be transferred from a Qt compositor
+ * to a Qt client without losing or adding false information by going
+ * through wl_seat and wl_keyboard.
+ *
+ * Note: This protocol is considered private to Qt. We will do our
+ * best to bump version numbers when we make backwards compatible
+ * changes, bump the protocol name and interface suffixes when we make
+ * backwards incompatible changes, but we provide no guarantees. We
+ * may also remove the protocol without warning. Implement this at
+ * your own risk.
+ * @section page_iface_zqt_key_v1_api API
+ * See @ref iface_zqt_key_v1.
+ */
+/**
+ * @defgroup iface_zqt_key_v1 The zqt_key_v1 interface
+ *
+ * This protocol is independent of the Wayland seat concept. Its
+ * intention is to let a QKeyEvent be transferred from a Qt compositor
+ * to a Qt client without losing or adding false information by going
+ * through wl_seat and wl_keyboard.
+ *
+ * Note: This protocol is considered private to Qt. We will do our
+ * best to bump version numbers when we make backwards compatible
+ * changes, bump the protocol name and interface suffixes when we make
+ * backwards incompatible changes, but we provide no guarantees. We
+ * may also remove the protocol without warning. Implement this at
+ * your own risk.
+ */
+extern const struct wl_interface zqt_key_v1_interface;
+#endif
+
+/**
+ * @ingroup iface_zqt_key_v1
+ * @struct zqt_key_v1_listener
+ */
+struct zqt_key_v1_listener {
+	/**
+	 * send key event
+	 *
+	 * The key event notifies the client that a QKeyEvent has
+	 * occurred on the server side.
+	 */
+	void (*key)(void *data,
+		    struct zqt_key_v1 *zqt_key_v1,
+		    struct wl_surface *surface,
+		    uint32_t time,
+		    uint32_t type,
+		    uint32_t key,
+		    uint32_t modifiers,
+		    uint32_t nativeScanCode,
+		    uint32_t nativeVirtualKey,
+		    uint32_t nativeModifiers,
+		    const char *text,
+		    uint32_t autorepeat,
+		    uint32_t count);
+};
+
+/**
+ * @ingroup iface_zqt_key_v1
+ */
+static inline int
+zqt_key_v1_add_listener(struct zqt_key_v1 *zqt_key_v1,
+			const struct zqt_key_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zqt_key_v1,
+				     (void (**)(void)) listener, data);
+}
+
+/**
+ * @ingroup iface_zqt_key_v1
+ */
+#define ZQT_KEY_V1_KEY_SINCE_VERSION 1
+
+
+/** @ingroup iface_zqt_key_v1 */
+static inline void
+zqt_key_v1_set_user_data(struct zqt_key_v1 *zqt_key_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zqt_key_v1, user_data);
+}
+
+/** @ingroup iface_zqt_key_v1 */
+static inline void *
+zqt_key_v1_get_user_data(struct zqt_key_v1 *zqt_key_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zqt_key_v1);
+}
+
+static inline uint32_t
+zqt_key_v1_get_version(struct zqt_key_v1 *zqt_key_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zqt_key_v1);
+}
+
+/** @ingroup iface_zqt_key_v1 */
+static inline void
+zqt_key_v1_destroy(struct zqt_key_v1 *zqt_key_v1)
+{
+	wl_proxy_destroy((struct wl_proxy *) zqt_key_v1);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-qt-key-unstable-v1-protocol.c b/src/client/wayland-qt-key-unstable-v1-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..e23695bf6961e92433bb838f824caaff3d8c2c96
--- /dev/null
+++ a/qtwayland/src/client/wayland-qt-key-unstable-v1-protocol.c
@@ -0,0 +1,70 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright (C) 2018 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_surface_interface;
+
+static const struct wl_interface *qt_key_unstable_v1_types[] = {
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+static const struct wl_message zqt_key_v1_events[] = {
+	{ "key", "ouuuuuuusuu", qt_key_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zqt_key_v1_interface = {
+	"zqt_key_v1", 1,
+	0, NULL,
+	1, zqt_key_v1_events,
+};
+
diff --git a/src/client/wayland-qt-windowmanager-client-protocol.h b/src/client/wayland-qt-windowmanager-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..065e33160cc957beb5002059717c29f3628a8d3a
--- /dev/null
+++ a/qtwayland/src/client/wayland-qt-windowmanager-client-protocol.h
@@ -0,0 +1,162 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef QT_WINDOWMANAGER_CLIENT_PROTOCOL_H
+#define QT_WINDOWMANAGER_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_qt_windowmanager The qt_windowmanager protocol
+ * @section page_ifaces_qt_windowmanager Interfaces
+ * - @subpage page_iface_qt_windowmanager - 
+ * @section page_copyright_qt_windowmanager Copyright
+ * <pre>
+ *
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ * </pre>
+ */
+struct qt_windowmanager;
+
+#ifndef QT_WINDOWMANAGER_INTERFACE
+#define QT_WINDOWMANAGER_INTERFACE
+/**
+ * @page page_iface_qt_windowmanager qt_windowmanager
+ * @section page_iface_qt_windowmanager_api API
+ * See @ref iface_qt_windowmanager.
+ */
+/**
+ * @defgroup iface_qt_windowmanager The qt_windowmanager interface
+ */
+extern const struct wl_interface qt_windowmanager_interface;
+#endif
+
+/**
+ * @ingroup iface_qt_windowmanager
+ * @struct qt_windowmanager_listener
+ */
+struct qt_windowmanager_listener {
+	/**
+	 */
+	void (*hints)(void *data,
+		      struct qt_windowmanager *qt_windowmanager,
+		      int32_t show_is_fullscreen);
+	/**
+	 */
+	void (*quit)(void *data,
+		     struct qt_windowmanager *qt_windowmanager);
+};
+
+/**
+ * @ingroup iface_qt_windowmanager
+ */
+static inline int
+qt_windowmanager_add_listener(struct qt_windowmanager *qt_windowmanager,
+			      const struct qt_windowmanager_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) qt_windowmanager,
+				     (void (**)(void)) listener, data);
+}
+
+#define QT_WINDOWMANAGER_OPEN_URL 0
+
+/**
+ * @ingroup iface_qt_windowmanager
+ */
+#define QT_WINDOWMANAGER_HINTS_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_windowmanager
+ */
+#define QT_WINDOWMANAGER_QUIT_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_qt_windowmanager
+ */
+#define QT_WINDOWMANAGER_OPEN_URL_SINCE_VERSION 1
+
+/** @ingroup iface_qt_windowmanager */
+static inline void
+qt_windowmanager_set_user_data(struct qt_windowmanager *qt_windowmanager, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) qt_windowmanager, user_data);
+}
+
+/** @ingroup iface_qt_windowmanager */
+static inline void *
+qt_windowmanager_get_user_data(struct qt_windowmanager *qt_windowmanager)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) qt_windowmanager);
+}
+
+static inline uint32_t
+qt_windowmanager_get_version(struct qt_windowmanager *qt_windowmanager)
+{
+	return wl_proxy_get_version((struct wl_proxy *) qt_windowmanager);
+}
+
+/** @ingroup iface_qt_windowmanager */
+static inline void
+qt_windowmanager_destroy(struct qt_windowmanager *qt_windowmanager)
+{
+	wl_proxy_destroy((struct wl_proxy *) qt_windowmanager);
+}
+
+/**
+ * @ingroup iface_qt_windowmanager
+ *
+ * If remaining is not 0 this is a multipart request, and
+ * the server must concatenate subsequent requst urls to and
+ * including a request where remaining is set to 0, before
+ * it can handle the url.
+ */
+static inline void
+qt_windowmanager_open_url(struct qt_windowmanager *qt_windowmanager, uint32_t remaining, const char *url)
+{
+	wl_proxy_marshal((struct wl_proxy *) qt_windowmanager,
+			 QT_WINDOWMANAGER_OPEN_URL, remaining, url);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-qt-windowmanager-protocol.c b/src/client/wayland-qt-windowmanager-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..ba98da6132ff3d4db853ecf0926746b58d8574ef
--- /dev/null
+++ a/qtwayland/src/client/wayland-qt-windowmanager-protocol.c
@@ -0,0 +1,65 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+
+static const struct wl_interface *qt_windowmanager_types[] = {
+	NULL,
+	NULL,
+};
+
+static const struct wl_message qt_windowmanager_requests[] = {
+	{ "open_url", "us", qt_windowmanager_types + 0 },
+};
+
+static const struct wl_message qt_windowmanager_events[] = {
+	{ "hints", "i", qt_windowmanager_types + 0 },
+	{ "quit", "", qt_windowmanager_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface qt_windowmanager_interface = {
+	"qt_windowmanager", 1,
+	1, qt_windowmanager_requests,
+	2, qt_windowmanager_events,
+};
+
diff --git a/src/client/wayland-server-buffer-extension-client-protocol.h b/src/client/wayland-server-buffer-extension-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..afbf4dcbb60aece667a1eb207568a8bc32a1f459
--- /dev/null
+++ a/qtwayland/src/client/wayland-server-buffer-extension-client-protocol.h
@@ -0,0 +1,137 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef SERVER_BUFFER_EXTENSION_CLIENT_PROTOCOL_H
+#define SERVER_BUFFER_EXTENSION_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_server_buffer_extension The server_buffer_extension protocol
+ * @section page_ifaces_server_buffer_extension Interfaces
+ * - @subpage page_iface_qt_server_buffer - buffers managed by the compositor
+ * @section page_copyright_server_buffer_extension Copyright
+ * <pre>
+ *
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ * </pre>
+ */
+struct qt_server_buffer;
+
+#ifndef QT_SERVER_BUFFER_INTERFACE
+#define QT_SERVER_BUFFER_INTERFACE
+/**
+ * @page page_iface_qt_server_buffer qt_server_buffer
+ * @section page_iface_qt_server_buffer_desc Description
+ *
+ * Server buffer is an extension which makes it possible to share a
+ * buffer created by the compositor to share it with arbitrary
+ * clients. These types of buffers are intended to be read only
+ * buffers for clients, but this is an implementation detail.
+ *
+ * Server buffers main purpose is to help implement caches
+ * @section page_iface_qt_server_buffer_api API
+ * See @ref iface_qt_server_buffer.
+ */
+/**
+ * @defgroup iface_qt_server_buffer The qt_server_buffer interface
+ *
+ * Server buffer is an extension which makes it possible to share a
+ * buffer created by the compositor to share it with arbitrary
+ * clients. These types of buffers are intended to be read only
+ * buffers for clients, but this is an implementation detail.
+ *
+ * Server buffers main purpose is to help implement caches
+ */
+extern const struct wl_interface qt_server_buffer_interface;
+#endif
+
+#define QT_SERVER_BUFFER_RELEASE 0
+
+
+/**
+ * @ingroup iface_qt_server_buffer
+ */
+#define QT_SERVER_BUFFER_RELEASE_SINCE_VERSION 1
+
+/** @ingroup iface_qt_server_buffer */
+static inline void
+qt_server_buffer_set_user_data(struct qt_server_buffer *qt_server_buffer, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) qt_server_buffer, user_data);
+}
+
+/** @ingroup iface_qt_server_buffer */
+static inline void *
+qt_server_buffer_get_user_data(struct qt_server_buffer *qt_server_buffer)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) qt_server_buffer);
+}
+
+static inline uint32_t
+qt_server_buffer_get_version(struct qt_server_buffer *qt_server_buffer)
+{
+	return wl_proxy_get_version((struct wl_proxy *) qt_server_buffer);
+}
+
+/** @ingroup iface_qt_server_buffer */
+static inline void
+qt_server_buffer_destroy(struct qt_server_buffer *qt_server_buffer)
+{
+	wl_proxy_destroy((struct wl_proxy *) qt_server_buffer);
+}
+
+/**
+ * @ingroup iface_qt_server_buffer
+ */
+static inline void
+qt_server_buffer_release(struct qt_server_buffer *qt_server_buffer)
+{
+	wl_proxy_marshal((struct wl_proxy *) qt_server_buffer,
+			 QT_SERVER_BUFFER_RELEASE);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-server-buffer-extension-protocol.c b/src/client/wayland-server-buffer-extension-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..613be188ea2fb57e7cfb31ebba3fdabb71e666ec
--- /dev/null
+++ a/qtwayland/src/client/wayland-server-buffer-extension-protocol.c
@@ -0,0 +1,58 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+
+static const struct wl_interface *server_buffer_extension_types[] = {
+};
+
+static const struct wl_message qt_server_buffer_requests[] = {
+	{ "release", "", server_buffer_extension_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface qt_server_buffer_interface = {
+	"qt_server_buffer", 1,
+	1, qt_server_buffer_requests,
+	0, NULL,
+};
+
diff --git a/src/client/wayland-surface-extension-client-protocol.h b/src/client/wayland-surface-extension-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..a42044219566fec2d798704aa71effc81e4318e7
--- /dev/null
+++ a/qtwayland/src/client/wayland-surface-extension-client-protocol.h
@@ -0,0 +1,311 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef SURFACE_EXTENSION_CLIENT_PROTOCOL_H
+#define SURFACE_EXTENSION_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_surface_extension The surface_extension protocol
+ * @section page_ifaces_surface_extension Interfaces
+ * - @subpage page_iface_qt_surface_extension - 
+ * - @subpage page_iface_qt_extended_surface - 
+ * @section page_copyright_surface_extension Copyright
+ * <pre>
+ *
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ * </pre>
+ */
+struct qt_extended_surface;
+struct qt_surface_extension;
+struct wl_surface;
+
+#ifndef QT_SURFACE_EXTENSION_INTERFACE
+#define QT_SURFACE_EXTENSION_INTERFACE
+/**
+ * @page page_iface_qt_surface_extension qt_surface_extension
+ * @section page_iface_qt_surface_extension_api API
+ * See @ref iface_qt_surface_extension.
+ */
+/**
+ * @defgroup iface_qt_surface_extension The qt_surface_extension interface
+ */
+extern const struct wl_interface qt_surface_extension_interface;
+#endif
+#ifndef QT_EXTENDED_SURFACE_INTERFACE
+#define QT_EXTENDED_SURFACE_INTERFACE
+/**
+ * @page page_iface_qt_extended_surface qt_extended_surface
+ * @section page_iface_qt_extended_surface_api API
+ * See @ref iface_qt_extended_surface.
+ */
+/**
+ * @defgroup iface_qt_extended_surface The qt_extended_surface interface
+ */
+extern const struct wl_interface qt_extended_surface_interface;
+#endif
+
+#define QT_SURFACE_EXTENSION_GET_EXTENDED_SURFACE 0
+
+
+/**
+ * @ingroup iface_qt_surface_extension
+ */
+#define QT_SURFACE_EXTENSION_GET_EXTENDED_SURFACE_SINCE_VERSION 1
+
+/** @ingroup iface_qt_surface_extension */
+static inline void
+qt_surface_extension_set_user_data(struct qt_surface_extension *qt_surface_extension, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) qt_surface_extension, user_data);
+}
+
+/** @ingroup iface_qt_surface_extension */
+static inline void *
+qt_surface_extension_get_user_data(struct qt_surface_extension *qt_surface_extension)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) qt_surface_extension);
+}
+
+static inline uint32_t
+qt_surface_extension_get_version(struct qt_surface_extension *qt_surface_extension)
+{
+	return wl_proxy_get_version((struct wl_proxy *) qt_surface_extension);
+}
+
+/** @ingroup iface_qt_surface_extension */
+static inline void
+qt_surface_extension_destroy(struct qt_surface_extension *qt_surface_extension)
+{
+	wl_proxy_destroy((struct wl_proxy *) qt_surface_extension);
+}
+
+/**
+ * @ingroup iface_qt_surface_extension
+ */
+static inline struct qt_extended_surface *
+qt_surface_extension_get_extended_surface(struct qt_surface_extension *qt_surface_extension, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) qt_surface_extension,
+			 QT_SURFACE_EXTENSION_GET_EXTENDED_SURFACE, &qt_extended_surface_interface, NULL, surface);
+
+	return (struct qt_extended_surface *) id;
+}
+
+#ifndef QT_EXTENDED_SURFACE_ORIENTATION_ENUM
+#define QT_EXTENDED_SURFACE_ORIENTATION_ENUM
+enum qt_extended_surface_orientation {
+	QT_EXTENDED_SURFACE_ORIENTATION_PRIMARYORIENTATION = 0,
+	QT_EXTENDED_SURFACE_ORIENTATION_PORTRAITORIENTATION = 1,
+	QT_EXTENDED_SURFACE_ORIENTATION_LANDSCAPEORIENTATION = 2,
+	QT_EXTENDED_SURFACE_ORIENTATION_INVERTEDPORTRAITORIENTATION = 4,
+	QT_EXTENDED_SURFACE_ORIENTATION_INVERTEDLANDSCAPEORIENTATION = 8,
+};
+#endif /* QT_EXTENDED_SURFACE_ORIENTATION_ENUM */
+
+#ifndef QT_EXTENDED_SURFACE_WINDOWFLAG_ENUM
+#define QT_EXTENDED_SURFACE_WINDOWFLAG_ENUM
+enum qt_extended_surface_windowflag {
+	QT_EXTENDED_SURFACE_WINDOWFLAG_OVERRIDESSYSTEMGESTURES = 1,
+	QT_EXTENDED_SURFACE_WINDOWFLAG_STAYSONTOP = 2,
+	QT_EXTENDED_SURFACE_WINDOWFLAG_BYPASSWINDOWMANAGER = 4,
+};
+#endif /* QT_EXTENDED_SURFACE_WINDOWFLAG_ENUM */
+
+/**
+ * @ingroup iface_qt_extended_surface
+ * @struct qt_extended_surface_listener
+ */
+struct qt_extended_surface_listener {
+	/**
+	 */
+	void (*onscreen_visibility)(void *data,
+				    struct qt_extended_surface *qt_extended_surface,
+				    int32_t visible);
+	/**
+	 */
+	void (*set_generic_property)(void *data,
+				     struct qt_extended_surface *qt_extended_surface,
+				     const char *name,
+				     struct wl_array *value);
+	/**
+	 */
+	void (*close)(void *data,
+		      struct qt_extended_surface *qt_extended_surface);
+};
+
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+static inline int
+qt_extended_surface_add_listener(struct qt_extended_surface *qt_extended_surface,
+				 const struct qt_extended_surface_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) qt_extended_surface,
+				     (void (**)(void)) listener, data);
+}
+
+#define QT_EXTENDED_SURFACE_UPDATE_GENERIC_PROPERTY 0
+#define QT_EXTENDED_SURFACE_SET_CONTENT_ORIENTATION_MASK 1
+#define QT_EXTENDED_SURFACE_SET_WINDOW_FLAGS 2
+#define QT_EXTENDED_SURFACE_RAISE 3
+#define QT_EXTENDED_SURFACE_LOWER 4
+
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+#define QT_EXTENDED_SURFACE_ONSCREEN_VISIBILITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+#define QT_EXTENDED_SURFACE_SET_GENERIC_PROPERTY_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+#define QT_EXTENDED_SURFACE_CLOSE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+#define QT_EXTENDED_SURFACE_UPDATE_GENERIC_PROPERTY_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+#define QT_EXTENDED_SURFACE_SET_CONTENT_ORIENTATION_MASK_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+#define QT_EXTENDED_SURFACE_SET_WINDOW_FLAGS_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+#define QT_EXTENDED_SURFACE_RAISE_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+#define QT_EXTENDED_SURFACE_LOWER_SINCE_VERSION 1
+
+/** @ingroup iface_qt_extended_surface */
+static inline void
+qt_extended_surface_set_user_data(struct qt_extended_surface *qt_extended_surface, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) qt_extended_surface, user_data);
+}
+
+/** @ingroup iface_qt_extended_surface */
+static inline void *
+qt_extended_surface_get_user_data(struct qt_extended_surface *qt_extended_surface)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) qt_extended_surface);
+}
+
+static inline uint32_t
+qt_extended_surface_get_version(struct qt_extended_surface *qt_extended_surface)
+{
+	return wl_proxy_get_version((struct wl_proxy *) qt_extended_surface);
+}
+
+/** @ingroup iface_qt_extended_surface */
+static inline void
+qt_extended_surface_destroy(struct qt_extended_surface *qt_extended_surface)
+{
+	wl_proxy_destroy((struct wl_proxy *) qt_extended_surface);
+}
+
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+static inline void
+qt_extended_surface_update_generic_property(struct qt_extended_surface *qt_extended_surface, const char *name, struct wl_array *value)
+{
+	wl_proxy_marshal((struct wl_proxy *) qt_extended_surface,
+			 QT_EXTENDED_SURFACE_UPDATE_GENERIC_PROPERTY, name, value);
+}
+
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+static inline void
+qt_extended_surface_set_content_orientation_mask(struct qt_extended_surface *qt_extended_surface, int32_t orientation)
+{
+	wl_proxy_marshal((struct wl_proxy *) qt_extended_surface,
+			 QT_EXTENDED_SURFACE_SET_CONTENT_ORIENTATION_MASK, orientation);
+}
+
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+static inline void
+qt_extended_surface_set_window_flags(struct qt_extended_surface *qt_extended_surface, int32_t flags)
+{
+	wl_proxy_marshal((struct wl_proxy *) qt_extended_surface,
+			 QT_EXTENDED_SURFACE_SET_WINDOW_FLAGS, flags);
+}
+
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+static inline void
+qt_extended_surface_raise(struct qt_extended_surface *qt_extended_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) qt_extended_surface,
+			 QT_EXTENDED_SURFACE_RAISE);
+}
+
+/**
+ * @ingroup iface_qt_extended_surface
+ */
+static inline void
+qt_extended_surface_lower(struct qt_extended_surface *qt_extended_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) qt_extended_surface,
+			 QT_EXTENDED_SURFACE_LOWER);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-surface-extension-protocol.c b/src/client/wayland-surface-extension-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..29a5e1ba1b6e509bcb6b007923df9f2e265a0bd8
--- /dev/null
+++ a/qtwayland/src/client/wayland-surface-extension-protocol.c
@@ -0,0 +1,84 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface qt_extended_surface_interface;
+extern const struct wl_interface wl_surface_interface;
+
+static const struct wl_interface *surface_extension_types[] = {
+	NULL,
+	NULL,
+	&qt_extended_surface_interface,
+	&wl_surface_interface,
+};
+
+static const struct wl_message qt_surface_extension_requests[] = {
+	{ "get_extended_surface", "no", surface_extension_types + 2 },
+};
+
+WL_EXPORT const struct wl_interface qt_surface_extension_interface = {
+	"qt_surface_extension", 1,
+	1, qt_surface_extension_requests,
+	0, NULL,
+};
+
+static const struct wl_message qt_extended_surface_requests[] = {
+	{ "update_generic_property", "sa", surface_extension_types + 0 },
+	{ "set_content_orientation_mask", "i", surface_extension_types + 0 },
+	{ "set_window_flags", "i", surface_extension_types + 0 },
+	{ "raise", "", surface_extension_types + 0 },
+	{ "lower", "", surface_extension_types + 0 },
+};
+
+static const struct wl_message qt_extended_surface_events[] = {
+	{ "onscreen_visibility", "i", surface_extension_types + 0 },
+	{ "set_generic_property", "sa", surface_extension_types + 0 },
+	{ "close", "", surface_extension_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface qt_extended_surface_interface = {
+	"qt_extended_surface", 1,
+	5, qt_extended_surface_requests,
+	3, qt_extended_surface_events,
+};
+
diff --git a/src/client/wayland-tablet-unstable-v2-client-protocol.h b/src/client/wayland-tablet-unstable-v2-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..cfa1ccfab9a2bbd30fe12a0ca76a8566e1cc5957
--- /dev/null
+++ a/qtwayland/src/client/wayland-tablet-unstable-v2-client-protocol.h
@@ -0,0 +1,2263 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef TABLET_UNSTABLE_V2_CLIENT_PROTOCOL_H
+#define TABLET_UNSTABLE_V2_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_tablet_unstable_v2 The tablet_unstable_v2 protocol
+ * Wayland protocol for graphics tablets
+ *
+ * @section page_desc_tablet_unstable_v2 Description
+ *
+ * This description provides a high-level overview of the interplay between
+ * the interfaces defined this protocol. For details, see the protocol
+ * specification.
+ *
+ * More than one tablet may exist, and device-specifics matter. Tablets are
+ * not represented by a single virtual device like wl_pointer. A client
+ * binds to the tablet manager object which is just a proxy object. From
+ * that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)
+ * and that returns the actual interface that has all the tablets. With
+ * this indirection, we can avoid merging wp_tablet into the actual Wayland
+ * protocol, a long-term benefit.
+ *
+ * The wp_tablet_seat sends a "tablet added" event for each tablet
+ * connected. That event is followed by descriptive events about the
+ * hardware; currently that includes events for name, vid/pid and
+ * a wp_tablet.path event that describes a local path. This path can be
+ * used to uniquely identify a tablet or get more information through
+ * libwacom. Emulated or nested tablets can skip any of those, e.g. a
+ * virtual tablet may not have a vid/pid. The sequence of descriptive
+ * events is terminated by a wp_tablet.done event to signal that a client
+ * may now finalize any initialization for that tablet.
+ *
+ * Events from tablets require a tool in proximity. Tools are also managed
+ * by the tablet seat; a "tool added" event is sent whenever a tool is new
+ * to the compositor. That event is followed by a number of descriptive
+ * events about the hardware; currently that includes capabilities,
+ * hardware id and serial number, and tool type. Similar to the tablet
+ * interface, a wp_tablet_tool.done event is sent to terminate that initial
+ * sequence.
+ *
+ * Any event from a tool happens on the wp_tablet_tool interface. When the
+ * tool gets into proximity of the tablet, a proximity_in event is sent on
+ * the wp_tablet_tool interface, listing the tablet and the surface. That
+ * event is followed by a motion event with the coordinates. After that,
+ * it's the usual motion, axis, button, etc. events. The protocol's
+ * serialisation means events are grouped by wp_tablet_tool.frame events.
+ *
+ * Two special events (that don't exist in X) are down and up. They signal
+ * "tip touching the surface". For tablets without real proximity
+ * detection, the sequence is: proximity_in, motion, down, frame.
+ *
+ * When the tool leaves proximity, a proximity_out event is sent. If any
+ * button is still down, a button release event is sent before this
+ * proximity event. These button events are sent in the same frame as the
+ * proximity event to signal to the client that the buttons were held when
+ * the tool left proximity.
+ *
+ * If the tool moves out of the surface but stays in proximity (i.e.
+ * between windows), compositor-specific grab policies apply. This usually
+ * means that the proximity-out is delayed until all buttons are released.
+ *
+ * Moving a tool physically from one tablet to the other has no real effect
+ * on the protocol, since we already have the tool object from the "tool
+ * added" event. All the information is already there and the proximity
+ * events on both tablets are all a client needs to reconstruct what
+ * happened.
+ *
+ * Some extra axes are normalized, i.e. the client knows the range as
+ * specified in the protocol (e.g. [0, 65535]), the granularity however is
+ * unknown. The current normalized axes are pressure, distance, and slider.
+ *
+ * Other extra axes are in physical units as specified in the protocol.
+ * The current extra axes with physical units are tilt, rotation and
+ * wheel rotation.
+ *
+ * Since tablets work independently of the pointer controlled by the mouse,
+ * the focus handling is independent too and controlled by proximity.
+ * The wp_tablet_tool.set_cursor request sets a tool-specific cursor.
+ * This cursor surface may be the same as the mouse cursor, and it may be
+ * the same across tools but it is possible to be more fine-grained. For
+ * example, a client may set different cursors for the pen and eraser.
+ *
+ * Tools are generally independent of tablets and it is
+ * compositor-specific policy when a tool can be removed. Common approaches
+ * will likely include some form of removing a tool when all tablets the
+ * tool was used on are removed.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ *
+ * @section page_ifaces_tablet_unstable_v2 Interfaces
+ * - @subpage page_iface_zwp_tablet_manager_v2 - controller object for graphic tablet devices
+ * - @subpage page_iface_zwp_tablet_seat_v2 - controller object for graphic tablet devices of a seat
+ * - @subpage page_iface_zwp_tablet_tool_v2 - a physical tablet tool
+ * - @subpage page_iface_zwp_tablet_v2 - graphics tablet device
+ * - @subpage page_iface_zwp_tablet_pad_ring_v2 - pad ring
+ * - @subpage page_iface_zwp_tablet_pad_strip_v2 - pad strip
+ * - @subpage page_iface_zwp_tablet_pad_group_v2 - a set of buttons, rings and strips
+ * - @subpage page_iface_zwp_tablet_pad_v2 - a set of buttons, rings and strips
+ * @section page_copyright_tablet_unstable_v2 Copyright
+ * <pre>
+ *
+ * Copyright 2014 © Stephen "Lyude" Chandler Paul
+ * Copyright 2015-2016 © Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * </pre>
+ */
+struct wl_seat;
+struct wl_surface;
+struct zwp_tablet_manager_v2;
+struct zwp_tablet_pad_group_v2;
+struct zwp_tablet_pad_ring_v2;
+struct zwp_tablet_pad_strip_v2;
+struct zwp_tablet_pad_v2;
+struct zwp_tablet_seat_v2;
+struct zwp_tablet_tool_v2;
+struct zwp_tablet_v2;
+
+#ifndef ZWP_TABLET_MANAGER_V2_INTERFACE
+#define ZWP_TABLET_MANAGER_V2_INTERFACE
+/**
+ * @page page_iface_zwp_tablet_manager_v2 zwp_tablet_manager_v2
+ * @section page_iface_zwp_tablet_manager_v2_desc Description
+ *
+ * An object that provides access to the graphics tablets available on this
+ * system. All tablets are associated with a seat, to get access to the
+ * actual tablets, use wp_tablet_manager.get_tablet_seat.
+ * @section page_iface_zwp_tablet_manager_v2_api API
+ * See @ref iface_zwp_tablet_manager_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_manager_v2 The zwp_tablet_manager_v2 interface
+ *
+ * An object that provides access to the graphics tablets available on this
+ * system. All tablets are associated with a seat, to get access to the
+ * actual tablets, use wp_tablet_manager.get_tablet_seat.
+ */
+extern const struct wl_interface zwp_tablet_manager_v2_interface;
+#endif
+#ifndef ZWP_TABLET_SEAT_V2_INTERFACE
+#define ZWP_TABLET_SEAT_V2_INTERFACE
+/**
+ * @page page_iface_zwp_tablet_seat_v2 zwp_tablet_seat_v2
+ * @section page_iface_zwp_tablet_seat_v2_desc Description
+ *
+ * An object that provides access to the graphics tablets available on this
+ * seat. After binding to this interface, the compositor sends a set of
+ * wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
+ * @section page_iface_zwp_tablet_seat_v2_api API
+ * See @ref iface_zwp_tablet_seat_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_seat_v2 The zwp_tablet_seat_v2 interface
+ *
+ * An object that provides access to the graphics tablets available on this
+ * seat. After binding to this interface, the compositor sends a set of
+ * wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
+ */
+extern const struct wl_interface zwp_tablet_seat_v2_interface;
+#endif
+#ifndef ZWP_TABLET_TOOL_V2_INTERFACE
+#define ZWP_TABLET_TOOL_V2_INTERFACE
+/**
+ * @page page_iface_zwp_tablet_tool_v2 zwp_tablet_tool_v2
+ * @section page_iface_zwp_tablet_tool_v2_desc Description
+ *
+ * An object that represents a physical tool that has been, or is
+ * currently in use with a tablet in this seat. Each wp_tablet_tool
+ * object stays valid until the client destroys it; the compositor
+ * reuses the wp_tablet_tool object to indicate that the object's
+ * respective physical tool has come into proximity of a tablet again.
+ *
+ * A wp_tablet_tool object's relation to a physical tool depends on the
+ * tablet's ability to report serial numbers. If the tablet supports
+ * this capability, then the object represents a specific physical tool
+ * and can be identified even when used on multiple tablets.
+ *
+ * A tablet tool has a number of static characteristics, e.g. tool type,
+ * hardware_serial and capabilities. These capabilities are sent in an
+ * event sequence after the wp_tablet_seat.tool_added event before any
+ * actual events from this tool. This initial event sequence is
+ * terminated by a wp_tablet_tool.done event.
+ *
+ * Tablet tool events are grouped by wp_tablet_tool.frame events.
+ * Any events received before a wp_tablet_tool.frame event should be
+ * considered part of the same hardware state change.
+ * @section page_iface_zwp_tablet_tool_v2_api API
+ * See @ref iface_zwp_tablet_tool_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_tool_v2 The zwp_tablet_tool_v2 interface
+ *
+ * An object that represents a physical tool that has been, or is
+ * currently in use with a tablet in this seat. Each wp_tablet_tool
+ * object stays valid until the client destroys it; the compositor
+ * reuses the wp_tablet_tool object to indicate that the object's
+ * respective physical tool has come into proximity of a tablet again.
+ *
+ * A wp_tablet_tool object's relation to a physical tool depends on the
+ * tablet's ability to report serial numbers. If the tablet supports
+ * this capability, then the object represents a specific physical tool
+ * and can be identified even when used on multiple tablets.
+ *
+ * A tablet tool has a number of static characteristics, e.g. tool type,
+ * hardware_serial and capabilities. These capabilities are sent in an
+ * event sequence after the wp_tablet_seat.tool_added event before any
+ * actual events from this tool. This initial event sequence is
+ * terminated by a wp_tablet_tool.done event.
+ *
+ * Tablet tool events are grouped by wp_tablet_tool.frame events.
+ * Any events received before a wp_tablet_tool.frame event should be
+ * considered part of the same hardware state change.
+ */
+extern const struct wl_interface zwp_tablet_tool_v2_interface;
+#endif
+#ifndef ZWP_TABLET_V2_INTERFACE
+#define ZWP_TABLET_V2_INTERFACE
+/**
+ * @page page_iface_zwp_tablet_v2 zwp_tablet_v2
+ * @section page_iface_zwp_tablet_v2_desc Description
+ *
+ * The wp_tablet interface represents one graphics tablet device. The
+ * tablet interface itself does not generate events; all events are
+ * generated by wp_tablet_tool objects when in proximity above a tablet.
+ *
+ * A tablet has a number of static characteristics, e.g. device name and
+ * pid/vid. These capabilities are sent in an event sequence after the
+ * wp_tablet_seat.tablet_added event. This initial event sequence is
+ * terminated by a wp_tablet.done event.
+ * @section page_iface_zwp_tablet_v2_api API
+ * See @ref iface_zwp_tablet_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_v2 The zwp_tablet_v2 interface
+ *
+ * The wp_tablet interface represents one graphics tablet device. The
+ * tablet interface itself does not generate events; all events are
+ * generated by wp_tablet_tool objects when in proximity above a tablet.
+ *
+ * A tablet has a number of static characteristics, e.g. device name and
+ * pid/vid. These capabilities are sent in an event sequence after the
+ * wp_tablet_seat.tablet_added event. This initial event sequence is
+ * terminated by a wp_tablet.done event.
+ */
+extern const struct wl_interface zwp_tablet_v2_interface;
+#endif
+#ifndef ZWP_TABLET_PAD_RING_V2_INTERFACE
+#define ZWP_TABLET_PAD_RING_V2_INTERFACE
+/**
+ * @page page_iface_zwp_tablet_pad_ring_v2 zwp_tablet_pad_ring_v2
+ * @section page_iface_zwp_tablet_pad_ring_v2_desc Description
+ *
+ * A circular interaction area, such as the touch ring on the Wacom Intuos
+ * Pro series tablets.
+ *
+ * Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
+ * event.
+ * @section page_iface_zwp_tablet_pad_ring_v2_api API
+ * See @ref iface_zwp_tablet_pad_ring_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_pad_ring_v2 The zwp_tablet_pad_ring_v2 interface
+ *
+ * A circular interaction area, such as the touch ring on the Wacom Intuos
+ * Pro series tablets.
+ *
+ * Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
+ * event.
+ */
+extern const struct wl_interface zwp_tablet_pad_ring_v2_interface;
+#endif
+#ifndef ZWP_TABLET_PAD_STRIP_V2_INTERFACE
+#define ZWP_TABLET_PAD_STRIP_V2_INTERFACE
+/**
+ * @page page_iface_zwp_tablet_pad_strip_v2 zwp_tablet_pad_strip_v2
+ * @section page_iface_zwp_tablet_pad_strip_v2_desc Description
+ *
+ * A linear interaction area, such as the strips found in Wacom Cintiq
+ * models.
+ *
+ * Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
+ * event.
+ * @section page_iface_zwp_tablet_pad_strip_v2_api API
+ * See @ref iface_zwp_tablet_pad_strip_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_pad_strip_v2 The zwp_tablet_pad_strip_v2 interface
+ *
+ * A linear interaction area, such as the strips found in Wacom Cintiq
+ * models.
+ *
+ * Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
+ * event.
+ */
+extern const struct wl_interface zwp_tablet_pad_strip_v2_interface;
+#endif
+#ifndef ZWP_TABLET_PAD_GROUP_V2_INTERFACE
+#define ZWP_TABLET_PAD_GROUP_V2_INTERFACE
+/**
+ * @page page_iface_zwp_tablet_pad_group_v2 zwp_tablet_pad_group_v2
+ * @section page_iface_zwp_tablet_pad_group_v2_desc Description
+ *
+ * A pad group describes a distinct (sub)set of buttons, rings and strips
+ * present in the tablet. The criteria of this grouping is usually positional,
+ * eg. if a tablet has buttons on the left and right side, 2 groups will be
+ * presented. The physical arrangement of groups is undisclosed and may
+ * change on the fly.
+ *
+ * Pad groups will announce their features during pad initialization. Between
+ * the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
+ * pad group will announce the buttons, rings and strips contained in it,
+ * plus the number of supported modes.
+ *
+ * Modes are a mechanism to allow multiple groups of actions for every element
+ * in the pad group. The number of groups and available modes in each is
+ * persistent across device plugs. The current mode is user-switchable, it
+ * will be announced through the wp_tablet_pad_group.mode_switch event both
+ * whenever it is switched, and after wp_tablet_pad.enter.
+ *
+ * The current mode logically applies to all elements in the pad group,
+ * although it is at clients' discretion whether to actually perform different
+ * actions, and/or issue the respective .set_feedback requests to notify the
+ * compositor. See the wp_tablet_pad_group.mode_switch event for more details.
+ * @section page_iface_zwp_tablet_pad_group_v2_api API
+ * See @ref iface_zwp_tablet_pad_group_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_pad_group_v2 The zwp_tablet_pad_group_v2 interface
+ *
+ * A pad group describes a distinct (sub)set of buttons, rings and strips
+ * present in the tablet. The criteria of this grouping is usually positional,
+ * eg. if a tablet has buttons on the left and right side, 2 groups will be
+ * presented. The physical arrangement of groups is undisclosed and may
+ * change on the fly.
+ *
+ * Pad groups will announce their features during pad initialization. Between
+ * the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
+ * pad group will announce the buttons, rings and strips contained in it,
+ * plus the number of supported modes.
+ *
+ * Modes are a mechanism to allow multiple groups of actions for every element
+ * in the pad group. The number of groups and available modes in each is
+ * persistent across device plugs. The current mode is user-switchable, it
+ * will be announced through the wp_tablet_pad_group.mode_switch event both
+ * whenever it is switched, and after wp_tablet_pad.enter.
+ *
+ * The current mode logically applies to all elements in the pad group,
+ * although it is at clients' discretion whether to actually perform different
+ * actions, and/or issue the respective .set_feedback requests to notify the
+ * compositor. See the wp_tablet_pad_group.mode_switch event for more details.
+ */
+extern const struct wl_interface zwp_tablet_pad_group_v2_interface;
+#endif
+#ifndef ZWP_TABLET_PAD_V2_INTERFACE
+#define ZWP_TABLET_PAD_V2_INTERFACE
+/**
+ * @page page_iface_zwp_tablet_pad_v2 zwp_tablet_pad_v2
+ * @section page_iface_zwp_tablet_pad_v2_desc Description
+ *
+ * A pad device is a set of buttons, rings and strips
+ * usually physically present on the tablet device itself. Some
+ * exceptions exist where the pad device is physically detached, e.g. the
+ * Wacom ExpressKey Remote.
+ *
+ * Pad devices have no axes that control the cursor and are generally
+ * auxiliary devices to the tool devices used on the tablet surface.
+ *
+ * A pad device has a number of static characteristics, e.g. the number
+ * of rings. These capabilities are sent in an event sequence after the
+ * wp_tablet_seat.pad_added event before any actual events from this pad.
+ * This initial event sequence is terminated by a wp_tablet_pad.done
+ * event.
+ *
+ * All pad features (buttons, rings and strips) are logically divided into
+ * groups and all pads have at least one group. The available groups are
+ * notified through the wp_tablet_pad.group event; the compositor will
+ * emit one event per group before emitting wp_tablet_pad.done.
+ *
+ * Groups may have multiple modes. Modes allow clients to map multiple
+ * actions to a single pad feature. Only one mode can be active per group,
+ * although different groups may have different active modes.
+ * @section page_iface_zwp_tablet_pad_v2_api API
+ * See @ref iface_zwp_tablet_pad_v2.
+ */
+/**
+ * @defgroup iface_zwp_tablet_pad_v2 The zwp_tablet_pad_v2 interface
+ *
+ * A pad device is a set of buttons, rings and strips
+ * usually physically present on the tablet device itself. Some
+ * exceptions exist where the pad device is physically detached, e.g. the
+ * Wacom ExpressKey Remote.
+ *
+ * Pad devices have no axes that control the cursor and are generally
+ * auxiliary devices to the tool devices used on the tablet surface.
+ *
+ * A pad device has a number of static characteristics, e.g. the number
+ * of rings. These capabilities are sent in an event sequence after the
+ * wp_tablet_seat.pad_added event before any actual events from this pad.
+ * This initial event sequence is terminated by a wp_tablet_pad.done
+ * event.
+ *
+ * All pad features (buttons, rings and strips) are logically divided into
+ * groups and all pads have at least one group. The available groups are
+ * notified through the wp_tablet_pad.group event; the compositor will
+ * emit one event per group before emitting wp_tablet_pad.done.
+ *
+ * Groups may have multiple modes. Modes allow clients to map multiple
+ * actions to a single pad feature. Only one mode can be active per group,
+ * although different groups may have different active modes.
+ */
+extern const struct wl_interface zwp_tablet_pad_v2_interface;
+#endif
+
+#define ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT 0
+#define ZWP_TABLET_MANAGER_V2_DESTROY 1
+
+
+/**
+ * @ingroup iface_zwp_tablet_manager_v2
+ */
+#define ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_manager_v2
+ */
+#define ZWP_TABLET_MANAGER_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_manager_v2 */
+static inline void
+zwp_tablet_manager_v2_set_user_data(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_manager_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_manager_v2 */
+static inline void *
+zwp_tablet_manager_v2_get_user_data(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_manager_v2);
+}
+
+static inline uint32_t
+zwp_tablet_manager_v2_get_version(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_manager_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_manager_v2
+ *
+ * Get the wp_tablet_seat object for the given seat. This object
+ * provides access to all graphics tablets in this seat.
+ */
+static inline struct zwp_tablet_seat_v2 *
+zwp_tablet_manager_v2_get_tablet_seat(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2, struct wl_seat *seat)
+{
+	struct wl_proxy *tablet_seat;
+
+	tablet_seat = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_tablet_manager_v2,
+			 ZWP_TABLET_MANAGER_V2_GET_TABLET_SEAT, &zwp_tablet_seat_v2_interface, NULL, seat);
+
+	return (struct zwp_tablet_seat_v2 *) tablet_seat;
+}
+
+/**
+ * @ingroup iface_zwp_tablet_manager_v2
+ *
+ * Destroy the wp_tablet_manager object. Objects created from this
+ * object are unaffected and should be destroyed separately.
+ */
+static inline void
+zwp_tablet_manager_v2_destroy(struct zwp_tablet_manager_v2 *zwp_tablet_manager_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_manager_v2,
+			 ZWP_TABLET_MANAGER_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_manager_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ * @struct zwp_tablet_seat_v2_listener
+ */
+struct zwp_tablet_seat_v2_listener {
+	/**
+	 * new device notification
+	 *
+	 * This event is sent whenever a new tablet becomes available on
+	 * this seat. This event only provides the object id of the tablet,
+	 * any static information about the tablet (device name, vid/pid,
+	 * etc.) is sent through the wp_tablet interface.
+	 * @param id the newly added graphics tablet
+	 */
+	void (*tablet_added)(void *data,
+			     struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
+			     struct zwp_tablet_v2 *id);
+	/**
+	 * a new tool has been used with a tablet
+	 *
+	 * This event is sent whenever a tool that has not previously
+	 * been used with a tablet comes into use. This event only provides
+	 * the object id of the tool; any static information about the tool
+	 * (capabilities, type, etc.) is sent through the wp_tablet_tool
+	 * interface.
+	 * @param id the newly added tablet tool
+	 */
+	void (*tool_added)(void *data,
+			   struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
+			   struct zwp_tablet_tool_v2 *id);
+	/**
+	 * new pad notification
+	 *
+	 * This event is sent whenever a new pad is known to the system.
+	 * Typically, pads are physically attached to tablets and a
+	 * pad_added event is sent immediately after the
+	 * wp_tablet_seat.tablet_added. However, some standalone pad
+	 * devices logically attach to tablets at runtime, and the client
+	 * must wait for wp_tablet_pad.enter to know the tablet a pad is
+	 * attached to.
+	 *
+	 * This event only provides the object id of the pad. All further
+	 * features (buttons, strips, rings) are sent through the
+	 * wp_tablet_pad interface.
+	 * @param id the newly added pad
+	 */
+	void (*pad_added)(void *data,
+			  struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
+			  struct zwp_tablet_pad_v2 *id);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+static inline int
+zwp_tablet_seat_v2_add_listener(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2,
+				const struct zwp_tablet_seat_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_seat_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_SEAT_V2_DESTROY 0
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+#define ZWP_TABLET_SEAT_V2_TABLET_ADDED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+#define ZWP_TABLET_SEAT_V2_TOOL_ADDED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+#define ZWP_TABLET_SEAT_V2_PAD_ADDED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ */
+#define ZWP_TABLET_SEAT_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_seat_v2 */
+static inline void
+zwp_tablet_seat_v2_set_user_data(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_seat_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_seat_v2 */
+static inline void *
+zwp_tablet_seat_v2_get_user_data(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_seat_v2);
+}
+
+static inline uint32_t
+zwp_tablet_seat_v2_get_version(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_seat_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_seat_v2
+ *
+ * Destroy the wp_tablet_seat object. Objects created from this
+ * object are unaffected and should be destroyed separately.
+ */
+static inline void
+zwp_tablet_seat_v2_destroy(struct zwp_tablet_seat_v2 *zwp_tablet_seat_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_seat_v2,
+			 ZWP_TABLET_SEAT_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_seat_v2);
+}
+
+#ifndef ZWP_TABLET_TOOL_V2_TYPE_ENUM
+#define ZWP_TABLET_TOOL_V2_TYPE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ * a physical tool type
+ *
+ * Describes the physical type of a tool. The physical type of a tool
+ * generally defines its base usage.
+ *
+ * The mouse tool represents a mouse-shaped tool that is not a relative
+ * device but bound to the tablet's surface, providing absolute
+ * coordinates.
+ *
+ * The lens tool is a mouse-shaped tool with an attached lens to
+ * provide precision focus.
+ */
+enum zwp_tablet_tool_v2_type {
+	/**
+	 * Pen
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_PEN = 0x140,
+	/**
+	 * Eraser
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_ERASER = 0x141,
+	/**
+	 * Brush
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_BRUSH = 0x142,
+	/**
+	 * Pencil
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_PENCIL = 0x143,
+	/**
+	 * Airbrush
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_AIRBRUSH = 0x144,
+	/**
+	 * Finger
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_FINGER = 0x145,
+	/**
+	 * Mouse
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_MOUSE = 0x146,
+	/**
+	 * Lens
+	 */
+	ZWP_TABLET_TOOL_V2_TYPE_LENS = 0x147,
+};
+#endif /* ZWP_TABLET_TOOL_V2_TYPE_ENUM */
+
+#ifndef ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM
+#define ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ * capability flags for a tool
+ *
+ * Describes extra capabilities on a tablet.
+ *
+ * Any tool must provide x and y values, extra axes are
+ * device-specific.
+ */
+enum zwp_tablet_tool_v2_capability {
+	/**
+	 * Tilt axes
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_TILT = 1,
+	/**
+	 * Pressure axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_PRESSURE = 2,
+	/**
+	 * Distance axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_DISTANCE = 3,
+	/**
+	 * Z-rotation axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_ROTATION = 4,
+	/**
+	 * Slider axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_SLIDER = 5,
+	/**
+	 * Wheel axis
+	 */
+	ZWP_TABLET_TOOL_V2_CAPABILITY_WHEEL = 6,
+};
+#endif /* ZWP_TABLET_TOOL_V2_CAPABILITY_ENUM */
+
+#ifndef ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM
+#define ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ * physical button state
+ *
+ * Describes the physical state of a button that produced the button event.
+ */
+enum zwp_tablet_tool_v2_button_state {
+	/**
+	 * button is not pressed
+	 */
+	ZWP_TABLET_TOOL_V2_BUTTON_STATE_RELEASED = 0,
+	/**
+	 * button is pressed
+	 */
+	ZWP_TABLET_TOOL_V2_BUTTON_STATE_PRESSED = 1,
+};
+#endif /* ZWP_TABLET_TOOL_V2_BUTTON_STATE_ENUM */
+
+#ifndef ZWP_TABLET_TOOL_V2_ERROR_ENUM
+#define ZWP_TABLET_TOOL_V2_ERROR_ENUM
+enum zwp_tablet_tool_v2_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	ZWP_TABLET_TOOL_V2_ERROR_ROLE = 0,
+};
+#endif /* ZWP_TABLET_TOOL_V2_ERROR_ENUM */
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ * @struct zwp_tablet_tool_v2_listener
+ */
+struct zwp_tablet_tool_v2_listener {
+	/**
+	 * tool type
+	 *
+	 * The tool type is the high-level type of the tool and usually
+	 * decides the interaction expected from this tool.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_tool.done event.
+	 * @param tool_type the physical tool type
+	 */
+	void (*type)(void *data,
+		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		     uint32_t tool_type);
+	/**
+	 * unique hardware serial number of the tool
+	 *
+	 * If the physical tool can be identified by a unique 64-bit
+	 * serial number, this event notifies the client of this serial
+	 * number.
+	 *
+	 * If multiple tablets are available in the same seat and the tool
+	 * is uniquely identifiable by the serial number, that tool may
+	 * move between tablets.
+	 *
+	 * Otherwise, if the tool has no serial number and this event is
+	 * missing, the tool is tied to the tablet it first comes into
+	 * proximity with. Even if the physical tool is used on multiple
+	 * tablets, separate wp_tablet_tool objects will be created, one
+	 * per tablet.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_tool.done event.
+	 * @param hardware_serial_hi the unique serial number of the tool, most significant bits
+	 * @param hardware_serial_lo the unique serial number of the tool, least significant bits
+	 */
+	void (*hardware_serial)(void *data,
+				struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+				uint32_t hardware_serial_hi,
+				uint32_t hardware_serial_lo);
+	/**
+	 * hardware id notification in Wacom's format
+	 *
+	 * This event notifies the client of a hardware id available on
+	 * this tool.
+	 *
+	 * The hardware id is a device-specific 64-bit id that provides
+	 * extra information about the tool in use, beyond the wl_tool.type
+	 * enumeration. The format of the id is specific to tablets made by
+	 * Wacom Inc. For example, the hardware id of a Wacom Grip Pen (a
+	 * stylus) is 0x802.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_tool.done event.
+	 * @param hardware_id_hi the hardware id, most significant bits
+	 * @param hardware_id_lo the hardware id, least significant bits
+	 */
+	void (*hardware_id_wacom)(void *data,
+				  struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+				  uint32_t hardware_id_hi,
+				  uint32_t hardware_id_lo);
+	/**
+	 * tool capability notification
+	 *
+	 * This event notifies the client of any capabilities of this
+	 * tool, beyond the main set of x/y axes and tip up/down detection.
+	 *
+	 * One event is sent for each extra capability available on this
+	 * tool.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_tool.done event.
+	 * @param capability the capability
+	 */
+	void (*capability)(void *data,
+			   struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			   uint32_t capability);
+	/**
+	 * tool description events sequence complete
+	 *
+	 * This event signals the end of the initial burst of descriptive
+	 * events. A client may consider the static description of the tool
+	 * to be complete and finalize initialization of the tool.
+	 */
+	void (*done)(void *data,
+		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
+	/**
+	 * tool removed
+	 *
+	 * This event is sent when the tool is removed from the system
+	 * and will send no further events. Should the physical tool come
+	 * back into proximity later, a new wp_tablet_tool object will be
+	 * created.
+	 *
+	 * It is compositor-dependent when a tool is removed. A compositor
+	 * may remove a tool on proximity out, tablet removal or any other
+	 * reason. A compositor may also keep a tool alive until shutdown.
+	 *
+	 * If the tool is currently in proximity, a proximity_out event
+	 * will be sent before the removed event. See
+	 * wp_tablet_tool.proximity_out for the handling of any buttons
+	 * logically down.
+	 *
+	 * When this event is received, the client must
+	 * wp_tablet_tool.destroy the object.
+	 */
+	void (*removed)(void *data,
+			struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
+	/**
+	 * proximity in event
+	 *
+	 * Notification that this tool is focused on a certain surface.
+	 *
+	 * This event can be received when the tool has moved from one
+	 * surface to another, or when the tool has come back into
+	 * proximity above the surface.
+	 *
+	 * If any button is logically down when the tool comes into
+	 * proximity, the respective button event is sent after the
+	 * proximity_in event but within the same frame as the proximity_in
+	 * event.
+	 * @param tablet The tablet the tool is in proximity of
+	 * @param surface The current surface the tablet tool is over
+	 */
+	void (*proximity_in)(void *data,
+			     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			     uint32_t serial,
+			     struct zwp_tablet_v2 *tablet,
+			     struct wl_surface *surface);
+	/**
+	 * proximity out event
+	 *
+	 * Notification that this tool has either left proximity, or is
+	 * no longer focused on a certain surface.
+	 *
+	 * When the tablet tool leaves proximity of the tablet, button
+	 * release events are sent for each button that was held down at
+	 * the time of leaving proximity. These events are sent before the
+	 * proximity_out event but within the same wp_tablet.frame.
+	 *
+	 * If the tool stays within proximity of the tablet, but the focus
+	 * changes from one surface to another, a button release event may
+	 * not be sent until the button is actually released or the tool
+	 * leaves the proximity of the tablet.
+	 */
+	void (*proximity_out)(void *data,
+			      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
+	/**
+	 * tablet tool is making contact
+	 *
+	 * Sent whenever the tablet tool comes in contact with the
+	 * surface of the tablet.
+	 *
+	 * If the tool is already in contact with the tablet when entering
+	 * the input region, the client owning said region will receive a
+	 * wp_tablet.proximity_in event, followed by a wp_tablet.down event
+	 * and a wp_tablet.frame event.
+	 *
+	 * Note that this event describes logical contact, not physical
+	 * contact. On some devices, a compositor may not consider a tool
+	 * in logical contact until a minimum physical pressure threshold
+	 * is exceeded.
+	 */
+	void (*down)(void *data,
+		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		     uint32_t serial);
+	/**
+	 * tablet tool is no longer making contact
+	 *
+	 * Sent whenever the tablet tool stops making contact with the
+	 * surface of the tablet, or when the tablet tool moves out of the
+	 * input region and the compositor grab (if any) is dismissed.
+	 *
+	 * If the tablet tool moves out of the input region while in
+	 * contact with the surface of the tablet and the compositor does
+	 * not have an ongoing grab on the surface, the client owning said
+	 * region will receive a wp_tablet.up event, followed by a
+	 * wp_tablet.proximity_out event and a wp_tablet.frame event. If
+	 * the compositor has an ongoing grab on this device, this event
+	 * sequence is sent whenever the grab is dismissed in the future.
+	 *
+	 * Note that this event describes logical contact, not physical
+	 * contact. On some devices, a compositor may not consider a tool
+	 * out of logical contact until physical pressure falls below a
+	 * specific threshold.
+	 */
+	void (*up)(void *data,
+		   struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2);
+	/**
+	 * motion event
+	 *
+	 * Sent whenever a tablet tool moves.
+	 * @param x surface-local x coordinate
+	 * @param y surface-local y coordinate
+	 */
+	void (*motion)(void *data,
+		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		       wl_fixed_t x,
+		       wl_fixed_t y);
+	/**
+	 * pressure change event
+	 *
+	 * Sent whenever the pressure axis on a tool changes. The value
+	 * of this event is normalized to a value between 0 and 65535.
+	 *
+	 * Note that pressure may be nonzero even when a tool is not in
+	 * logical contact. See the down and up events for more details.
+	 * @param pressure The current pressure value
+	 */
+	void (*pressure)(void *data,
+			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			 uint32_t pressure);
+	/**
+	 * distance change event
+	 *
+	 * Sent whenever the distance axis on a tool changes. The value
+	 * of this event is normalized to a value between 0 and 65535.
+	 *
+	 * Note that distance may be nonzero even when a tool is not in
+	 * logical contact. See the down and up events for more details.
+	 * @param distance The current distance value
+	 */
+	void (*distance)(void *data,
+			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			 uint32_t distance);
+	/**
+	 * tilt change event
+	 *
+	 * Sent whenever one or both of the tilt axes on a tool change.
+	 * Each tilt value is in degrees, relative to the z-axis of the
+	 * tablet. The angle is positive when the top of a tool tilts along
+	 * the positive x or y axis.
+	 * @param tilt_x The current value of the X tilt axis
+	 * @param tilt_y The current value of the Y tilt axis
+	 */
+	void (*tilt)(void *data,
+		     struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		     wl_fixed_t tilt_x,
+		     wl_fixed_t tilt_y);
+	/**
+	 * z-rotation change event
+	 *
+	 * Sent whenever the z-rotation axis on the tool changes. The
+	 * rotation value is in degrees clockwise from the tool's logical
+	 * neutral position.
+	 * @param degrees The current rotation of the Z axis
+	 */
+	void (*rotation)(void *data,
+			 struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+			 wl_fixed_t degrees);
+	/**
+	 * Slider position change event
+	 *
+	 * Sent whenever the slider position on the tool changes. The
+	 * value is normalized between -65535 and 65535, with 0 as the
+	 * logical neutral position of the slider.
+	 *
+	 * The slider is available on e.g. the Wacom Airbrush tool.
+	 * @param position The current position of slider
+	 */
+	void (*slider)(void *data,
+		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		       int32_t position);
+	/**
+	 * Wheel delta event
+	 *
+	 * Sent whenever the wheel on the tool emits an event. This event
+	 * contains two values for the same axis change. The degrees value
+	 * is in the same orientation as the wl_pointer.vertical_scroll
+	 * axis. The clicks value is in discrete logical clicks of the
+	 * mouse wheel. This value may be zero if the movement of the wheel
+	 * was less than one logical click.
+	 *
+	 * Clients should choose either value and avoid mixing degrees and
+	 * clicks. The compositor may accumulate values smaller than a
+	 * logical click and emulate click events when a certain threshold
+	 * is met. Thus, wl_tablet_tool.wheel events with non-zero clicks
+	 * values may have different degrees values.
+	 * @param degrees The wheel delta in degrees
+	 * @param clicks The wheel delta in discrete clicks
+	 */
+	void (*wheel)(void *data,
+		      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		      wl_fixed_t degrees,
+		      int32_t clicks);
+	/**
+	 * button event
+	 *
+	 * Sent whenever a button on the tool is pressed or released.
+	 *
+	 * If a button is held down when the tool moves in or out of
+	 * proximity, button events are generated by the compositor. See
+	 * wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
+	 * details.
+	 * @param button The button whose state has changed
+	 * @param state Whether the button was pressed or released
+	 */
+	void (*button)(void *data,
+		       struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		       uint32_t serial,
+		       uint32_t button,
+		       uint32_t state);
+	/**
+	 * frame event
+	 *
+	 * Marks the end of a series of axis and/or button updates from
+	 * the tablet. The Wayland protocol requires axis updates to be
+	 * sent sequentially, however all events within a frame should be
+	 * considered one hardware event.
+	 * @param time The time of the event with millisecond granularity
+	 */
+	void (*frame)(void *data,
+		      struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+		      uint32_t time);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+static inline int
+zwp_tablet_tool_v2_add_listener(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2,
+				const struct zwp_tablet_tool_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_tool_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_TOOL_V2_SET_CURSOR 0
+#define ZWP_TABLET_TOOL_V2_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_TYPE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_HARDWARE_SERIAL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_HARDWARE_ID_WACOM_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_CAPABILITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_REMOVED_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_PROXIMITY_IN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_PROXIMITY_OUT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_DOWN_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_UP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_MOTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_PRESSURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_DISTANCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_TILT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_ROTATION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_SLIDER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_WHEEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_BUTTON_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_FRAME_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_SET_CURSOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ */
+#define ZWP_TABLET_TOOL_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_tool_v2 */
+static inline void
+zwp_tablet_tool_v2_set_user_data(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_tool_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_tool_v2 */
+static inline void *
+zwp_tablet_tool_v2_get_user_data(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_tool_v2);
+}
+
+static inline uint32_t
+zwp_tablet_tool_v2_get_version(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_tool_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ *
+ * Sets the surface of the cursor used for this tool on the given
+ * tablet. This request only takes effect if the tool is in proximity
+ * of one of the requesting client's surfaces or the surface parameter
+ * is the current pointer surface. If there was a previous surface set
+ * with this request it is replaced. If surface is NULL, the cursor
+ * image is hidden.
+ *
+ * The parameters hotspot_x and hotspot_y define the position of the
+ * pointer surface relative to the pointer location. Its top-left corner
+ * is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
+ * coordinates of the pointer location, in surface-local coordinates.
+ *
+ * On surface.attach requests to the pointer surface, hotspot_x and
+ * hotspot_y are decremented by the x and y parameters passed to the
+ * request. Attach must be confirmed by wl_surface.commit as usual.
+ *
+ * The hotspot can also be updated by passing the currently set pointer
+ * surface to this request with new values for hotspot_x and hotspot_y.
+ *
+ * The current and pending input regions of the wl_surface are cleared,
+ * and wl_surface.set_input_region is ignored until the wl_surface is no
+ * longer used as the cursor. When the use as a cursor ends, the current
+ * and pending input regions become undefined, and the wl_surface is
+ * unmapped.
+ *
+ * This request gives the surface the role of a wp_tablet_tool cursor. A
+ * surface may only ever be used as the cursor surface for one
+ * wp_tablet_tool. If the surface already has another role or has
+ * previously been used as cursor surface for a different tool, a
+ * protocol error is raised.
+ */
+static inline void
+zwp_tablet_tool_v2_set_cursor(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2, uint32_t serial, struct wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_tool_v2,
+			 ZWP_TABLET_TOOL_V2_SET_CURSOR, serial, surface, hotspot_x, hotspot_y);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_tool_v2
+ *
+ * This destroys the client's resource for this tool object.
+ */
+static inline void
+zwp_tablet_tool_v2_destroy(struct zwp_tablet_tool_v2 *zwp_tablet_tool_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_tool_v2,
+			 ZWP_TABLET_TOOL_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_tool_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ * @struct zwp_tablet_v2_listener
+ */
+struct zwp_tablet_v2_listener {
+	/**
+	 * tablet device name
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet.done event.
+	 * @param name the device name
+	 */
+	void (*name)(void *data,
+		     struct zwp_tablet_v2 *zwp_tablet_v2,
+		     const char *name);
+	/**
+	 * tablet device USB vendor/product id
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet.done event.
+	 * @param vid USB vendor id
+	 * @param pid USB product id
+	 */
+	void (*id)(void *data,
+		   struct zwp_tablet_v2 *zwp_tablet_v2,
+		   uint32_t vid,
+		   uint32_t pid);
+	/**
+	 * path to the device
+	 *
+	 * A system-specific device path that indicates which device is
+	 * behind this wp_tablet. This information may be used to gather
+	 * additional information about the device, e.g. through libwacom.
+	 *
+	 * A device may have more than one device path. If so, multiple
+	 * wp_tablet.path events are sent. A device may be emulated and not
+	 * have a device path, and in that case this event will not be
+	 * sent.
+	 *
+	 * The format of the path is unspecified, it may be a device node,
+	 * a sysfs path, or some other identifier. It is up to the client
+	 * to identify the string provided.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet.done event.
+	 * @param path path to local device
+	 */
+	void (*path)(void *data,
+		     struct zwp_tablet_v2 *zwp_tablet_v2,
+		     const char *path);
+	/**
+	 * tablet description events sequence complete
+	 *
+	 * This event is sent immediately to signal the end of the
+	 * initial burst of descriptive events. A client may consider the
+	 * static description of the tablet to be complete and finalize
+	 * initialization of the tablet.
+	 */
+	void (*done)(void *data,
+		     struct zwp_tablet_v2 *zwp_tablet_v2);
+	/**
+	 * tablet removed event
+	 *
+	 * Sent when the tablet has been removed from the system. When a
+	 * tablet is removed, some tools may be removed.
+	 *
+	 * When this event is received, the client must wp_tablet.destroy
+	 * the object.
+	 */
+	void (*removed)(void *data,
+			struct zwp_tablet_v2 *zwp_tablet_v2);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+static inline int
+zwp_tablet_v2_add_listener(struct zwp_tablet_v2 *zwp_tablet_v2,
+			   const struct zwp_tablet_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_V2_DESTROY 0
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_NAME_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_PATH_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_REMOVED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ */
+#define ZWP_TABLET_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_v2 */
+static inline void
+zwp_tablet_v2_set_user_data(struct zwp_tablet_v2 *zwp_tablet_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_v2 */
+static inline void *
+zwp_tablet_v2_get_user_data(struct zwp_tablet_v2 *zwp_tablet_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_v2);
+}
+
+static inline uint32_t
+zwp_tablet_v2_get_version(struct zwp_tablet_v2 *zwp_tablet_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_v2
+ *
+ * This destroys the client's resource for this tablet object.
+ */
+static inline void
+zwp_tablet_v2_destroy(struct zwp_tablet_v2 *zwp_tablet_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_v2,
+			 ZWP_TABLET_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_v2);
+}
+
+#ifndef ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM
+#define ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ * ring axis source
+ *
+ * Describes the source types for ring events. This indicates to the
+ * client how a ring event was physically generated; a client may
+ * adjust the user interface accordingly. For example, events
+ * from a "finger" source may trigger kinetic scrolling.
+ */
+enum zwp_tablet_pad_ring_v2_source {
+	/**
+	 * finger
+	 */
+	ZWP_TABLET_PAD_RING_V2_SOURCE_FINGER = 1,
+};
+#endif /* ZWP_TABLET_PAD_RING_V2_SOURCE_ENUM */
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ * @struct zwp_tablet_pad_ring_v2_listener
+ */
+struct zwp_tablet_pad_ring_v2_listener {
+	/**
+	 * ring event source
+	 *
+	 * Source information for ring events.
+	 *
+	 * This event does not occur on its own. It is sent before a
+	 * wp_tablet_pad_ring.frame event and carries the source
+	 * information for all events within that frame.
+	 *
+	 * The source specifies how this event was generated. If the source
+	 * is wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop
+	 * event will be sent when the user lifts the finger off the
+	 * device.
+	 *
+	 * This event is optional. If the source is unknown for an
+	 * interaction, no event is sent.
+	 * @param source the event source
+	 */
+	void (*source)(void *data,
+		       struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+		       uint32_t source);
+	/**
+	 * angle changed
+	 *
+	 * Sent whenever the angle on a ring changes.
+	 *
+	 * The angle is provided in degrees clockwise from the logical
+	 * north of the ring in the pad's current rotation.
+	 * @param degrees the current angle in degrees
+	 */
+	void (*angle)(void *data,
+		      struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+		      wl_fixed_t degrees);
+	/**
+	 * interaction stopped
+	 *
+	 * Stop notification for ring events.
+	 *
+	 * For some wp_tablet_pad_ring.source types, a
+	 * wp_tablet_pad_ring.stop event is sent to notify a client that
+	 * the interaction with the ring has terminated. This enables the
+	 * client to implement kinetic scrolling. See the
+	 * wp_tablet_pad_ring.source documentation for information on when
+	 * this event may be generated.
+	 *
+	 * Any wp_tablet_pad_ring.angle events with the same source after
+	 * this event should be considered as the start of a new
+	 * interaction.
+	 */
+	void (*stop)(void *data,
+		     struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2);
+	/**
+	 * end of a ring event sequence
+	 *
+	 * Indicates the end of a set of ring events that logically
+	 * belong together. A client is expected to accumulate the data in
+	 * all events within the frame before proceeding.
+	 *
+	 * All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame
+	 * event belong logically together. For example, on termination of
+	 * a finger interaction on a ring the compositor will send a
+	 * wp_tablet_pad_ring.source event, a wp_tablet_pad_ring.stop event
+	 * and a wp_tablet_pad_ring.frame event.
+	 *
+	 * A wp_tablet_pad_ring.frame event is sent for every logical event
+	 * group, even if the group only contains a single
+	 * wp_tablet_pad_ring event. Specifically, a client may get a
+	 * sequence: angle, frame, angle, frame, etc.
+	 * @param time timestamp with millisecond granularity
+	 */
+	void (*frame)(void *data,
+		      struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+		      uint32_t time);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+static inline int
+zwp_tablet_pad_ring_v2_add_listener(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2,
+				    const struct zwp_tablet_pad_ring_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_ring_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK 0
+#define ZWP_TABLET_PAD_RING_V2_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_SOURCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_ANGLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_STOP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_FRAME_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ */
+#define ZWP_TABLET_PAD_RING_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_pad_ring_v2 */
+static inline void
+zwp_tablet_pad_ring_v2_set_user_data(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_ring_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_pad_ring_v2 */
+static inline void *
+zwp_tablet_pad_ring_v2_get_user_data(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_ring_v2);
+}
+
+static inline uint32_t
+zwp_tablet_pad_ring_v2_get_version(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_ring_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ *
+ * Request that the compositor use the provided feedback string
+ * associated with this ring. This request should be issued immediately
+ * after a wp_tablet_pad_group.mode_switch event from the corresponding
+ * group is received, or whenever the ring is mapped to a different
+ * action. See wp_tablet_pad_group.mode_switch for more details.
+ *
+ * Clients are encouraged to provide context-aware descriptions for
+ * the actions associated with the ring; compositors may use this
+ * information to offer visual feedback about the button layout
+ * (eg. on-screen displays).
+ *
+ * The provided string 'description' is a UTF-8 encoded string to be
+ * associated with this ring, and is considered user-visible; general
+ * internationalization rules apply.
+ *
+ * The serial argument will be that of the last
+ * wp_tablet_pad_group.mode_switch event received for the group of this
+ * ring. Requests providing other serials than the most recent one will be
+ * ignored.
+ */
+static inline void
+zwp_tablet_pad_ring_v2_set_feedback(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2, const char *description, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_ring_v2,
+			 ZWP_TABLET_PAD_RING_V2_SET_FEEDBACK, description, serial);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_ring_v2
+ *
+ * This destroys the client's resource for this ring object.
+ */
+static inline void
+zwp_tablet_pad_ring_v2_destroy(struct zwp_tablet_pad_ring_v2 *zwp_tablet_pad_ring_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_ring_v2,
+			 ZWP_TABLET_PAD_RING_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_pad_ring_v2);
+}
+
+#ifndef ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM
+#define ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ * strip axis source
+ *
+ * Describes the source types for strip events. This indicates to the
+ * client how a strip event was physically generated; a client may
+ * adjust the user interface accordingly. For example, events
+ * from a "finger" source may trigger kinetic scrolling.
+ */
+enum zwp_tablet_pad_strip_v2_source {
+	/**
+	 * finger
+	 */
+	ZWP_TABLET_PAD_STRIP_V2_SOURCE_FINGER = 1,
+};
+#endif /* ZWP_TABLET_PAD_STRIP_V2_SOURCE_ENUM */
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ * @struct zwp_tablet_pad_strip_v2_listener
+ */
+struct zwp_tablet_pad_strip_v2_listener {
+	/**
+	 * strip event source
+	 *
+	 * Source information for strip events.
+	 *
+	 * This event does not occur on its own. It is sent before a
+	 * wp_tablet_pad_strip.frame event and carries the source
+	 * information for all events within that frame.
+	 *
+	 * The source specifies how this event was generated. If the source
+	 * is wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop
+	 * event will be sent when the user lifts their finger off the
+	 * device.
+	 *
+	 * This event is optional. If the source is unknown for an
+	 * interaction, no event is sent.
+	 * @param source the event source
+	 */
+	void (*source)(void *data,
+		       struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+		       uint32_t source);
+	/**
+	 * position changed
+	 *
+	 * Sent whenever the position on a strip changes.
+	 *
+	 * The position is normalized to a range of [0, 65535], the 0-value
+	 * represents the top-most and/or left-most position of the strip
+	 * in the pad's current rotation.
+	 * @param position the current position
+	 */
+	void (*position)(void *data,
+			 struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+			 uint32_t position);
+	/**
+	 * interaction stopped
+	 *
+	 * Stop notification for strip events.
+	 *
+	 * For some wp_tablet_pad_strip.source types, a
+	 * wp_tablet_pad_strip.stop event is sent to notify a client that
+	 * the interaction with the strip has terminated. This enables the
+	 * client to implement kinetic scrolling. See the
+	 * wp_tablet_pad_strip.source documentation for information on when
+	 * this event may be generated.
+	 *
+	 * Any wp_tablet_pad_strip.position events with the same source
+	 * after this event should be considered as the start of a new
+	 * interaction.
+	 */
+	void (*stop)(void *data,
+		     struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2);
+	/**
+	 * end of a strip event sequence
+	 *
+	 * Indicates the end of a set of events that represent one
+	 * logical hardware strip event. A client is expected to accumulate
+	 * the data in all events within the frame before proceeding.
+	 *
+	 * All wp_tablet_pad_strip events before a
+	 * wp_tablet_pad_strip.frame event belong logically together. For
+	 * example, on termination of a finger interaction on a strip the
+	 * compositor will send a wp_tablet_pad_strip.source event, a
+	 * wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
+	 * event.
+	 *
+	 * A wp_tablet_pad_strip.frame event is sent for every logical
+	 * event group, even if the group only contains a single
+	 * wp_tablet_pad_strip event. Specifically, a client may get a
+	 * sequence: position, frame, position, frame, etc.
+	 * @param time timestamp with millisecond granularity
+	 */
+	void (*frame)(void *data,
+		      struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+		      uint32_t time);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+static inline int
+zwp_tablet_pad_strip_v2_add_listener(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2,
+				     const struct zwp_tablet_pad_strip_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_strip_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK 0
+#define ZWP_TABLET_PAD_STRIP_V2_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_SOURCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_POSITION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_STOP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_FRAME_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ */
+#define ZWP_TABLET_PAD_STRIP_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_pad_strip_v2 */
+static inline void
+zwp_tablet_pad_strip_v2_set_user_data(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_strip_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_pad_strip_v2 */
+static inline void *
+zwp_tablet_pad_strip_v2_get_user_data(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_strip_v2);
+}
+
+static inline uint32_t
+zwp_tablet_pad_strip_v2_get_version(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_strip_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ *
+ * Requests the compositor to use the provided feedback string
+ * associated with this strip. This request should be issued immediately
+ * after a wp_tablet_pad_group.mode_switch event from the corresponding
+ * group is received, or whenever the strip is mapped to a different
+ * action. See wp_tablet_pad_group.mode_switch for more details.
+ *
+ * Clients are encouraged to provide context-aware descriptions for
+ * the actions associated with the strip, and compositors may use this
+ * information to offer visual feedback about the button layout
+ * (eg. on-screen displays).
+ *
+ * The provided string 'description' is a UTF-8 encoded string to be
+ * associated with this ring, and is considered user-visible; general
+ * internationalization rules apply.
+ *
+ * The serial argument will be that of the last
+ * wp_tablet_pad_group.mode_switch event received for the group of this
+ * strip. Requests providing other serials than the most recent one will be
+ * ignored.
+ */
+static inline void
+zwp_tablet_pad_strip_v2_set_feedback(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2, const char *description, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_strip_v2,
+			 ZWP_TABLET_PAD_STRIP_V2_SET_FEEDBACK, description, serial);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_strip_v2
+ *
+ * This destroys the client's resource for this strip object.
+ */
+static inline void
+zwp_tablet_pad_strip_v2_destroy(struct zwp_tablet_pad_strip_v2 *zwp_tablet_pad_strip_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_strip_v2,
+			 ZWP_TABLET_PAD_STRIP_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_pad_strip_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ * @struct zwp_tablet_pad_group_v2_listener
+ */
+struct zwp_tablet_pad_group_v2_listener {
+	/**
+	 * buttons announced
+	 *
+	 * Sent on wp_tablet_pad_group initialization to announce the
+	 * available buttons in the group. Button indices start at 0, a
+	 * button may only be in one group at a time.
+	 *
+	 * This event is first sent in the initial burst of events before
+	 * the wp_tablet_pad_group.done event.
+	 *
+	 * Some buttons are reserved by the compositor. These buttons may
+	 * not be assigned to any wp_tablet_pad_group. Compositors may
+	 * broadcast this event in the case of changes to the mapping of
+	 * these reserved buttons. If the compositor happens to reserve all
+	 * buttons in a group, this event will be sent with an empty array.
+	 * @param buttons buttons in this group
+	 */
+	void (*buttons)(void *data,
+			struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+			struct wl_array *buttons);
+	/**
+	 * ring announced
+	 *
+	 * Sent on wp_tablet_pad_group initialization to announce
+	 * available rings. One event is sent for each ring available on
+	 * this pad group.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad_group.done event.
+	 */
+	void (*ring)(void *data,
+		     struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+		     struct zwp_tablet_pad_ring_v2 *ring);
+	/**
+	 * strip announced
+	 *
+	 * Sent on wp_tablet_pad initialization to announce available
+	 * strips. One event is sent for each strip available on this pad
+	 * group.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad_group.done event.
+	 */
+	void (*strip)(void *data,
+		      struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+		      struct zwp_tablet_pad_strip_v2 *strip);
+	/**
+	 * mode-switch ability announced
+	 *
+	 * Sent on wp_tablet_pad_group initialization to announce that
+	 * the pad group may switch between modes. A client may use a mode
+	 * to store a specific configuration for buttons, rings and strips
+	 * and use the wl_tablet_pad_group.mode_switch event to toggle
+	 * between these configurations. Mode indices start at 0.
+	 *
+	 * Switching modes is compositor-dependent. See the
+	 * wp_tablet_pad_group.mode_switch event for more details.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad_group.done event. This event is only sent when
+	 * more than more than one mode is available.
+	 * @param modes the number of modes
+	 */
+	void (*modes)(void *data,
+		      struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+		      uint32_t modes);
+	/**
+	 * tablet group description events sequence complete
+	 *
+	 * This event is sent immediately to signal the end of the
+	 * initial burst of descriptive events. A client may consider the
+	 * static description of the tablet to be complete and finalize
+	 * initialization of the tablet group.
+	 */
+	void (*done)(void *data,
+		     struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2);
+	/**
+	 * mode switch event
+	 *
+	 * Notification that the mode was switched.
+	 *
+	 * A mode applies to all buttons, rings and strips in a group
+	 * simultaneously, but a client is not required to assign different
+	 * actions for each mode. For example, a client may have
+	 * mode-specific button mappings but map the ring to vertical
+	 * scrolling in all modes. Mode indices start at 0.
+	 *
+	 * Switching modes is compositor-dependent. The compositor may
+	 * provide visual cues to the client about the mode, e.g. by
+	 * toggling LEDs on the tablet device. Mode-switching may be
+	 * software-controlled or controlled by one or more physical
+	 * buttons. For example, on a Wacom Intuos Pro, the button inside
+	 * the ring may be assigned to switch between modes.
+	 *
+	 * The compositor will also send this event after
+	 * wp_tablet_pad.enter on each group in order to notify of the
+	 * current mode. Groups that only feature one mode will use mode=0
+	 * when emitting this event.
+	 *
+	 * If a button action in the new mode differs from the action in
+	 * the previous mode, the client should immediately issue a
+	 * wp_tablet_pad.set_feedback request for each changed button.
+	 *
+	 * If a ring or strip action in the new mode differs from the
+	 * action in the previous mode, the client should immediately issue
+	 * a wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback
+	 * request for each changed ring or strip.
+	 * @param time the time of the event with millisecond granularity
+	 * @param mode the new mode of the pad
+	 */
+	void (*mode_switch)(void *data,
+			    struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+			    uint32_t time,
+			    uint32_t serial,
+			    uint32_t mode);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+static inline int
+zwp_tablet_pad_group_v2_add_listener(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2,
+				     const struct zwp_tablet_pad_group_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_group_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_PAD_GROUP_V2_DESTROY 0
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_BUTTONS_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_RING_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_STRIP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_MODES_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_MODE_SWITCH_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ */
+#define ZWP_TABLET_PAD_GROUP_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_pad_group_v2 */
+static inline void
+zwp_tablet_pad_group_v2_set_user_data(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_group_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_pad_group_v2 */
+static inline void *
+zwp_tablet_pad_group_v2_get_user_data(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_group_v2);
+}
+
+static inline uint32_t
+zwp_tablet_pad_group_v2_get_version(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_group_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_group_v2
+ *
+ * Destroy the wp_tablet_pad_group object. Objects created from this object
+ * are unaffected and should be destroyed separately.
+ */
+static inline void
+zwp_tablet_pad_group_v2_destroy(struct zwp_tablet_pad_group_v2 *zwp_tablet_pad_group_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_group_v2,
+			 ZWP_TABLET_PAD_GROUP_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_pad_group_v2);
+}
+
+#ifndef ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM
+#define ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ * physical button state
+ *
+ * Describes the physical state of a button that caused the button
+ * event.
+ */
+enum zwp_tablet_pad_v2_button_state {
+	/**
+	 * the button is not pressed
+	 */
+	ZWP_TABLET_PAD_V2_BUTTON_STATE_RELEASED = 0,
+	/**
+	 * the button is pressed
+	 */
+	ZWP_TABLET_PAD_V2_BUTTON_STATE_PRESSED = 1,
+};
+#endif /* ZWP_TABLET_PAD_V2_BUTTON_STATE_ENUM */
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ * @struct zwp_tablet_pad_v2_listener
+ */
+struct zwp_tablet_pad_v2_listener {
+	/**
+	 * group announced
+	 *
+	 * Sent on wp_tablet_pad initialization to announce available
+	 * groups. One event is sent for each pad group available.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad.done event. At least one group will be announced.
+	 */
+	void (*group)(void *data,
+		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		      struct zwp_tablet_pad_group_v2 *pad_group);
+	/**
+	 * path to the device
+	 *
+	 * A system-specific device path that indicates which device is
+	 * behind this wp_tablet_pad. This information may be used to
+	 * gather additional information about the device, e.g. through
+	 * libwacom.
+	 *
+	 * The format of the path is unspecified, it may be a device node,
+	 * a sysfs path, or some other identifier. It is up to the client
+	 * to identify the string provided.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad.done event.
+	 * @param path path to local device
+	 */
+	void (*path)(void *data,
+		     struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		     const char *path);
+	/**
+	 * buttons announced
+	 *
+	 * Sent on wp_tablet_pad initialization to announce the available
+	 * buttons.
+	 *
+	 * This event is sent in the initial burst of events before the
+	 * wp_tablet_pad.done event. This event is only sent when at least
+	 * one button is available.
+	 * @param buttons the number of buttons
+	 */
+	void (*buttons)(void *data,
+			struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+			uint32_t buttons);
+	/**
+	 * pad description event sequence complete
+	 *
+	 * This event signals the end of the initial burst of descriptive
+	 * events. A client may consider the static description of the pad
+	 * to be complete and finalize initialization of the pad.
+	 */
+	void (*done)(void *data,
+		     struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2);
+	/**
+	 * physical button state
+	 *
+	 * Sent whenever the physical state of a button changes.
+	 * @param time the time of the event with millisecond granularity
+	 * @param button the index of the button that changed state
+	 */
+	void (*button)(void *data,
+		       struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		       uint32_t time,
+		       uint32_t button,
+		       uint32_t state);
+	/**
+	 * enter event
+	 *
+	 * Notification that this pad is focused on the specified
+	 * surface.
+	 * @param serial serial number of the enter event
+	 * @param tablet the tablet the pad is attached to
+	 * @param surface surface the pad is focused on
+	 */
+	void (*enter)(void *data,
+		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		      uint32_t serial,
+		      struct zwp_tablet_v2 *tablet,
+		      struct wl_surface *surface);
+	/**
+	 * enter event
+	 *
+	 * Notification that this pad is no longer focused on the
+	 * specified surface.
+	 * @param serial serial number of the leave event
+	 * @param surface surface the pad is no longer focused on
+	 */
+	void (*leave)(void *data,
+		      struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+		      uint32_t serial,
+		      struct wl_surface *surface);
+	/**
+	 * pad removed event
+	 *
+	 * Sent when the pad has been removed from the system. When a
+	 * tablet is removed its pad(s) will be removed too.
+	 *
+	 * When this event is received, the client must destroy all rings,
+	 * strips and groups that were offered by this pad, and issue
+	 * wp_tablet_pad.destroy the pad itself.
+	 */
+	void (*removed)(void *data,
+			struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2);
+};
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+static inline int
+zwp_tablet_pad_v2_add_listener(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2,
+			       const struct zwp_tablet_pad_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_tablet_pad_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TABLET_PAD_V2_SET_FEEDBACK 0
+#define ZWP_TABLET_PAD_V2_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_GROUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_PATH_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_BUTTONS_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_BUTTON_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_ENTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_LEAVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_REMOVED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_SET_FEEDBACK_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ */
+#define ZWP_TABLET_PAD_V2_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_tablet_pad_v2 */
+static inline void
+zwp_tablet_pad_v2_set_user_data(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_tablet_pad_v2, user_data);
+}
+
+/** @ingroup iface_zwp_tablet_pad_v2 */
+static inline void *
+zwp_tablet_pad_v2_get_user_data(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_tablet_pad_v2);
+}
+
+static inline uint32_t
+zwp_tablet_pad_v2_get_version(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_tablet_pad_v2);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ *
+ * Requests the compositor to use the provided feedback string
+ * associated with this button. This request should be issued immediately
+ * after a wp_tablet_pad_group.mode_switch event from the corresponding
+ * group is received, or whenever a button is mapped to a different
+ * action. See wp_tablet_pad_group.mode_switch for more details.
+ *
+ * Clients are encouraged to provide context-aware descriptions for
+ * the actions associated with each button, and compositors may use
+ * this information to offer visual feedback on the button layout
+ * (e.g. on-screen displays).
+ *
+ * Button indices start at 0. Setting the feedback string on a button
+ * that is reserved by the compositor (i.e. not belonging to any
+ * wp_tablet_pad_group) does not generate an error but the compositor
+ * is free to ignore the request.
+ *
+ * The provided string 'description' is a UTF-8 encoded string to be
+ * associated with this ring, and is considered user-visible; general
+ * internationalization rules apply.
+ *
+ * The serial argument will be that of the last
+ * wp_tablet_pad_group.mode_switch event received for the group of this
+ * button. Requests providing other serials than the most recent one will
+ * be ignored.
+ */
+static inline void
+zwp_tablet_pad_v2_set_feedback(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2, uint32_t button, const char *description, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_v2,
+			 ZWP_TABLET_PAD_V2_SET_FEEDBACK, button, description, serial);
+}
+
+/**
+ * @ingroup iface_zwp_tablet_pad_v2
+ *
+ * Destroy the wp_tablet_pad object. Objects created from this object
+ * are unaffected and should be destroyed separately.
+ */
+static inline void
+zwp_tablet_pad_v2_destroy(struct zwp_tablet_pad_v2 *zwp_tablet_pad_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_tablet_pad_v2,
+			 ZWP_TABLET_PAD_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_tablet_pad_v2);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-tablet-unstable-v2-protocol.c b/src/client/wayland-tablet-unstable-v2-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..13bdfa32ef259a74807538cfd739a41cf577801a
--- /dev/null
+++ a/qtwayland/src/client/wayland-tablet-unstable-v2-protocol.c
@@ -0,0 +1,223 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright 2014 © Stephen "Lyude" Chandler Paul
+ * Copyright 2015-2016 © Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface zwp_tablet_pad_group_v2_interface;
+extern const struct wl_interface zwp_tablet_pad_ring_v2_interface;
+extern const struct wl_interface zwp_tablet_pad_strip_v2_interface;
+extern const struct wl_interface zwp_tablet_pad_v2_interface;
+extern const struct wl_interface zwp_tablet_seat_v2_interface;
+extern const struct wl_interface zwp_tablet_tool_v2_interface;
+extern const struct wl_interface zwp_tablet_v2_interface;
+
+static const struct wl_interface *tablet_unstable_v2_types[] = {
+	NULL,
+	NULL,
+	NULL,
+	&zwp_tablet_seat_v2_interface,
+	&wl_seat_interface,
+	&zwp_tablet_v2_interface,
+	&zwp_tablet_tool_v2_interface,
+	&zwp_tablet_pad_v2_interface,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	&zwp_tablet_v2_interface,
+	&wl_surface_interface,
+	&zwp_tablet_pad_ring_v2_interface,
+	&zwp_tablet_pad_strip_v2_interface,
+	&zwp_tablet_pad_group_v2_interface,
+	NULL,
+	&zwp_tablet_v2_interface,
+	&wl_surface_interface,
+	NULL,
+	&wl_surface_interface,
+};
+
+static const struct wl_message zwp_tablet_manager_v2_requests[] = {
+	{ "get_tablet_seat", "no", tablet_unstable_v2_types + 3 },
+	{ "destroy", "", tablet_unstable_v2_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_tablet_manager_v2_interface = {
+	"zwp_tablet_manager_v2", 1,
+	2, zwp_tablet_manager_v2_requests,
+	0, NULL,
+};
+
+static const struct wl_message zwp_tablet_seat_v2_requests[] = {
+	{ "destroy", "", tablet_unstable_v2_types + 0 },
+};
+
+static const struct wl_message zwp_tablet_seat_v2_events[] = {
+	{ "tablet_added", "n", tablet_unstable_v2_types + 5 },
+	{ "tool_added", "n", tablet_unstable_v2_types + 6 },
+	{ "pad_added", "n", tablet_unstable_v2_types + 7 },
+};
+
+WL_EXPORT const struct wl_interface zwp_tablet_seat_v2_interface = {
+	"zwp_tablet_seat_v2", 1,
+	1, zwp_tablet_seat_v2_requests,
+	3, zwp_tablet_seat_v2_events,
+};
+
+static const struct wl_message zwp_tablet_tool_v2_requests[] = {
+	{ "set_cursor", "u?oii", tablet_unstable_v2_types + 8 },
+	{ "destroy", "", tablet_unstable_v2_types + 0 },
+};
+
+static const struct wl_message zwp_tablet_tool_v2_events[] = {
+	{ "type", "u", tablet_unstable_v2_types + 0 },
+	{ "hardware_serial", "uu", tablet_unstable_v2_types + 0 },
+	{ "hardware_id_wacom", "uu", tablet_unstable_v2_types + 0 },
+	{ "capability", "u", tablet_unstable_v2_types + 0 },
+	{ "done", "", tablet_unstable_v2_types + 0 },
+	{ "removed", "", tablet_unstable_v2_types + 0 },
+	{ "proximity_in", "uoo", tablet_unstable_v2_types + 12 },
+	{ "proximity_out", "", tablet_unstable_v2_types + 0 },
+	{ "down", "u", tablet_unstable_v2_types + 0 },
+	{ "up", "", tablet_unstable_v2_types + 0 },
+	{ "motion", "ff", tablet_unstable_v2_types + 0 },
+	{ "pressure", "u", tablet_unstable_v2_types + 0 },
+	{ "distance", "u", tablet_unstable_v2_types + 0 },
+	{ "tilt", "ff", tablet_unstable_v2_types + 0 },
+	{ "rotation", "f", tablet_unstable_v2_types + 0 },
+	{ "slider", "i", tablet_unstable_v2_types + 0 },
+	{ "wheel", "fi", tablet_unstable_v2_types + 0 },
+	{ "button", "uuu", tablet_unstable_v2_types + 0 },
+	{ "frame", "u", tablet_unstable_v2_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_tablet_tool_v2_interface = {
+	"zwp_tablet_tool_v2", 1,
+	2, zwp_tablet_tool_v2_requests,
+	19, zwp_tablet_tool_v2_events,
+};
+
+static const struct wl_message zwp_tablet_v2_requests[] = {
+	{ "destroy", "", tablet_unstable_v2_types + 0 },
+};
+
+static const struct wl_message zwp_tablet_v2_events[] = {
+	{ "name", "s", tablet_unstable_v2_types + 0 },
+	{ "id", "uu", tablet_unstable_v2_types + 0 },
+	{ "path", "s", tablet_unstable_v2_types + 0 },
+	{ "done", "", tablet_unstable_v2_types + 0 },
+	{ "removed", "", tablet_unstable_v2_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_tablet_v2_interface = {
+	"zwp_tablet_v2", 1,
+	1, zwp_tablet_v2_requests,
+	5, zwp_tablet_v2_events,
+};
+
+static const struct wl_message zwp_tablet_pad_ring_v2_requests[] = {
+	{ "set_feedback", "su", tablet_unstable_v2_types + 0 },
+	{ "destroy", "", tablet_unstable_v2_types + 0 },
+};
+
+static const struct wl_message zwp_tablet_pad_ring_v2_events[] = {
+	{ "source", "u", tablet_unstable_v2_types + 0 },
+	{ "angle", "f", tablet_unstable_v2_types + 0 },
+	{ "stop", "", tablet_unstable_v2_types + 0 },
+	{ "frame", "u", tablet_unstable_v2_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_tablet_pad_ring_v2_interface = {
+	"zwp_tablet_pad_ring_v2", 1,
+	2, zwp_tablet_pad_ring_v2_requests,
+	4, zwp_tablet_pad_ring_v2_events,
+};
+
+static const struct wl_message zwp_tablet_pad_strip_v2_requests[] = {
+	{ "set_feedback", "su", tablet_unstable_v2_types + 0 },
+	{ "destroy", "", tablet_unstable_v2_types + 0 },
+};
+
+static const struct wl_message zwp_tablet_pad_strip_v2_events[] = {
+	{ "source", "u", tablet_unstable_v2_types + 0 },
+	{ "position", "u", tablet_unstable_v2_types + 0 },
+	{ "stop", "", tablet_unstable_v2_types + 0 },
+	{ "frame", "u", tablet_unstable_v2_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_tablet_pad_strip_v2_interface = {
+	"zwp_tablet_pad_strip_v2", 1,
+	2, zwp_tablet_pad_strip_v2_requests,
+	4, zwp_tablet_pad_strip_v2_events,
+};
+
+static const struct wl_message zwp_tablet_pad_group_v2_requests[] = {
+	{ "destroy", "", tablet_unstable_v2_types + 0 },
+};
+
+static const struct wl_message zwp_tablet_pad_group_v2_events[] = {
+	{ "buttons", "a", tablet_unstable_v2_types + 0 },
+	{ "ring", "n", tablet_unstable_v2_types + 15 },
+	{ "strip", "n", tablet_unstable_v2_types + 16 },
+	{ "modes", "u", tablet_unstable_v2_types + 0 },
+	{ "done", "", tablet_unstable_v2_types + 0 },
+	{ "mode_switch", "uuu", tablet_unstable_v2_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_tablet_pad_group_v2_interface = {
+	"zwp_tablet_pad_group_v2", 1,
+	1, zwp_tablet_pad_group_v2_requests,
+	6, zwp_tablet_pad_group_v2_events,
+};
+
+static const struct wl_message zwp_tablet_pad_v2_requests[] = {
+	{ "set_feedback", "usu", tablet_unstable_v2_types + 0 },
+	{ "destroy", "", tablet_unstable_v2_types + 0 },
+};
+
+static const struct wl_message zwp_tablet_pad_v2_events[] = {
+	{ "group", "n", tablet_unstable_v2_types + 17 },
+	{ "path", "s", tablet_unstable_v2_types + 0 },
+	{ "buttons", "u", tablet_unstable_v2_types + 0 },
+	{ "done", "", tablet_unstable_v2_types + 0 },
+	{ "button", "uuu", tablet_unstable_v2_types + 0 },
+	{ "enter", "uoo", tablet_unstable_v2_types + 18 },
+	{ "leave", "uo", tablet_unstable_v2_types + 21 },
+	{ "removed", "", tablet_unstable_v2_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_tablet_pad_v2_interface = {
+	"zwp_tablet_pad_v2", 1,
+	2, zwp_tablet_pad_v2_requests,
+	8, zwp_tablet_pad_v2_events,
+};
+
diff --git a/src/client/wayland-text-input-unstable-v2-client-protocol.h b/src/client/wayland-text-input-unstable-v2-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..eca09006805ff93b57289c0a66d93883867743f5
--- /dev/null
+++ a/qtwayland/src/client/wayland-text-input-unstable-v2-client-protocol.h
@@ -0,0 +1,974 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef TEXT_INPUT_UNSTABLE_V2_CLIENT_PROTOCOL_H
+#define TEXT_INPUT_UNSTABLE_V2_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_text_input_unstable_v2 The text_input_unstable_v2 protocol
+ * @section page_ifaces_text_input_unstable_v2 Interfaces
+ * - @subpage page_iface_zwp_text_input_v2 - text input
+ * - @subpage page_iface_zwp_text_input_manager_v2 - text input manager
+ * @section page_copyright_text_input_unstable_v2 Copyright
+ * <pre>
+ *
+ * Copyright © 2012, 2013 Intel Corporation
+ * Copyright © 2015, 2016 Jan Arne Petersen
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ * </pre>
+ */
+struct wl_seat;
+struct wl_surface;
+struct zwp_text_input_manager_v2;
+struct zwp_text_input_v2;
+
+#ifndef ZWP_TEXT_INPUT_V2_INTERFACE
+#define ZWP_TEXT_INPUT_V2_INTERFACE
+/**
+ * @page page_iface_zwp_text_input_v2 zwp_text_input_v2
+ * @section page_iface_zwp_text_input_v2_desc Description
+ *
+ * The zwp_text_input_v2 interface represents text input and input methods
+ * associated with a seat. It provides enter/leave events to follow the
+ * text input focus for a seat.
+ *
+ * Requests are used to enable/disable the text-input object and set
+ * state information like surrounding and selected text or the content type.
+ * The information about the entered text is sent to the text-input object
+ * via the pre-edit and commit events. Using this interface removes the need
+ * for applications to directly process hardware key events and compose text
+ * out of them.
+ *
+ * Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
+ * have to always point to the first byte of an UTF-8 encoded code point.
+ * Lengths are not allowed to contain just a part of an UTF-8 encoded code
+ * point.
+ *
+ * State is sent by the state requests (set_surrounding_text,
+ * set_content_type, set_cursor_rectangle and set_preferred_language) and
+ * an update_state request. After an enter or an input_method_change event
+ * all state information is invalidated and needs to be resent from the
+ * client. A reset or entering a new widget on client side also
+ * invalidates all current state information.
+ * @section page_iface_zwp_text_input_v2_api API
+ * See @ref iface_zwp_text_input_v2.
+ */
+/**
+ * @defgroup iface_zwp_text_input_v2 The zwp_text_input_v2 interface
+ *
+ * The zwp_text_input_v2 interface represents text input and input methods
+ * associated with a seat. It provides enter/leave events to follow the
+ * text input focus for a seat.
+ *
+ * Requests are used to enable/disable the text-input object and set
+ * state information like surrounding and selected text or the content type.
+ * The information about the entered text is sent to the text-input object
+ * via the pre-edit and commit events. Using this interface removes the need
+ * for applications to directly process hardware key events and compose text
+ * out of them.
+ *
+ * Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
+ * have to always point to the first byte of an UTF-8 encoded code point.
+ * Lengths are not allowed to contain just a part of an UTF-8 encoded code
+ * point.
+ *
+ * State is sent by the state requests (set_surrounding_text,
+ * set_content_type, set_cursor_rectangle and set_preferred_language) and
+ * an update_state request. After an enter or an input_method_change event
+ * all state information is invalidated and needs to be resent from the
+ * client. A reset or entering a new widget on client side also
+ * invalidates all current state information.
+ */
+extern const struct wl_interface zwp_text_input_v2_interface;
+#endif
+#ifndef ZWP_TEXT_INPUT_MANAGER_V2_INTERFACE
+#define ZWP_TEXT_INPUT_MANAGER_V2_INTERFACE
+/**
+ * @page page_iface_zwp_text_input_manager_v2 zwp_text_input_manager_v2
+ * @section page_iface_zwp_text_input_manager_v2_desc Description
+ *
+ * A factory for text-input objects. This object is a global singleton.
+ * @section page_iface_zwp_text_input_manager_v2_api API
+ * See @ref iface_zwp_text_input_manager_v2.
+ */
+/**
+ * @defgroup iface_zwp_text_input_manager_v2 The zwp_text_input_manager_v2 interface
+ *
+ * A factory for text-input objects. This object is a global singleton.
+ */
+extern const struct wl_interface zwp_text_input_manager_v2_interface;
+#endif
+
+#ifndef ZWP_TEXT_INPUT_V2_CONTENT_HINT_ENUM
+#define ZWP_TEXT_INPUT_V2_CONTENT_HINT_ENUM
+/**
+ * @ingroup iface_zwp_text_input_v2
+ * content hint
+ *
+ * Content hint is a bitmask to allow to modify the behavior of the text
+ * input.
+ */
+enum zwp_text_input_v2_content_hint {
+	/**
+	 * no special behaviour
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_NONE = 0x0,
+	/**
+	 * suggest word completions
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_AUTO_COMPLETION = 0x1,
+	/**
+	 * suggest word corrections
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_AUTO_CORRECTION = 0x2,
+	/**
+	 * switch to uppercase letters at the start of a sentence
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_AUTO_CAPITALIZATION = 0x4,
+	/**
+	 * prefer lowercase letters
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_LOWERCASE = 0x8,
+	/**
+	 * prefer uppercase letters
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_UPPERCASE = 0x10,
+	/**
+	 * prefer casing for titles and headings (can be language dependent)
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_TITLECASE = 0x20,
+	/**
+	 * characters should be hidden
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_HIDDEN_TEXT = 0x40,
+	/**
+	 * typed text should not be stored
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_SENSITIVE_DATA = 0x80,
+	/**
+	 * just latin characters should be entered
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_LATIN = 0x100,
+	/**
+	 * the text input is multiline
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_HINT_MULTILINE = 0x200,
+};
+#endif /* ZWP_TEXT_INPUT_V2_CONTENT_HINT_ENUM */
+
+#ifndef ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_ENUM
+#define ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_ENUM
+/**
+ * @ingroup iface_zwp_text_input_v2
+ * content purpose
+ *
+ * The content purpose allows to specify the primary purpose of a text
+ * input.
+ *
+ * This allows an input method to show special purpose input panels with
+ * extra characters or to disallow some characters.
+ */
+enum zwp_text_input_v2_content_purpose {
+	/**
+	 * default input, allowing all characters
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_NORMAL = 0,
+	/**
+	 * allow only alphabetic characters
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_ALPHA = 1,
+	/**
+	 * allow only digits
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_DIGITS = 2,
+	/**
+	 * input a number (including decimal separator and sign)
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_NUMBER = 3,
+	/**
+	 * input a phone number
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_PHONE = 4,
+	/**
+	 * input an URL
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_URL = 5,
+	/**
+	 * input an email address
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_EMAIL = 6,
+	/**
+	 * input a name of a person
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_NAME = 7,
+	/**
+	 * input a password (combine with password or sensitive_data hint)
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_PASSWORD = 8,
+	/**
+	 * input a date
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_DATE = 9,
+	/**
+	 * input a time
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_TIME = 10,
+	/**
+	 * input a date and time
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_DATETIME = 11,
+	/**
+	 * input for a terminal
+	 */
+	ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_TERMINAL = 12,
+};
+#endif /* ZWP_TEXT_INPUT_V2_CONTENT_PURPOSE_ENUM */
+
+#ifndef ZWP_TEXT_INPUT_V2_UPDATE_STATE_ENUM
+#define ZWP_TEXT_INPUT_V2_UPDATE_STATE_ENUM
+/**
+ * @ingroup iface_zwp_text_input_v2
+ * update_state flags
+ *
+ * Defines the reason for sending an updated state.
+ */
+enum zwp_text_input_v2_update_state {
+	/**
+	 * updated state because it changed
+	 */
+	ZWP_TEXT_INPUT_V2_UPDATE_STATE_CHANGE = 0,
+	/**
+	 * full state after enter or input_method_changed event
+	 */
+	ZWP_TEXT_INPUT_V2_UPDATE_STATE_FULL = 1,
+	/**
+	 * full state after reset
+	 */
+	ZWP_TEXT_INPUT_V2_UPDATE_STATE_RESET = 2,
+	/**
+	 * full state after switching focus to a different widget on client side
+	 */
+	ZWP_TEXT_INPUT_V2_UPDATE_STATE_ENTER = 3,
+};
+#endif /* ZWP_TEXT_INPUT_V2_UPDATE_STATE_ENUM */
+
+#ifndef ZWP_TEXT_INPUT_V2_INPUT_PANEL_VISIBILITY_ENUM
+#define ZWP_TEXT_INPUT_V2_INPUT_PANEL_VISIBILITY_ENUM
+enum zwp_text_input_v2_input_panel_visibility {
+	/**
+	 * the input panel (virtual keyboard) is hidden
+	 */
+	ZWP_TEXT_INPUT_V2_INPUT_PANEL_VISIBILITY_HIDDEN = 0,
+	/**
+	 * the input panel (virtual keyboard) is visible
+	 */
+	ZWP_TEXT_INPUT_V2_INPUT_PANEL_VISIBILITY_VISIBLE = 1,
+};
+#endif /* ZWP_TEXT_INPUT_V2_INPUT_PANEL_VISIBILITY_ENUM */
+
+#ifndef ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_ENUM
+#define ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_ENUM
+enum zwp_text_input_v2_preedit_style {
+	/**
+	 * default style for composing text
+	 */
+	ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_DEFAULT = 0,
+	/**
+	 * composing text should be shown the same as non-composing text
+	 */
+	ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_NONE = 1,
+	/**
+	 * composing text might be bold
+	 */
+	ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_ACTIVE = 2,
+	/**
+	 * composing text might be cursive
+	 */
+	ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_INACTIVE = 3,
+	/**
+	 * composing text might have a different background color
+	 */
+	ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_HIGHLIGHT = 4,
+	/**
+	 * composing text might be underlined
+	 */
+	ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_UNDERLINE = 5,
+	/**
+	 * composing text should be shown the same as selected text
+	 */
+	ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_SELECTION = 6,
+	/**
+	 * composing text might be underlined with a red wavy line
+	 */
+	ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_INCORRECT = 7,
+};
+#endif /* ZWP_TEXT_INPUT_V2_PREEDIT_STYLE_ENUM */
+
+#ifndef ZWP_TEXT_INPUT_V2_TEXT_DIRECTION_ENUM
+#define ZWP_TEXT_INPUT_V2_TEXT_DIRECTION_ENUM
+enum zwp_text_input_v2_text_direction {
+	/**
+	 * automatic text direction based on text and language
+	 */
+	ZWP_TEXT_INPUT_V2_TEXT_DIRECTION_AUTO = 0,
+	/**
+	 * left-to-right
+	 */
+	ZWP_TEXT_INPUT_V2_TEXT_DIRECTION_LTR = 1,
+	/**
+	 * right-to-left
+	 */
+	ZWP_TEXT_INPUT_V2_TEXT_DIRECTION_RTL = 2,
+};
+#endif /* ZWP_TEXT_INPUT_V2_TEXT_DIRECTION_ENUM */
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ * @struct zwp_text_input_v2_listener
+ */
+struct zwp_text_input_v2_listener {
+	/**
+	 * enter event
+	 *
+	 * Notification that this seat's text-input focus is on a certain
+	 * surface.
+	 *
+	 * When the seat has the keyboard capability the text-input focus
+	 * follows the keyboard focus.
+	 * @param serial serial to be used by update_state
+	 */
+	void (*enter)(void *data,
+		      struct zwp_text_input_v2 *zwp_text_input_v2,
+		      uint32_t serial,
+		      struct wl_surface *surface);
+	/**
+	 * leave event
+	 *
+	 * Notification that this seat's text-input focus is no longer on
+	 * a certain surface.
+	 *
+	 * The leave notification is sent before the enter notification for
+	 * the new focus.
+	 *
+	 * When the seat has the keyboard capabillity the text-input focus
+	 * follows the keyboard focus.
+	 */
+	void (*leave)(void *data,
+		      struct zwp_text_input_v2 *zwp_text_input_v2,
+		      uint32_t serial,
+		      struct wl_surface *surface);
+	/**
+	 * state of the input panel
+	 *
+	 * Notification that the visibility of the input panel (virtual
+	 * keyboard) changed.
+	 *
+	 * The rectangle x, y, width, height defines the area overlapped by
+	 * the input panel (virtual keyboard) on the surface having the
+	 * text focus in surface local coordinates.
+	 *
+	 * That can be used to make sure widgets are visible and not
+	 * covered by a virtual keyboard.
+	 */
+	void (*input_panel_state)(void *data,
+				  struct zwp_text_input_v2 *zwp_text_input_v2,
+				  uint32_t state,
+				  int32_t x,
+				  int32_t y,
+				  int32_t width,
+				  int32_t height);
+	/**
+	 * pre-edit
+	 *
+	 * Notify when a new composing text (pre-edit) should be set
+	 * around the current cursor position. Any previously set composing
+	 * text should be removed.
+	 *
+	 * The commit text can be used to replace the composing text in
+	 * some cases (for example when losing focus).
+	 *
+	 * The text input should also handle all preedit_style and
+	 * preedit_cursor events occurring directly before preedit_string.
+	 */
+	void (*preedit_string)(void *data,
+			       struct zwp_text_input_v2 *zwp_text_input_v2,
+			       const char *text,
+			       const char *commit);
+	/**
+	 * pre-edit styling
+	 *
+	 * Sets styling information on composing text. The style is
+	 * applied for length bytes from index relative to the beginning of
+	 * the composing text (as byte offset). Multiple styles can be
+	 * applied to a composing text by sending multiple preedit_styling
+	 * events.
+	 *
+	 * This event is handled as part of a following preedit_string
+	 * event.
+	 */
+	void (*preedit_styling)(void *data,
+				struct zwp_text_input_v2 *zwp_text_input_v2,
+				uint32_t index,
+				uint32_t length,
+				uint32_t style);
+	/**
+	 * pre-edit cursor
+	 *
+	 * Sets the cursor position inside the composing text (as byte
+	 * offset) relative to the start of the composing text. When index
+	 * is a negative number no cursor is shown.
+	 *
+	 * When no preedit_cursor event is sent the cursor will be at the
+	 * end of the composing text by default.
+	 *
+	 * This event is handled as part of a following preedit_string
+	 * event.
+	 */
+	void (*preedit_cursor)(void *data,
+			       struct zwp_text_input_v2 *zwp_text_input_v2,
+			       int32_t index);
+	/**
+	 * commit
+	 *
+	 * Notify when text should be inserted into the editor widget.
+	 * The text to commit could be either just a single character after
+	 * a key press or the result of some composing (pre-edit). It could
+	 * be also an empty text when some text should be removed (see
+	 * delete_surrounding_text) or when the input cursor should be
+	 * moved (see cursor_position).
+	 *
+	 * Any previously set composing text should be removed.
+	 */
+	void (*commit_string)(void *data,
+			      struct zwp_text_input_v2 *zwp_text_input_v2,
+			      const char *text);
+	/**
+	 * set cursor to new position
+	 *
+	 * Notify when the cursor or anchor position should be modified.
+	 *
+	 * This event should be handled as part of a following
+	 * commit_string event.
+	 *
+	 * The text between anchor and index should be selected.
+	 * @param index position of cursor
+	 * @param anchor position of selection anchor
+	 */
+	void (*cursor_position)(void *data,
+				struct zwp_text_input_v2 *zwp_text_input_v2,
+				int32_t index,
+				int32_t anchor);
+	/**
+	 * delete surrounding text
+	 *
+	 * Notify when the text around the current cursor position should
+	 * be deleted. BeforeLength and afterLength is the length (in
+	 * bytes) of text before and after the current cursor position
+	 * (excluding the selection) to delete.
+	 *
+	 * This event should be handled as part of a following
+	 * commit_string or preedit_string event.
+	 * @param before_length length of text before current cursor positon
+	 * @param after_length length of text after current cursor positon
+	 */
+	void (*delete_surrounding_text)(void *data,
+					struct zwp_text_input_v2 *zwp_text_input_v2,
+					uint32_t before_length,
+					uint32_t after_length);
+	/**
+	 * modifiers map
+	 *
+	 * Transfer an array of 0-terminated modifiers names. The
+	 * position in the array is the index of the modifier as used in
+	 * the modifiers bitmask in the keysym event.
+	 */
+	void (*modifiers_map)(void *data,
+			      struct zwp_text_input_v2 *zwp_text_input_v2,
+			      struct wl_array *map);
+	/**
+	 * keysym
+	 *
+	 * Notify when a key event was sent. Key events should not be
+	 * used for normal text input operations, which should be done with
+	 * commit_string, delete_surrounding_text, etc. The key event
+	 * follows the wl_keyboard key event convention. Sym is a XKB
+	 * keysym, state a wl_keyboard key_state. Modifiers are a mask for
+	 * effective modifiers (where the modifier indices are set by the
+	 * modifiers_map event)
+	 */
+	void (*keysym)(void *data,
+		       struct zwp_text_input_v2 *zwp_text_input_v2,
+		       uint32_t time,
+		       uint32_t sym,
+		       uint32_t state,
+		       uint32_t modifiers);
+	/**
+	 * language
+	 *
+	 * Sets the language of the input text. The "language" argument
+	 * is a RFC-3066 format language tag.
+	 */
+	void (*language)(void *data,
+			 struct zwp_text_input_v2 *zwp_text_input_v2,
+			 const char *language);
+	/**
+	 * text direction
+	 *
+	 * Sets the text direction of input text.
+	 *
+	 * It is mainly needed for showing input cursor on correct side of
+	 * the editor when there is no input yet done and making sure
+	 * neutral direction text is laid out properly.
+	 */
+	void (*text_direction)(void *data,
+			       struct zwp_text_input_v2 *zwp_text_input_v2,
+			       uint32_t direction);
+	/**
+	 * configure amount of surrounding text to be sent
+	 *
+	 * Configure what amount of surrounding text is expected by the
+	 * input method. The surrounding text will be sent in the
+	 * set_surrounding_text request on the following state information
+	 * updates.
+	 */
+	void (*configure_surrounding_text)(void *data,
+					   struct zwp_text_input_v2 *zwp_text_input_v2,
+					   int32_t before_cursor,
+					   int32_t after_cursor);
+	/**
+	 * Notifies about a changed input method
+	 *
+	 * The input method changed on compositor side, which invalidates
+	 * all current state information. New state information should be
+	 * sent from the client via state requests (set_surrounding_text,
+	 * set_content_hint, ...) and update_state.
+	 * @param serial serial to be used by update_state
+	 * @param flags currently unused
+	 */
+	void (*input_method_changed)(void *data,
+				     struct zwp_text_input_v2 *zwp_text_input_v2,
+				     uint32_t serial,
+				     uint32_t flags);
+};
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+static inline int
+zwp_text_input_v2_add_listener(struct zwp_text_input_v2 *zwp_text_input_v2,
+			       const struct zwp_text_input_v2_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_text_input_v2,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_TEXT_INPUT_V2_DESTROY 0
+#define ZWP_TEXT_INPUT_V2_ENABLE 1
+#define ZWP_TEXT_INPUT_V2_DISABLE 2
+#define ZWP_TEXT_INPUT_V2_SHOW_INPUT_PANEL 3
+#define ZWP_TEXT_INPUT_V2_HIDE_INPUT_PANEL 4
+#define ZWP_TEXT_INPUT_V2_SET_SURROUNDING_TEXT 5
+#define ZWP_TEXT_INPUT_V2_SET_CONTENT_TYPE 6
+#define ZWP_TEXT_INPUT_V2_SET_CURSOR_RECTANGLE 7
+#define ZWP_TEXT_INPUT_V2_SET_PREFERRED_LANGUAGE 8
+#define ZWP_TEXT_INPUT_V2_UPDATE_STATE 9
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_ENTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_LEAVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_INPUT_PANEL_STATE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_PREEDIT_STRING_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_PREEDIT_STYLING_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_PREEDIT_CURSOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_COMMIT_STRING_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_CURSOR_POSITION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_DELETE_SURROUNDING_TEXT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_MODIFIERS_MAP_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_KEYSYM_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_LANGUAGE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_TEXT_DIRECTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_CONFIGURE_SURROUNDING_TEXT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_INPUT_METHOD_CHANGED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_ENABLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_DISABLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_SHOW_INPUT_PANEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_HIDE_INPUT_PANEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_SET_SURROUNDING_TEXT_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_SET_CONTENT_TYPE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_SET_CURSOR_RECTANGLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_SET_PREFERRED_LANGUAGE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_v2
+ */
+#define ZWP_TEXT_INPUT_V2_UPDATE_STATE_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_text_input_v2 */
+static inline void
+zwp_text_input_v2_set_user_data(struct zwp_text_input_v2 *zwp_text_input_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_text_input_v2, user_data);
+}
+
+/** @ingroup iface_zwp_text_input_v2 */
+static inline void *
+zwp_text_input_v2_get_user_data(struct zwp_text_input_v2 *zwp_text_input_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_text_input_v2);
+}
+
+static inline uint32_t
+zwp_text_input_v2_get_version(struct zwp_text_input_v2 *zwp_text_input_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_text_input_v2);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Destroy the wp_text_input object. Also disables all surfaces enabled
+ * through this wp_text_input object
+ */
+static inline void
+zwp_text_input_v2_destroy(struct zwp_text_input_v2 *zwp_text_input_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_text_input_v2);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Enable text input in a surface (usually when a text entry inside of it
+ * has focus).
+ *
+ * This can be called before or after a surface gets text (or keyboard)
+ * focus via the enter event. Text input to a surface is only active
+ * when it has the current text (or keyboard) focus and is enabled.
+ */
+static inline void
+zwp_text_input_v2_enable(struct zwp_text_input_v2 *zwp_text_input_v2, struct wl_surface *surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_ENABLE, surface);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Disable text input in a surface (typically when there is no focus on any
+ * text entry inside the surface).
+ */
+static inline void
+zwp_text_input_v2_disable(struct zwp_text_input_v2 *zwp_text_input_v2, struct wl_surface *surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_DISABLE, surface);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Requests input panels (virtual keyboard) to show.
+ *
+ * This should be used for example to show a virtual keyboard again
+ * (with a tap) after it was closed by pressing on a close button on the
+ * keyboard.
+ */
+static inline void
+zwp_text_input_v2_show_input_panel(struct zwp_text_input_v2 *zwp_text_input_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_SHOW_INPUT_PANEL);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Requests input panels (virtual keyboard) to hide.
+ */
+static inline void
+zwp_text_input_v2_hide_input_panel(struct zwp_text_input_v2 *zwp_text_input_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_HIDE_INPUT_PANEL);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Sets the plain surrounding text around the input position. Text is
+ * UTF-8 encoded. Cursor is the byte offset within the surrounding text.
+ * Anchor is the byte offset of the selection anchor within the
+ * surrounding text. If there is no selected text, anchor is the same as
+ * cursor.
+ *
+ * Make sure to always send some text before and after the cursor
+ * except when the cursor is at the beginning or end of text.
+ *
+ * When there was a configure_surrounding_text event take the
+ * before_cursor and after_cursor arguments into account for picking how
+ * much surrounding text to send.
+ *
+ * There is a maximum length of wayland messages so text can not be
+ * longer than 4000 bytes.
+ */
+static inline void
+zwp_text_input_v2_set_surrounding_text(struct zwp_text_input_v2 *zwp_text_input_v2, const char *text, int32_t cursor, int32_t anchor)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_SET_SURROUNDING_TEXT, text, cursor, anchor);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Sets the content purpose and content hint. While the purpose is the
+ * basic purpose of an input field, the hint flags allow to modify some
+ * of the behavior.
+ *
+ * When no content type is explicitly set, a normal content purpose with
+ * none hint should be assumed.
+ */
+static inline void
+zwp_text_input_v2_set_content_type(struct zwp_text_input_v2 *zwp_text_input_v2, uint32_t hint, uint32_t purpose)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_SET_CONTENT_TYPE, hint, purpose);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Sets the cursor outline as a x, y, width, height rectangle in surface
+ * local coordinates.
+ *
+ * Allows the compositor to put a window with word suggestions near the
+ * cursor.
+ */
+static inline void
+zwp_text_input_v2_set_cursor_rectangle(struct zwp_text_input_v2 *zwp_text_input_v2, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_SET_CURSOR_RECTANGLE, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Sets a specific language. This allows for example a virtual keyboard to
+ * show a language specific layout. The "language" argument is a RFC-3066
+ * format language tag.
+ *
+ * It could be used for example in a word processor to indicate language of
+ * currently edited document or in an instant message application which
+ * tracks languages of contacts.
+ */
+static inline void
+zwp_text_input_v2_set_preferred_language(struct zwp_text_input_v2 *zwp_text_input_v2, const char *language)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_SET_PREFERRED_LANGUAGE, language);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_v2
+ *
+ * Allows to atomically send state updates from client.
+ *
+ * This request should follow after a batch of state updating requests
+ * like set_surrounding_text, set_content_type, set_cursor_rectangle and
+ * set_preferred_language.
+ *
+ * The flags field indicates why an updated state is sent to the input
+ * method.
+ *
+ * Reset should be used by an editor widget after the text was changed
+ * outside of the normal input method flow.
+ *
+ * For "change" it is enough to send the changed state, else the full
+ * state should be send.
+ *
+ * Serial should be set to the serial from the last enter or
+ * input_method_changed event.
+ *
+ * To make sure to not receive outdated input method events after a
+ * reset or switching to a new widget wl_display_sync() should be used
+ * after update_state in these cases.
+ */
+static inline void
+zwp_text_input_v2_update_state(struct zwp_text_input_v2 *zwp_text_input_v2, uint32_t serial, uint32_t reason)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_v2,
+			 ZWP_TEXT_INPUT_V2_UPDATE_STATE, serial, reason);
+}
+
+#define ZWP_TEXT_INPUT_MANAGER_V2_DESTROY 0
+#define ZWP_TEXT_INPUT_MANAGER_V2_GET_TEXT_INPUT 1
+
+
+/**
+ * @ingroup iface_zwp_text_input_manager_v2
+ */
+#define ZWP_TEXT_INPUT_MANAGER_V2_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_text_input_manager_v2
+ */
+#define ZWP_TEXT_INPUT_MANAGER_V2_GET_TEXT_INPUT_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_text_input_manager_v2 */
+static inline void
+zwp_text_input_manager_v2_set_user_data(struct zwp_text_input_manager_v2 *zwp_text_input_manager_v2, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_text_input_manager_v2, user_data);
+}
+
+/** @ingroup iface_zwp_text_input_manager_v2 */
+static inline void *
+zwp_text_input_manager_v2_get_user_data(struct zwp_text_input_manager_v2 *zwp_text_input_manager_v2)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_text_input_manager_v2);
+}
+
+static inline uint32_t
+zwp_text_input_manager_v2_get_version(struct zwp_text_input_manager_v2 *zwp_text_input_manager_v2)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_text_input_manager_v2);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_manager_v2
+ *
+ * Destroy the wp_text_input_manager object.
+ */
+static inline void
+zwp_text_input_manager_v2_destroy(struct zwp_text_input_manager_v2 *zwp_text_input_manager_v2)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_text_input_manager_v2,
+			 ZWP_TEXT_INPUT_MANAGER_V2_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_text_input_manager_v2);
+}
+
+/**
+ * @ingroup iface_zwp_text_input_manager_v2
+ *
+ * Creates a new text-input object for a given seat.
+ */
+static inline struct zwp_text_input_v2 *
+zwp_text_input_manager_v2_get_text_input(struct zwp_text_input_manager_v2 *zwp_text_input_manager_v2, struct wl_seat *seat)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_text_input_manager_v2,
+			 ZWP_TEXT_INPUT_MANAGER_V2_GET_TEXT_INPUT, &zwp_text_input_v2_interface, NULL, seat);
+
+	return (struct zwp_text_input_v2 *) id;
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-text-input-unstable-v2-protocol.c b/src/client/wayland-text-input-unstable-v2-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..ce19c6d2acae8720f5db824bae2368a55cd4bff0
--- /dev/null
+++ a/qtwayland/src/client/wayland-text-input-unstable-v2-protocol.c
@@ -0,0 +1,100 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright © 2012, 2013 Intel Corporation
+ * Copyright © 2015, 2016 Jan Arne Petersen
+ *
+ * Permission to use, copy, modify, distribute, and sell this
+ * software and its documentation for any purpose is hereby granted
+ * without fee, provided that the above copyright notice appear in
+ * all copies and that both that copyright notice and this permission
+ * notice appear in supporting documentation, and that the name of
+ * the copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+ * THIS SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface zwp_text_input_v2_interface;
+
+static const struct wl_interface *text_input_unstable_v2_types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	&wl_surface_interface,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	&wl_surface_interface,
+	&zwp_text_input_v2_interface,
+	&wl_seat_interface,
+};
+
+static const struct wl_message zwp_text_input_v2_requests[] = {
+	{ "destroy", "", text_input_unstable_v2_types + 0 },
+	{ "enable", "o", text_input_unstable_v2_types + 5 },
+	{ "disable", "o", text_input_unstable_v2_types + 6 },
+	{ "show_input_panel", "", text_input_unstable_v2_types + 0 },
+	{ "hide_input_panel", "", text_input_unstable_v2_types + 0 },
+	{ "set_surrounding_text", "sii", text_input_unstable_v2_types + 0 },
+	{ "set_content_type", "uu", text_input_unstable_v2_types + 0 },
+	{ "set_cursor_rectangle", "iiii", text_input_unstable_v2_types + 0 },
+	{ "set_preferred_language", "s", text_input_unstable_v2_types + 0 },
+	{ "update_state", "uu", text_input_unstable_v2_types + 0 },
+};
+
+static const struct wl_message zwp_text_input_v2_events[] = {
+	{ "enter", "uo", text_input_unstable_v2_types + 7 },
+	{ "leave", "uo", text_input_unstable_v2_types + 9 },
+	{ "input_panel_state", "uiiii", text_input_unstable_v2_types + 0 },
+	{ "preedit_string", "ss", text_input_unstable_v2_types + 0 },
+	{ "preedit_styling", "uuu", text_input_unstable_v2_types + 0 },
+	{ "preedit_cursor", "i", text_input_unstable_v2_types + 0 },
+	{ "commit_string", "s", text_input_unstable_v2_types + 0 },
+	{ "cursor_position", "ii", text_input_unstable_v2_types + 0 },
+	{ "delete_surrounding_text", "uu", text_input_unstable_v2_types + 0 },
+	{ "modifiers_map", "a", text_input_unstable_v2_types + 0 },
+	{ "keysym", "uuuu", text_input_unstable_v2_types + 0 },
+	{ "language", "s", text_input_unstable_v2_types + 0 },
+	{ "text_direction", "u", text_input_unstable_v2_types + 0 },
+	{ "configure_surrounding_text", "ii", text_input_unstable_v2_types + 0 },
+	{ "input_method_changed", "uu", text_input_unstable_v2_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_text_input_v2_interface = {
+	"zwp_text_input_v2", 1,
+	10, zwp_text_input_v2_requests,
+	15, zwp_text_input_v2_events,
+};
+
+static const struct wl_message zwp_text_input_manager_v2_requests[] = {
+	{ "destroy", "", text_input_unstable_v2_types + 0 },
+	{ "get_text_input", "no", text_input_unstable_v2_types + 11 },
+};
+
+WL_EXPORT const struct wl_interface zwp_text_input_manager_v2_interface = {
+	"zwp_text_input_manager_v2", 1,
+	2, zwp_text_input_manager_v2_requests,
+	0, NULL,
+};
+
diff --git a/src/client/wayland-touch-extension-client-protocol.h b/src/client/wayland-touch-extension-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..9c502fc67b03b6832333059bd8a27dd19604eb59
--- /dev/null
+++ a/qtwayland/src/client/wayland-touch-extension-client-protocol.h
@@ -0,0 +1,178 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef TOUCH_EXTENSION_CLIENT_PROTOCOL_H
+#define TOUCH_EXTENSION_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_touch_extension The touch_extension protocol
+ * @section page_ifaces_touch_extension Interfaces
+ * - @subpage page_iface_qt_touch_extension - 
+ * @section page_copyright_touch_extension Copyright
+ * <pre>
+ *
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ * </pre>
+ */
+struct qt_touch_extension;
+
+#ifndef QT_TOUCH_EXTENSION_INTERFACE
+#define QT_TOUCH_EXTENSION_INTERFACE
+/**
+ * @page page_iface_qt_touch_extension qt_touch_extension
+ * @section page_iface_qt_touch_extension_api API
+ * See @ref iface_qt_touch_extension.
+ */
+/**
+ * @defgroup iface_qt_touch_extension The qt_touch_extension interface
+ */
+extern const struct wl_interface qt_touch_extension_interface;
+#endif
+
+#ifndef QT_TOUCH_EXTENSION_FLAGS_ENUM
+#define QT_TOUCH_EXTENSION_FLAGS_ENUM
+enum qt_touch_extension_flags {
+	QT_TOUCH_EXTENSION_FLAGS_MOUSE_FROM_TOUCH = 0x1,
+};
+#endif /* QT_TOUCH_EXTENSION_FLAGS_ENUM */
+
+/**
+ * @ingroup iface_qt_touch_extension
+ * @struct qt_touch_extension_listener
+ */
+struct qt_touch_extension_listener {
+	/**
+	 */
+	void (*touch)(void *data,
+		      struct qt_touch_extension *qt_touch_extension,
+		      uint32_t time,
+		      uint32_t id,
+		      uint32_t state,
+		      int32_t x,
+		      int32_t y,
+		      int32_t normalized_x,
+		      int32_t normalized_y,
+		      int32_t width,
+		      int32_t height,
+		      uint32_t pressure,
+		      int32_t velocity_x,
+		      int32_t velocity_y,
+		      uint32_t flags,
+		      struct wl_array *rawdata);
+	/**
+	 */
+	void (*configure)(void *data,
+			  struct qt_touch_extension *qt_touch_extension,
+			  uint32_t flags);
+};
+
+/**
+ * @ingroup iface_qt_touch_extension
+ */
+static inline int
+qt_touch_extension_add_listener(struct qt_touch_extension *qt_touch_extension,
+				const struct qt_touch_extension_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) qt_touch_extension,
+				     (void (**)(void)) listener, data);
+}
+
+#define QT_TOUCH_EXTENSION_DUMMY 0
+
+/**
+ * @ingroup iface_qt_touch_extension
+ */
+#define QT_TOUCH_EXTENSION_TOUCH_SINCE_VERSION 1
+/**
+ * @ingroup iface_qt_touch_extension
+ */
+#define QT_TOUCH_EXTENSION_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_qt_touch_extension
+ */
+#define QT_TOUCH_EXTENSION_DUMMY_SINCE_VERSION 1
+
+/** @ingroup iface_qt_touch_extension */
+static inline void
+qt_touch_extension_set_user_data(struct qt_touch_extension *qt_touch_extension, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) qt_touch_extension, user_data);
+}
+
+/** @ingroup iface_qt_touch_extension */
+static inline void *
+qt_touch_extension_get_user_data(struct qt_touch_extension *qt_touch_extension)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) qt_touch_extension);
+}
+
+static inline uint32_t
+qt_touch_extension_get_version(struct qt_touch_extension *qt_touch_extension)
+{
+	return wl_proxy_get_version((struct wl_proxy *) qt_touch_extension);
+}
+
+/** @ingroup iface_qt_touch_extension */
+static inline void
+qt_touch_extension_destroy(struct qt_touch_extension *qt_touch_extension)
+{
+	wl_proxy_destroy((struct wl_proxy *) qt_touch_extension);
+}
+
+/**
+ * @ingroup iface_qt_touch_extension
+ */
+static inline void
+qt_touch_extension_dummy(struct qt_touch_extension *qt_touch_extension)
+{
+	wl_proxy_marshal((struct wl_proxy *) qt_touch_extension,
+			 QT_TOUCH_EXTENSION_DUMMY);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-touch-extension-protocol.c b/src/client/wayland-touch-extension-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..a423b894b2a25cc576fbbca6b7e99bf1330d9afe
--- /dev/null
+++ a/qtwayland/src/client/wayland-touch-extension-protocol.c
@@ -0,0 +1,77 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright (C) 2015 The Qt Company Ltd.
+ * Contact: http://www.qt.io/licensing/
+ *
+ * This file is part of the plugins of the Qt Toolkit.
+ *
+ * $QT_BEGIN_LICENSE:BSD$
+ * You may use this file under the terms of the BSD license as follows:
+ *
+ * "Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * * Neither the name of The Qt Company Ltd nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+ *
+ * $QT_END_LICENSE$
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+
+static const struct wl_interface *touch_extension_types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+static const struct wl_message qt_touch_extension_requests[] = {
+	{ "dummy", "", touch_extension_types + 0 },
+};
+
+static const struct wl_message qt_touch_extension_events[] = {
+	{ "touch", "uuuiiiiiiuiiua", touch_extension_types + 0 },
+	{ "configure", "u", touch_extension_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface qt_touch_extension_interface = {
+	"qt_touch_extension", 1,
+	1, qt_touch_extension_requests,
+	2, qt_touch_extension_events,
+};
+
diff --git a/src/client/wayland-wayland-client-protocol.h b/src/client/wayland-wayland-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..c366d58defbf6418bec8131fe620acbab9869b21
--- /dev/null
+++ a/qtwayland/src/client/wayland-wayland-client-protocol.h
@@ -0,0 +1,5676 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef WAYLAND_CLIENT_PROTOCOL_H
+#define WAYLAND_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_wayland The wayland protocol
+ * @section page_ifaces_wayland Interfaces
+ * - @subpage page_iface_wl_display - core global object
+ * - @subpage page_iface_wl_registry - global registry object
+ * - @subpage page_iface_wl_callback - callback object
+ * - @subpage page_iface_wl_compositor - the compositor singleton
+ * - @subpage page_iface_wl_shm_pool - a shared memory pool
+ * - @subpage page_iface_wl_shm - shared memory support
+ * - @subpage page_iface_wl_buffer - content for a wl_surface
+ * - @subpage page_iface_wl_data_offer - offer to transfer data
+ * - @subpage page_iface_wl_data_source - offer to transfer data
+ * - @subpage page_iface_wl_data_device - data transfer device
+ * - @subpage page_iface_wl_data_device_manager - data transfer interface
+ * - @subpage page_iface_wl_shell - create desktop-style surfaces
+ * - @subpage page_iface_wl_shell_surface - desktop-style metadata interface
+ * - @subpage page_iface_wl_surface - an onscreen surface
+ * - @subpage page_iface_wl_seat - group of input devices
+ * - @subpage page_iface_wl_pointer - pointer input device
+ * - @subpage page_iface_wl_keyboard - keyboard input device
+ * - @subpage page_iface_wl_touch - touchscreen input device
+ * - @subpage page_iface_wl_output - compositor output region
+ * - @subpage page_iface_wl_region - region interface
+ * - @subpage page_iface_wl_subcompositor - sub-surface compositing
+ * - @subpage page_iface_wl_subsurface - sub-surface interface to a wl_surface
+ * @section page_copyright_wayland Copyright
+ * <pre>
+ *
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2010-2011 Intel Corporation
+ * Copyright © 2012-2013 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * </pre>
+ */
+struct wl_buffer;
+struct wl_callback;
+struct wl_compositor;
+struct wl_data_device;
+struct wl_data_device_manager;
+struct wl_data_offer;
+struct wl_data_source;
+struct wl_display;
+struct wl_keyboard;
+struct wl_output;
+struct wl_pointer;
+struct wl_region;
+struct wl_registry;
+struct wl_seat;
+struct wl_shell;
+struct wl_shell_surface;
+struct wl_shm;
+struct wl_shm_pool;
+struct wl_subcompositor;
+struct wl_subsurface;
+struct wl_surface;
+struct wl_touch;
+
+#ifndef WL_DISPLAY_INTERFACE
+#define WL_DISPLAY_INTERFACE
+/**
+ * @page page_iface_wl_display wl_display
+ * @section page_iface_wl_display_desc Description
+ *
+ * The core global object.  This is a special singleton object.  It
+ * is used for internal Wayland protocol features.
+ * @section page_iface_wl_display_api API
+ * See @ref iface_wl_display.
+ */
+/**
+ * @defgroup iface_wl_display The wl_display interface
+ *
+ * The core global object.  This is a special singleton object.  It
+ * is used for internal Wayland protocol features.
+ */
+extern const struct wl_interface wl_display_interface;
+#endif
+#ifndef WL_REGISTRY_INTERFACE
+#define WL_REGISTRY_INTERFACE
+/**
+ * @page page_iface_wl_registry wl_registry
+ * @section page_iface_wl_registry_desc Description
+ *
+ * The singleton global registry object.  The server has a number of
+ * global objects that are available to all clients.  These objects
+ * typically represent an actual object in the server (for example,
+ * an input device) or they are singleton objects that provide
+ * extension functionality.
+ *
+ * When a client creates a registry object, the registry object
+ * will emit a global event for each global currently in the
+ * registry.  Globals come and go as a result of device or
+ * monitor hotplugs, reconfiguration or other events, and the
+ * registry will send out global and global_remove events to
+ * keep the client up to date with the changes.  To mark the end
+ * of the initial burst of events, the client can use the
+ * wl_display.sync request immediately after calling
+ * wl_display.get_registry.
+ *
+ * A client can bind to a global object by using the bind
+ * request.  This creates a client-side handle that lets the object
+ * emit events to the client and lets the client invoke requests on
+ * the object.
+ * @section page_iface_wl_registry_api API
+ * See @ref iface_wl_registry.
+ */
+/**
+ * @defgroup iface_wl_registry The wl_registry interface
+ *
+ * The singleton global registry object.  The server has a number of
+ * global objects that are available to all clients.  These objects
+ * typically represent an actual object in the server (for example,
+ * an input device) or they are singleton objects that provide
+ * extension functionality.
+ *
+ * When a client creates a registry object, the registry object
+ * will emit a global event for each global currently in the
+ * registry.  Globals come and go as a result of device or
+ * monitor hotplugs, reconfiguration or other events, and the
+ * registry will send out global and global_remove events to
+ * keep the client up to date with the changes.  To mark the end
+ * of the initial burst of events, the client can use the
+ * wl_display.sync request immediately after calling
+ * wl_display.get_registry.
+ *
+ * A client can bind to a global object by using the bind
+ * request.  This creates a client-side handle that lets the object
+ * emit events to the client and lets the client invoke requests on
+ * the object.
+ */
+extern const struct wl_interface wl_registry_interface;
+#endif
+#ifndef WL_CALLBACK_INTERFACE
+#define WL_CALLBACK_INTERFACE
+/**
+ * @page page_iface_wl_callback wl_callback
+ * @section page_iface_wl_callback_desc Description
+ *
+ * Clients can handle the 'done' event to get notified when
+ * the related request is done.
+ * @section page_iface_wl_callback_api API
+ * See @ref iface_wl_callback.
+ */
+/**
+ * @defgroup iface_wl_callback The wl_callback interface
+ *
+ * Clients can handle the 'done' event to get notified when
+ * the related request is done.
+ */
+extern const struct wl_interface wl_callback_interface;
+#endif
+#ifndef WL_COMPOSITOR_INTERFACE
+#define WL_COMPOSITOR_INTERFACE
+/**
+ * @page page_iface_wl_compositor wl_compositor
+ * @section page_iface_wl_compositor_desc Description
+ *
+ * A compositor.  This object is a singleton global.  The
+ * compositor is in charge of combining the contents of multiple
+ * surfaces into one displayable output.
+ * @section page_iface_wl_compositor_api API
+ * See @ref iface_wl_compositor.
+ */
+/**
+ * @defgroup iface_wl_compositor The wl_compositor interface
+ *
+ * A compositor.  This object is a singleton global.  The
+ * compositor is in charge of combining the contents of multiple
+ * surfaces into one displayable output.
+ */
+extern const struct wl_interface wl_compositor_interface;
+#endif
+#ifndef WL_SHM_POOL_INTERFACE
+#define WL_SHM_POOL_INTERFACE
+/**
+ * @page page_iface_wl_shm_pool wl_shm_pool
+ * @section page_iface_wl_shm_pool_desc Description
+ *
+ * The wl_shm_pool object encapsulates a piece of memory shared
+ * between the compositor and client.  Through the wl_shm_pool
+ * object, the client can allocate shared memory wl_buffer objects.
+ * All objects created through the same pool share the same
+ * underlying mapped memory. Reusing the mapped memory avoids the
+ * setup/teardown overhead and is useful when interactively resizing
+ * a surface or for many small buffers.
+ * @section page_iface_wl_shm_pool_api API
+ * See @ref iface_wl_shm_pool.
+ */
+/**
+ * @defgroup iface_wl_shm_pool The wl_shm_pool interface
+ *
+ * The wl_shm_pool object encapsulates a piece of memory shared
+ * between the compositor and client.  Through the wl_shm_pool
+ * object, the client can allocate shared memory wl_buffer objects.
+ * All objects created through the same pool share the same
+ * underlying mapped memory. Reusing the mapped memory avoids the
+ * setup/teardown overhead and is useful when interactively resizing
+ * a surface or for many small buffers.
+ */
+extern const struct wl_interface wl_shm_pool_interface;
+#endif
+#ifndef WL_SHM_INTERFACE
+#define WL_SHM_INTERFACE
+/**
+ * @page page_iface_wl_shm wl_shm
+ * @section page_iface_wl_shm_desc Description
+ *
+ * A singleton global object that provides support for shared
+ * memory.
+ *
+ * Clients can create wl_shm_pool objects using the create_pool
+ * request.
+ *
+ * At connection setup time, the wl_shm object emits one or more
+ * format events to inform clients about the valid pixel formats
+ * that can be used for buffers.
+ * @section page_iface_wl_shm_api API
+ * See @ref iface_wl_shm.
+ */
+/**
+ * @defgroup iface_wl_shm The wl_shm interface
+ *
+ * A singleton global object that provides support for shared
+ * memory.
+ *
+ * Clients can create wl_shm_pool objects using the create_pool
+ * request.
+ *
+ * At connection setup time, the wl_shm object emits one or more
+ * format events to inform clients about the valid pixel formats
+ * that can be used for buffers.
+ */
+extern const struct wl_interface wl_shm_interface;
+#endif
+#ifndef WL_BUFFER_INTERFACE
+#define WL_BUFFER_INTERFACE
+/**
+ * @page page_iface_wl_buffer wl_buffer
+ * @section page_iface_wl_buffer_desc Description
+ *
+ * A buffer provides the content for a wl_surface. Buffers are
+ * created through factory interfaces such as wl_drm, wl_shm or
+ * similar. It has a width and a height and can be attached to a
+ * wl_surface, but the mechanism by which a client provides and
+ * updates the contents is defined by the buffer factory interface.
+ * @section page_iface_wl_buffer_api API
+ * See @ref iface_wl_buffer.
+ */
+/**
+ * @defgroup iface_wl_buffer The wl_buffer interface
+ *
+ * A buffer provides the content for a wl_surface. Buffers are
+ * created through factory interfaces such as wl_drm, wl_shm or
+ * similar. It has a width and a height and can be attached to a
+ * wl_surface, but the mechanism by which a client provides and
+ * updates the contents is defined by the buffer factory interface.
+ */
+extern const struct wl_interface wl_buffer_interface;
+#endif
+#ifndef WL_DATA_OFFER_INTERFACE
+#define WL_DATA_OFFER_INTERFACE
+/**
+ * @page page_iface_wl_data_offer wl_data_offer
+ * @section page_iface_wl_data_offer_desc Description
+ *
+ * A wl_data_offer represents a piece of data offered for transfer
+ * by another client (the source client).  It is used by the
+ * copy-and-paste and drag-and-drop mechanisms.  The offer
+ * describes the different mime types that the data can be
+ * converted to and provides the mechanism for transferring the
+ * data directly from the source client.
+ * @section page_iface_wl_data_offer_api API
+ * See @ref iface_wl_data_offer.
+ */
+/**
+ * @defgroup iface_wl_data_offer The wl_data_offer interface
+ *
+ * A wl_data_offer represents a piece of data offered for transfer
+ * by another client (the source client).  It is used by the
+ * copy-and-paste and drag-and-drop mechanisms.  The offer
+ * describes the different mime types that the data can be
+ * converted to and provides the mechanism for transferring the
+ * data directly from the source client.
+ */
+extern const struct wl_interface wl_data_offer_interface;
+#endif
+#ifndef WL_DATA_SOURCE_INTERFACE
+#define WL_DATA_SOURCE_INTERFACE
+/**
+ * @page page_iface_wl_data_source wl_data_source
+ * @section page_iface_wl_data_source_desc Description
+ *
+ * The wl_data_source object is the source side of a wl_data_offer.
+ * It is created by the source client in a data transfer and
+ * provides a way to describe the offered data and a way to respond
+ * to requests to transfer the data.
+ * @section page_iface_wl_data_source_api API
+ * See @ref iface_wl_data_source.
+ */
+/**
+ * @defgroup iface_wl_data_source The wl_data_source interface
+ *
+ * The wl_data_source object is the source side of a wl_data_offer.
+ * It is created by the source client in a data transfer and
+ * provides a way to describe the offered data and a way to respond
+ * to requests to transfer the data.
+ */
+extern const struct wl_interface wl_data_source_interface;
+#endif
+#ifndef WL_DATA_DEVICE_INTERFACE
+#define WL_DATA_DEVICE_INTERFACE
+/**
+ * @page page_iface_wl_data_device wl_data_device
+ * @section page_iface_wl_data_device_desc Description
+ *
+ * There is one wl_data_device per seat which can be obtained
+ * from the global wl_data_device_manager singleton.
+ *
+ * A wl_data_device provides access to inter-client data transfer
+ * mechanisms such as copy-and-paste and drag-and-drop.
+ * @section page_iface_wl_data_device_api API
+ * See @ref iface_wl_data_device.
+ */
+/**
+ * @defgroup iface_wl_data_device The wl_data_device interface
+ *
+ * There is one wl_data_device per seat which can be obtained
+ * from the global wl_data_device_manager singleton.
+ *
+ * A wl_data_device provides access to inter-client data transfer
+ * mechanisms such as copy-and-paste and drag-and-drop.
+ */
+extern const struct wl_interface wl_data_device_interface;
+#endif
+#ifndef WL_DATA_DEVICE_MANAGER_INTERFACE
+#define WL_DATA_DEVICE_MANAGER_INTERFACE
+/**
+ * @page page_iface_wl_data_device_manager wl_data_device_manager
+ * @section page_iface_wl_data_device_manager_desc Description
+ *
+ * The wl_data_device_manager is a singleton global object that
+ * provides access to inter-client data transfer mechanisms such as
+ * copy-and-paste and drag-and-drop.  These mechanisms are tied to
+ * a wl_seat and this interface lets a client get a wl_data_device
+ * corresponding to a wl_seat.
+ *
+ * Depending on the version bound, the objects created from the bound
+ * wl_data_device_manager object will have different requirements for
+ * functioning properly. See wl_data_source.set_actions,
+ * wl_data_offer.accept and wl_data_offer.finish for details.
+ * @section page_iface_wl_data_device_manager_api API
+ * See @ref iface_wl_data_device_manager.
+ */
+/**
+ * @defgroup iface_wl_data_device_manager The wl_data_device_manager interface
+ *
+ * The wl_data_device_manager is a singleton global object that
+ * provides access to inter-client data transfer mechanisms such as
+ * copy-and-paste and drag-and-drop.  These mechanisms are tied to
+ * a wl_seat and this interface lets a client get a wl_data_device
+ * corresponding to a wl_seat.
+ *
+ * Depending on the version bound, the objects created from the bound
+ * wl_data_device_manager object will have different requirements for
+ * functioning properly. See wl_data_source.set_actions,
+ * wl_data_offer.accept and wl_data_offer.finish for details.
+ */
+extern const struct wl_interface wl_data_device_manager_interface;
+#endif
+#ifndef WL_SHELL_INTERFACE
+#define WL_SHELL_INTERFACE
+/**
+ * @page page_iface_wl_shell wl_shell
+ * @section page_iface_wl_shell_desc Description
+ *
+ * This interface is implemented by servers that provide
+ * desktop-style user interfaces.
+ *
+ * It allows clients to associate a wl_shell_surface with
+ * a basic surface.
+ *
+ * Note! This protocol is deprecated and not intended for production use.
+ * For desktop-style user interfaces, use xdg_shell.
+ * @section page_iface_wl_shell_api API
+ * See @ref iface_wl_shell.
+ */
+/**
+ * @defgroup iface_wl_shell The wl_shell interface
+ *
+ * This interface is implemented by servers that provide
+ * desktop-style user interfaces.
+ *
+ * It allows clients to associate a wl_shell_surface with
+ * a basic surface.
+ *
+ * Note! This protocol is deprecated and not intended for production use.
+ * For desktop-style user interfaces, use xdg_shell.
+ */
+extern const struct wl_interface wl_shell_interface;
+#endif
+#ifndef WL_SHELL_SURFACE_INTERFACE
+#define WL_SHELL_SURFACE_INTERFACE
+/**
+ * @page page_iface_wl_shell_surface wl_shell_surface
+ * @section page_iface_wl_shell_surface_desc Description
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides requests to treat surfaces like toplevel, fullscreen
+ * or popup windows, move, resize or maximize them, associate
+ * metadata like title and class, etc.
+ *
+ * On the server side the object is automatically destroyed when
+ * the related wl_surface is destroyed. On the client side,
+ * wl_shell_surface_destroy() must be called before destroying
+ * the wl_surface object.
+ * @section page_iface_wl_shell_surface_api API
+ * See @ref iface_wl_shell_surface.
+ */
+/**
+ * @defgroup iface_wl_shell_surface The wl_shell_surface interface
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides requests to treat surfaces like toplevel, fullscreen
+ * or popup windows, move, resize or maximize them, associate
+ * metadata like title and class, etc.
+ *
+ * On the server side the object is automatically destroyed when
+ * the related wl_surface is destroyed. On the client side,
+ * wl_shell_surface_destroy() must be called before destroying
+ * the wl_surface object.
+ */
+extern const struct wl_interface wl_shell_surface_interface;
+#endif
+#ifndef WL_SURFACE_INTERFACE
+#define WL_SURFACE_INTERFACE
+/**
+ * @page page_iface_wl_surface wl_surface
+ * @section page_iface_wl_surface_desc Description
+ *
+ * A surface is a rectangular area that is displayed on the screen.
+ * It has a location, size and pixel contents.
+ *
+ * The size of a surface (and relative positions on it) is described
+ * in surface-local coordinates, which may differ from the buffer
+ * coordinates of the pixel content, in case a buffer_transform
+ * or a buffer_scale is used.
+ *
+ * A surface without a "role" is fairly useless: a compositor does
+ * not know where, when or how to present it. The role is the
+ * purpose of a wl_surface. Examples of roles are a cursor for a
+ * pointer (as set by wl_pointer.set_cursor), a drag icon
+ * (wl_data_device.start_drag), a sub-surface
+ * (wl_subcompositor.get_subsurface), and a window as defined by a
+ * shell protocol (e.g. wl_shell.get_shell_surface).
+ *
+ * A surface can have only one role at a time. Initially a
+ * wl_surface does not have a role. Once a wl_surface is given a
+ * role, it is set permanently for the whole lifetime of the
+ * wl_surface object. Giving the current role again is allowed,
+ * unless explicitly forbidden by the relevant interface
+ * specification.
+ *
+ * Surface roles are given by requests in other interfaces such as
+ * wl_pointer.set_cursor. The request should explicitly mention
+ * that this request gives a role to a wl_surface. Often, this
+ * request also creates a new protocol object that represents the
+ * role and adds additional functionality to wl_surface. When a
+ * client wants to destroy a wl_surface, they must destroy this 'role
+ * object' before the wl_surface.
+ *
+ * Destroying the role object does not remove the role from the
+ * wl_surface, but it may stop the wl_surface from "playing the role".
+ * For instance, if a wl_subsurface object is destroyed, the wl_surface
+ * it was created for will be unmapped and forget its position and
+ * z-order. It is allowed to create a wl_subsurface for the same
+ * wl_surface again, but it is not allowed to use the wl_surface as
+ * a cursor (cursor is a different role than sub-surface, and role
+ * switching is not allowed).
+ * @section page_iface_wl_surface_api API
+ * See @ref iface_wl_surface.
+ */
+/**
+ * @defgroup iface_wl_surface The wl_surface interface
+ *
+ * A surface is a rectangular area that is displayed on the screen.
+ * It has a location, size and pixel contents.
+ *
+ * The size of a surface (and relative positions on it) is described
+ * in surface-local coordinates, which may differ from the buffer
+ * coordinates of the pixel content, in case a buffer_transform
+ * or a buffer_scale is used.
+ *
+ * A surface without a "role" is fairly useless: a compositor does
+ * not know where, when or how to present it. The role is the
+ * purpose of a wl_surface. Examples of roles are a cursor for a
+ * pointer (as set by wl_pointer.set_cursor), a drag icon
+ * (wl_data_device.start_drag), a sub-surface
+ * (wl_subcompositor.get_subsurface), and a window as defined by a
+ * shell protocol (e.g. wl_shell.get_shell_surface).
+ *
+ * A surface can have only one role at a time. Initially a
+ * wl_surface does not have a role. Once a wl_surface is given a
+ * role, it is set permanently for the whole lifetime of the
+ * wl_surface object. Giving the current role again is allowed,
+ * unless explicitly forbidden by the relevant interface
+ * specification.
+ *
+ * Surface roles are given by requests in other interfaces such as
+ * wl_pointer.set_cursor. The request should explicitly mention
+ * that this request gives a role to a wl_surface. Often, this
+ * request also creates a new protocol object that represents the
+ * role and adds additional functionality to wl_surface. When a
+ * client wants to destroy a wl_surface, they must destroy this 'role
+ * object' before the wl_surface.
+ *
+ * Destroying the role object does not remove the role from the
+ * wl_surface, but it may stop the wl_surface from "playing the role".
+ * For instance, if a wl_subsurface object is destroyed, the wl_surface
+ * it was created for will be unmapped and forget its position and
+ * z-order. It is allowed to create a wl_subsurface for the same
+ * wl_surface again, but it is not allowed to use the wl_surface as
+ * a cursor (cursor is a different role than sub-surface, and role
+ * switching is not allowed).
+ */
+extern const struct wl_interface wl_surface_interface;
+#endif
+#ifndef WL_SEAT_INTERFACE
+#define WL_SEAT_INTERFACE
+/**
+ * @page page_iface_wl_seat wl_seat
+ * @section page_iface_wl_seat_desc Description
+ *
+ * A seat is a group of keyboards, pointer and touch devices. This
+ * object is published as a global during start up, or when such a
+ * device is hot plugged.  A seat typically has a pointer and
+ * maintains a keyboard focus and a pointer focus.
+ * @section page_iface_wl_seat_api API
+ * See @ref iface_wl_seat.
+ */
+/**
+ * @defgroup iface_wl_seat The wl_seat interface
+ *
+ * A seat is a group of keyboards, pointer and touch devices. This
+ * object is published as a global during start up, or when such a
+ * device is hot plugged.  A seat typically has a pointer and
+ * maintains a keyboard focus and a pointer focus.
+ */
+extern const struct wl_interface wl_seat_interface;
+#endif
+#ifndef WL_POINTER_INTERFACE
+#define WL_POINTER_INTERFACE
+/**
+ * @page page_iface_wl_pointer wl_pointer
+ * @section page_iface_wl_pointer_desc Description
+ *
+ * The wl_pointer interface represents one or more input devices,
+ * such as mice, which control the pointer location and pointer_focus
+ * of a seat.
+ *
+ * The wl_pointer interface generates motion, enter and leave
+ * events for the surfaces that the pointer is located over,
+ * and button and axis events for button presses, button releases
+ * and scrolling.
+ * @section page_iface_wl_pointer_api API
+ * See @ref iface_wl_pointer.
+ */
+/**
+ * @defgroup iface_wl_pointer The wl_pointer interface
+ *
+ * The wl_pointer interface represents one or more input devices,
+ * such as mice, which control the pointer location and pointer_focus
+ * of a seat.
+ *
+ * The wl_pointer interface generates motion, enter and leave
+ * events for the surfaces that the pointer is located over,
+ * and button and axis events for button presses, button releases
+ * and scrolling.
+ */
+extern const struct wl_interface wl_pointer_interface;
+#endif
+#ifndef WL_KEYBOARD_INTERFACE
+#define WL_KEYBOARD_INTERFACE
+/**
+ * @page page_iface_wl_keyboard wl_keyboard
+ * @section page_iface_wl_keyboard_desc Description
+ *
+ * The wl_keyboard interface represents one or more keyboards
+ * associated with a seat.
+ * @section page_iface_wl_keyboard_api API
+ * See @ref iface_wl_keyboard.
+ */
+/**
+ * @defgroup iface_wl_keyboard The wl_keyboard interface
+ *
+ * The wl_keyboard interface represents one or more keyboards
+ * associated with a seat.
+ */
+extern const struct wl_interface wl_keyboard_interface;
+#endif
+#ifndef WL_TOUCH_INTERFACE
+#define WL_TOUCH_INTERFACE
+/**
+ * @page page_iface_wl_touch wl_touch
+ * @section page_iface_wl_touch_desc Description
+ *
+ * The wl_touch interface represents a touchscreen
+ * associated with a seat.
+ *
+ * Touch interactions can consist of one or more contacts.
+ * For each contact, a series of events is generated, starting
+ * with a down event, followed by zero or more motion events,
+ * and ending with an up event. Events relating to the same
+ * contact point can be identified by the ID of the sequence.
+ * @section page_iface_wl_touch_api API
+ * See @ref iface_wl_touch.
+ */
+/**
+ * @defgroup iface_wl_touch The wl_touch interface
+ *
+ * The wl_touch interface represents a touchscreen
+ * associated with a seat.
+ *
+ * Touch interactions can consist of one or more contacts.
+ * For each contact, a series of events is generated, starting
+ * with a down event, followed by zero or more motion events,
+ * and ending with an up event. Events relating to the same
+ * contact point can be identified by the ID of the sequence.
+ */
+extern const struct wl_interface wl_touch_interface;
+#endif
+#ifndef WL_OUTPUT_INTERFACE
+#define WL_OUTPUT_INTERFACE
+/**
+ * @page page_iface_wl_output wl_output
+ * @section page_iface_wl_output_desc Description
+ *
+ * An output describes part of the compositor geometry.  The
+ * compositor works in the 'compositor coordinate system' and an
+ * output corresponds to a rectangular area in that space that is
+ * actually visible.  This typically corresponds to a monitor that
+ * displays part of the compositor space.  This object is published
+ * as global during start up, or when a monitor is hotplugged.
+ * @section page_iface_wl_output_api API
+ * See @ref iface_wl_output.
+ */
+/**
+ * @defgroup iface_wl_output The wl_output interface
+ *
+ * An output describes part of the compositor geometry.  The
+ * compositor works in the 'compositor coordinate system' and an
+ * output corresponds to a rectangular area in that space that is
+ * actually visible.  This typically corresponds to a monitor that
+ * displays part of the compositor space.  This object is published
+ * as global during start up, or when a monitor is hotplugged.
+ */
+extern const struct wl_interface wl_output_interface;
+#endif
+#ifndef WL_REGION_INTERFACE
+#define WL_REGION_INTERFACE
+/**
+ * @page page_iface_wl_region wl_region
+ * @section page_iface_wl_region_desc Description
+ *
+ * A region object describes an area.
+ *
+ * Region objects are used to describe the opaque and input
+ * regions of a surface.
+ * @section page_iface_wl_region_api API
+ * See @ref iface_wl_region.
+ */
+/**
+ * @defgroup iface_wl_region The wl_region interface
+ *
+ * A region object describes an area.
+ *
+ * Region objects are used to describe the opaque and input
+ * regions of a surface.
+ */
+extern const struct wl_interface wl_region_interface;
+#endif
+#ifndef WL_SUBCOMPOSITOR_INTERFACE
+#define WL_SUBCOMPOSITOR_INTERFACE
+/**
+ * @page page_iface_wl_subcompositor wl_subcompositor
+ * @section page_iface_wl_subcompositor_desc Description
+ *
+ * The global interface exposing sub-surface compositing capabilities.
+ * A wl_surface, that has sub-surfaces associated, is called the
+ * parent surface. Sub-surfaces can be arbitrarily nested and create
+ * a tree of sub-surfaces.
+ *
+ * The root surface in a tree of sub-surfaces is the main
+ * surface. The main surface cannot be a sub-surface, because
+ * sub-surfaces must always have a parent.
+ *
+ * A main surface with its sub-surfaces forms a (compound) window.
+ * For window management purposes, this set of wl_surface objects is
+ * to be considered as a single window, and it should also behave as
+ * such.
+ *
+ * The aim of sub-surfaces is to offload some of the compositing work
+ * within a window from clients to the compositor. A prime example is
+ * a video player with decorations and video in separate wl_surface
+ * objects. This should allow the compositor to pass YUV video buffer
+ * processing to dedicated overlay hardware when possible.
+ * @section page_iface_wl_subcompositor_api API
+ * See @ref iface_wl_subcompositor.
+ */
+/**
+ * @defgroup iface_wl_subcompositor The wl_subcompositor interface
+ *
+ * The global interface exposing sub-surface compositing capabilities.
+ * A wl_surface, that has sub-surfaces associated, is called the
+ * parent surface. Sub-surfaces can be arbitrarily nested and create
+ * a tree of sub-surfaces.
+ *
+ * The root surface in a tree of sub-surfaces is the main
+ * surface. The main surface cannot be a sub-surface, because
+ * sub-surfaces must always have a parent.
+ *
+ * A main surface with its sub-surfaces forms a (compound) window.
+ * For window management purposes, this set of wl_surface objects is
+ * to be considered as a single window, and it should also behave as
+ * such.
+ *
+ * The aim of sub-surfaces is to offload some of the compositing work
+ * within a window from clients to the compositor. A prime example is
+ * a video player with decorations and video in separate wl_surface
+ * objects. This should allow the compositor to pass YUV video buffer
+ * processing to dedicated overlay hardware when possible.
+ */
+extern const struct wl_interface wl_subcompositor_interface;
+#endif
+#ifndef WL_SUBSURFACE_INTERFACE
+#define WL_SUBSURFACE_INTERFACE
+/**
+ * @page page_iface_wl_subsurface wl_subsurface
+ * @section page_iface_wl_subsurface_desc Description
+ *
+ * An additional interface to a wl_surface object, which has been
+ * made a sub-surface. A sub-surface has one parent surface. A
+ * sub-surface's size and position are not limited to that of the parent.
+ * Particularly, a sub-surface is not automatically clipped to its
+ * parent's area.
+ *
+ * A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
+ * and the parent surface is mapped. The order of which one happens
+ * first is irrelevant. A sub-surface is hidden if the parent becomes
+ * hidden, or if a NULL wl_buffer is applied. These rules apply
+ * recursively through the tree of surfaces.
+ *
+ * The behaviour of a wl_surface.commit request on a sub-surface
+ * depends on the sub-surface's mode. The possible modes are
+ * synchronized and desynchronized, see methods
+ * wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
+ * mode caches the wl_surface state to be applied when the parent's
+ * state gets applied, and desynchronized mode applies the pending
+ * wl_surface state directly. A sub-surface is initially in the
+ * synchronized mode.
+ *
+ * Sub-surfaces have also other kind of state, which is managed by
+ * wl_subsurface requests, as opposed to wl_surface requests. This
+ * state includes the sub-surface position relative to the parent
+ * surface (wl_subsurface.set_position), and the stacking order of
+ * the parent and its sub-surfaces (wl_subsurface.place_above and
+ * .place_below). This state is applied when the parent surface's
+ * wl_surface state is applied, regardless of the sub-surface's mode.
+ * As the exception, set_sync and set_desync are effective immediately.
+ *
+ * The main surface can be thought to be always in desynchronized mode,
+ * since it does not have a parent in the sub-surfaces sense.
+ *
+ * Even if a sub-surface is in desynchronized mode, it will behave as
+ * in synchronized mode, if its parent surface behaves as in
+ * synchronized mode. This rule is applied recursively throughout the
+ * tree of surfaces. This means, that one can set a sub-surface into
+ * synchronized mode, and then assume that all its child and grand-child
+ * sub-surfaces are synchronized, too, without explicitly setting them.
+ *
+ * If the wl_surface associated with the wl_subsurface is destroyed, the
+ * wl_subsurface object becomes inert. Note, that destroying either object
+ * takes effect immediately. If you need to synchronize the removal
+ * of a sub-surface to the parent surface update, unmap the sub-surface
+ * first by attaching a NULL wl_buffer, update parent, and then destroy
+ * the sub-surface.
+ *
+ * If the parent wl_surface object is destroyed, the sub-surface is
+ * unmapped.
+ * @section page_iface_wl_subsurface_api API
+ * See @ref iface_wl_subsurface.
+ */
+/**
+ * @defgroup iface_wl_subsurface The wl_subsurface interface
+ *
+ * An additional interface to a wl_surface object, which has been
+ * made a sub-surface. A sub-surface has one parent surface. A
+ * sub-surface's size and position are not limited to that of the parent.
+ * Particularly, a sub-surface is not automatically clipped to its
+ * parent's area.
+ *
+ * A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
+ * and the parent surface is mapped. The order of which one happens
+ * first is irrelevant. A sub-surface is hidden if the parent becomes
+ * hidden, or if a NULL wl_buffer is applied. These rules apply
+ * recursively through the tree of surfaces.
+ *
+ * The behaviour of a wl_surface.commit request on a sub-surface
+ * depends on the sub-surface's mode. The possible modes are
+ * synchronized and desynchronized, see methods
+ * wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
+ * mode caches the wl_surface state to be applied when the parent's
+ * state gets applied, and desynchronized mode applies the pending
+ * wl_surface state directly. A sub-surface is initially in the
+ * synchronized mode.
+ *
+ * Sub-surfaces have also other kind of state, which is managed by
+ * wl_subsurface requests, as opposed to wl_surface requests. This
+ * state includes the sub-surface position relative to the parent
+ * surface (wl_subsurface.set_position), and the stacking order of
+ * the parent and its sub-surfaces (wl_subsurface.place_above and
+ * .place_below). This state is applied when the parent surface's
+ * wl_surface state is applied, regardless of the sub-surface's mode.
+ * As the exception, set_sync and set_desync are effective immediately.
+ *
+ * The main surface can be thought to be always in desynchronized mode,
+ * since it does not have a parent in the sub-surfaces sense.
+ *
+ * Even if a sub-surface is in desynchronized mode, it will behave as
+ * in synchronized mode, if its parent surface behaves as in
+ * synchronized mode. This rule is applied recursively throughout the
+ * tree of surfaces. This means, that one can set a sub-surface into
+ * synchronized mode, and then assume that all its child and grand-child
+ * sub-surfaces are synchronized, too, without explicitly setting them.
+ *
+ * If the wl_surface associated with the wl_subsurface is destroyed, the
+ * wl_subsurface object becomes inert. Note, that destroying either object
+ * takes effect immediately. If you need to synchronize the removal
+ * of a sub-surface to the parent surface update, unmap the sub-surface
+ * first by attaching a NULL wl_buffer, update parent, and then destroy
+ * the sub-surface.
+ *
+ * If the parent wl_surface object is destroyed, the sub-surface is
+ * unmapped.
+ */
+extern const struct wl_interface wl_subsurface_interface;
+#endif
+
+#ifndef WL_DISPLAY_ERROR_ENUM
+#define WL_DISPLAY_ERROR_ENUM
+/**
+ * @ingroup iface_wl_display
+ * global error values
+ *
+ * These errors are global and can be emitted in response to any
+ * server request.
+ */
+enum wl_display_error {
+	/**
+	 * server couldn't find object
+	 */
+	WL_DISPLAY_ERROR_INVALID_OBJECT = 0,
+	/**
+	 * method doesn't exist on the specified interface
+	 */
+	WL_DISPLAY_ERROR_INVALID_METHOD = 1,
+	/**
+	 * server is out of memory
+	 */
+	WL_DISPLAY_ERROR_NO_MEMORY = 2,
+};
+#endif /* WL_DISPLAY_ERROR_ENUM */
+
+/**
+ * @ingroup iface_wl_display
+ * @struct wl_display_listener
+ */
+struct wl_display_listener {
+	/**
+	 * fatal error event
+	 *
+	 * The error event is sent out when a fatal (non-recoverable)
+	 * error has occurred. The object_id argument is the object where
+	 * the error occurred, most often in response to a request to that
+	 * object. The code identifies the error and is defined by the
+	 * object interface. As such, each interface defines its own set of
+	 * error codes. The message is a brief description of the error,
+	 * for (debugging) convenience.
+	 * @param object_id object where the error occurred
+	 * @param code error code
+	 * @param message error description
+	 */
+	void (*error)(void *data,
+		      struct wl_display *wl_display,
+		      void *object_id,
+		      uint32_t code,
+		      const char *message);
+	/**
+	 * acknowledge object ID deletion
+	 *
+	 * This event is used internally by the object ID management
+	 * logic. When a client deletes an object, the server will send
+	 * this event to acknowledge that it has seen the delete request.
+	 * When the client receives this event, it will know that it can
+	 * safely reuse the object ID.
+	 * @param id deleted object ID
+	 */
+	void (*delete_id)(void *data,
+			  struct wl_display *wl_display,
+			  uint32_t id);
+};
+
+/**
+ * @ingroup iface_wl_display
+ */
+static inline int
+wl_display_add_listener(struct wl_display *wl_display,
+			const struct wl_display_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_display,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_DISPLAY_SYNC 0
+#define WL_DISPLAY_GET_REGISTRY 1
+
+/**
+ * @ingroup iface_wl_display
+ */
+#define WL_DISPLAY_ERROR_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_display
+ */
+#define WL_DISPLAY_DELETE_ID_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_wl_display
+ */
+#define WL_DISPLAY_SYNC_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_display
+ */
+#define WL_DISPLAY_GET_REGISTRY_SINCE_VERSION 1
+
+/** @ingroup iface_wl_display */
+static inline void
+wl_display_set_user_data(struct wl_display *wl_display, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_display, user_data);
+}
+
+/** @ingroup iface_wl_display */
+static inline void *
+wl_display_get_user_data(struct wl_display *wl_display)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_display);
+}
+
+static inline uint32_t
+wl_display_get_version(struct wl_display *wl_display)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_display);
+}
+
+/**
+ * @ingroup iface_wl_display
+ *
+ * The sync request asks the server to emit the 'done' event
+ * on the returned wl_callback object.  Since requests are
+ * handled in-order and events are delivered in-order, this can
+ * be used as a barrier to ensure all previous requests and the
+ * resulting events have been handled.
+ *
+ * The object returned by this request will be destroyed by the
+ * compositor after the callback is fired and as such the client must not
+ * attempt to use it after that point.
+ *
+ * The callback_data passed in the callback is the event serial.
+ */
+static inline struct wl_callback *
+wl_display_sync(struct wl_display *wl_display)
+{
+	struct wl_proxy *callback;
+
+	callback = wl_proxy_marshal_constructor((struct wl_proxy *) wl_display,
+			 WL_DISPLAY_SYNC, &wl_callback_interface, NULL);
+
+	return (struct wl_callback *) callback;
+}
+
+/**
+ * @ingroup iface_wl_display
+ *
+ * This request creates a registry object that allows the client
+ * to list and bind the global objects available from the
+ * compositor.
+ *
+ * It should be noted that the server side resources consumed in
+ * response to a get_registry request can only be released when the
+ * client disconnects, not when the client side proxy is destroyed.
+ * Therefore, clients should invoke get_registry as infrequently as
+ * possible to avoid wasting memory.
+ */
+static inline struct wl_registry *
+wl_display_get_registry(struct wl_display *wl_display)
+{
+	struct wl_proxy *registry;
+
+	registry = wl_proxy_marshal_constructor((struct wl_proxy *) wl_display,
+			 WL_DISPLAY_GET_REGISTRY, &wl_registry_interface, NULL);
+
+	return (struct wl_registry *) registry;
+}
+
+/**
+ * @ingroup iface_wl_registry
+ * @struct wl_registry_listener
+ */
+struct wl_registry_listener {
+	/**
+	 * announce global object
+	 *
+	 * Notify the client of global objects.
+	 *
+	 * The event notifies the client that a global object with the
+	 * given name is now available, and it implements the given version
+	 * of the given interface.
+	 * @param name numeric name of the global object
+	 * @param interface interface implemented by the object
+	 * @param version interface version
+	 */
+	void (*global)(void *data,
+		       struct wl_registry *wl_registry,
+		       uint32_t name,
+		       const char *interface,
+		       uint32_t version);
+	/**
+	 * announce removal of global object
+	 *
+	 * Notify the client of removed global objects.
+	 *
+	 * This event notifies the client that the global identified by
+	 * name is no longer available. If the client bound to the global
+	 * using the bind request, the client should now destroy that
+	 * object.
+	 *
+	 * The object remains valid and requests to the object will be
+	 * ignored until the client destroys it, to avoid races between the
+	 * global going away and a client sending a request to it.
+	 * @param name numeric name of the global object
+	 */
+	void (*global_remove)(void *data,
+			      struct wl_registry *wl_registry,
+			      uint32_t name);
+};
+
+/**
+ * @ingroup iface_wl_registry
+ */
+static inline int
+wl_registry_add_listener(struct wl_registry *wl_registry,
+			 const struct wl_registry_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_registry,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_REGISTRY_BIND 0
+
+/**
+ * @ingroup iface_wl_registry
+ */
+#define WL_REGISTRY_GLOBAL_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_registry
+ */
+#define WL_REGISTRY_GLOBAL_REMOVE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_wl_registry
+ */
+#define WL_REGISTRY_BIND_SINCE_VERSION 1
+
+/** @ingroup iface_wl_registry */
+static inline void
+wl_registry_set_user_data(struct wl_registry *wl_registry, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_registry, user_data);
+}
+
+/** @ingroup iface_wl_registry */
+static inline void *
+wl_registry_get_user_data(struct wl_registry *wl_registry)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_registry);
+}
+
+static inline uint32_t
+wl_registry_get_version(struct wl_registry *wl_registry)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_registry);
+}
+
+/** @ingroup iface_wl_registry */
+static inline void
+wl_registry_destroy(struct wl_registry *wl_registry)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_registry);
+}
+
+/**
+ * @ingroup iface_wl_registry
+ *
+ * Binds a new, client-created object to the server using the
+ * specified name as the identifier.
+ */
+static inline void *
+wl_registry_bind(struct wl_registry *wl_registry, uint32_t name, const struct wl_interface *interface, uint32_t version)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor_versioned((struct wl_proxy *) wl_registry,
+			 WL_REGISTRY_BIND, interface, version, name, interface->name, version, NULL);
+
+	return (void *) id;
+}
+
+/**
+ * @ingroup iface_wl_callback
+ * @struct wl_callback_listener
+ */
+struct wl_callback_listener {
+	/**
+	 * done event
+	 *
+	 * Notify the client when the related request is done.
+	 * @param callback_data request-specific data for the callback
+	 */
+	void (*done)(void *data,
+		     struct wl_callback *wl_callback,
+		     uint32_t callback_data);
+};
+
+/**
+ * @ingroup iface_wl_callback
+ */
+static inline int
+wl_callback_add_listener(struct wl_callback *wl_callback,
+			 const struct wl_callback_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_callback,
+				     (void (**)(void)) listener, data);
+}
+
+/**
+ * @ingroup iface_wl_callback
+ */
+#define WL_CALLBACK_DONE_SINCE_VERSION 1
+
+
+/** @ingroup iface_wl_callback */
+static inline void
+wl_callback_set_user_data(struct wl_callback *wl_callback, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_callback, user_data);
+}
+
+/** @ingroup iface_wl_callback */
+static inline void *
+wl_callback_get_user_data(struct wl_callback *wl_callback)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_callback);
+}
+
+static inline uint32_t
+wl_callback_get_version(struct wl_callback *wl_callback)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_callback);
+}
+
+/** @ingroup iface_wl_callback */
+static inline void
+wl_callback_destroy(struct wl_callback *wl_callback)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_callback);
+}
+
+#define WL_COMPOSITOR_CREATE_SURFACE 0
+#define WL_COMPOSITOR_CREATE_REGION 1
+
+
+/**
+ * @ingroup iface_wl_compositor
+ */
+#define WL_COMPOSITOR_CREATE_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_compositor
+ */
+#define WL_COMPOSITOR_CREATE_REGION_SINCE_VERSION 1
+
+/** @ingroup iface_wl_compositor */
+static inline void
+wl_compositor_set_user_data(struct wl_compositor *wl_compositor, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_compositor, user_data);
+}
+
+/** @ingroup iface_wl_compositor */
+static inline void *
+wl_compositor_get_user_data(struct wl_compositor *wl_compositor)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_compositor);
+}
+
+static inline uint32_t
+wl_compositor_get_version(struct wl_compositor *wl_compositor)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_compositor);
+}
+
+/** @ingroup iface_wl_compositor */
+static inline void
+wl_compositor_destroy(struct wl_compositor *wl_compositor)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_compositor);
+}
+
+/**
+ * @ingroup iface_wl_compositor
+ *
+ * Ask the compositor to create a new surface.
+ */
+static inline struct wl_surface *
+wl_compositor_create_surface(struct wl_compositor *wl_compositor)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_compositor,
+			 WL_COMPOSITOR_CREATE_SURFACE, &wl_surface_interface, NULL);
+
+	return (struct wl_surface *) id;
+}
+
+/**
+ * @ingroup iface_wl_compositor
+ *
+ * Ask the compositor to create a new region.
+ */
+static inline struct wl_region *
+wl_compositor_create_region(struct wl_compositor *wl_compositor)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_compositor,
+			 WL_COMPOSITOR_CREATE_REGION, &wl_region_interface, NULL);
+
+	return (struct wl_region *) id;
+}
+
+#define WL_SHM_POOL_CREATE_BUFFER 0
+#define WL_SHM_POOL_DESTROY 1
+#define WL_SHM_POOL_RESIZE 2
+
+
+/**
+ * @ingroup iface_wl_shm_pool
+ */
+#define WL_SHM_POOL_CREATE_BUFFER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shm_pool
+ */
+#define WL_SHM_POOL_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shm_pool
+ */
+#define WL_SHM_POOL_RESIZE_SINCE_VERSION 1
+
+/** @ingroup iface_wl_shm_pool */
+static inline void
+wl_shm_pool_set_user_data(struct wl_shm_pool *wl_shm_pool, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_shm_pool, user_data);
+}
+
+/** @ingroup iface_wl_shm_pool */
+static inline void *
+wl_shm_pool_get_user_data(struct wl_shm_pool *wl_shm_pool)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_shm_pool);
+}
+
+static inline uint32_t
+wl_shm_pool_get_version(struct wl_shm_pool *wl_shm_pool)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_shm_pool);
+}
+
+/**
+ * @ingroup iface_wl_shm_pool
+ *
+ * Create a wl_buffer object from the pool.
+ *
+ * The buffer is created offset bytes into the pool and has
+ * width and height as specified.  The stride argument specifies
+ * the number of bytes from the beginning of one row to the beginning
+ * of the next.  The format is the pixel format of the buffer and
+ * must be one of those advertised through the wl_shm.format event.
+ *
+ * A buffer will keep a reference to the pool it was created from
+ * so it is valid to destroy the pool immediately after creating
+ * a buffer from it.
+ */
+static inline struct wl_buffer *
+wl_shm_pool_create_buffer(struct wl_shm_pool *wl_shm_pool, int32_t offset, int32_t width, int32_t height, int32_t stride, uint32_t format)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_shm_pool,
+			 WL_SHM_POOL_CREATE_BUFFER, &wl_buffer_interface, NULL, offset, width, height, stride, format);
+
+	return (struct wl_buffer *) id;
+}
+
+/**
+ * @ingroup iface_wl_shm_pool
+ *
+ * Destroy the shared memory pool.
+ *
+ * The mmapped memory will be released when all
+ * buffers that have been created from this pool
+ * are gone.
+ */
+static inline void
+wl_shm_pool_destroy(struct wl_shm_pool *wl_shm_pool)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shm_pool,
+			 WL_SHM_POOL_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_shm_pool);
+}
+
+/**
+ * @ingroup iface_wl_shm_pool
+ *
+ * This request will cause the server to remap the backing memory
+ * for the pool from the file descriptor passed when the pool was
+ * created, but using the new size.  This request can only be
+ * used to make the pool bigger.
+ */
+static inline void
+wl_shm_pool_resize(struct wl_shm_pool *wl_shm_pool, int32_t size)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shm_pool,
+			 WL_SHM_POOL_RESIZE, size);
+}
+
+#ifndef WL_SHM_ERROR_ENUM
+#define WL_SHM_ERROR_ENUM
+/**
+ * @ingroup iface_wl_shm
+ * wl_shm error values
+ *
+ * These errors can be emitted in response to wl_shm requests.
+ */
+enum wl_shm_error {
+	/**
+	 * buffer format is not known
+	 */
+	WL_SHM_ERROR_INVALID_FORMAT = 0,
+	/**
+	 * invalid size or stride during pool or buffer creation
+	 */
+	WL_SHM_ERROR_INVALID_STRIDE = 1,
+	/**
+	 * mmapping the file descriptor failed
+	 */
+	WL_SHM_ERROR_INVALID_FD = 2,
+};
+#endif /* WL_SHM_ERROR_ENUM */
+
+#ifndef WL_SHM_FORMAT_ENUM
+#define WL_SHM_FORMAT_ENUM
+/**
+ * @ingroup iface_wl_shm
+ * pixel formats
+ *
+ * This describes the memory layout of an individual pixel.
+ *
+ * All renderers should support argb8888 and xrgb8888 but any other
+ * formats are optional and may not be supported by the particular
+ * renderer in use.
+ *
+ * The drm format codes match the macros defined in drm_fourcc.h.
+ * The formats actually supported by the compositor will be
+ * reported by the format event.
+ */
+enum wl_shm_format {
+	/**
+	 * 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_ARGB8888 = 0,
+	/**
+	 * 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_XRGB8888 = 1,
+	/**
+	 * 8-bit color index format, [7:0] C
+	 */
+	WL_SHM_FORMAT_C8 = 0x20203843,
+	/**
+	 * 8-bit RGB format, [7:0] R:G:B 3:3:2
+	 */
+	WL_SHM_FORMAT_RGB332 = 0x38424752,
+	/**
+	 * 8-bit BGR format, [7:0] B:G:R 2:3:3
+	 */
+	WL_SHM_FORMAT_BGR233 = 0x38524742,
+	/**
+	 * 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
+	 */
+	WL_SHM_FORMAT_XRGB4444 = 0x32315258,
+	/**
+	 * 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
+	 */
+	WL_SHM_FORMAT_XBGR4444 = 0x32314258,
+	/**
+	 * 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
+	 */
+	WL_SHM_FORMAT_RGBX4444 = 0x32315852,
+	/**
+	 * 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
+	 */
+	WL_SHM_FORMAT_BGRX4444 = 0x32315842,
+	/**
+	 * 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
+	 */
+	WL_SHM_FORMAT_ARGB4444 = 0x32315241,
+	/**
+	 * 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
+	 */
+	WL_SHM_FORMAT_ABGR4444 = 0x32314241,
+	/**
+	 * 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
+	 */
+	WL_SHM_FORMAT_RGBA4444 = 0x32314152,
+	/**
+	 * 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
+	 */
+	WL_SHM_FORMAT_BGRA4444 = 0x32314142,
+	/**
+	 * 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
+	 */
+	WL_SHM_FORMAT_XRGB1555 = 0x35315258,
+	/**
+	 * 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
+	 */
+	WL_SHM_FORMAT_XBGR1555 = 0x35314258,
+	/**
+	 * 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
+	 */
+	WL_SHM_FORMAT_RGBX5551 = 0x35315852,
+	/**
+	 * 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
+	 */
+	WL_SHM_FORMAT_BGRX5551 = 0x35315842,
+	/**
+	 * 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
+	 */
+	WL_SHM_FORMAT_ARGB1555 = 0x35315241,
+	/**
+	 * 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
+	 */
+	WL_SHM_FORMAT_ABGR1555 = 0x35314241,
+	/**
+	 * 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
+	 */
+	WL_SHM_FORMAT_RGBA5551 = 0x35314152,
+	/**
+	 * 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
+	 */
+	WL_SHM_FORMAT_BGRA5551 = 0x35314142,
+	/**
+	 * 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
+	 */
+	WL_SHM_FORMAT_RGB565 = 0x36314752,
+	/**
+	 * 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
+	 */
+	WL_SHM_FORMAT_BGR565 = 0x36314742,
+	/**
+	 * 24-bit RGB format, [23:0] R:G:B little endian
+	 */
+	WL_SHM_FORMAT_RGB888 = 0x34324752,
+	/**
+	 * 24-bit BGR format, [23:0] B:G:R little endian
+	 */
+	WL_SHM_FORMAT_BGR888 = 0x34324742,
+	/**
+	 * 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_XBGR8888 = 0x34324258,
+	/**
+	 * 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_RGBX8888 = 0x34325852,
+	/**
+	 * 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_BGRX8888 = 0x34325842,
+	/**
+	 * 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_ABGR8888 = 0x34324241,
+	/**
+	 * 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_RGBA8888 = 0x34324152,
+	/**
+	 * 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_BGRA8888 = 0x34324142,
+	/**
+	 * 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
+	 */
+	WL_SHM_FORMAT_XRGB2101010 = 0x30335258,
+	/**
+	 * 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
+	 */
+	WL_SHM_FORMAT_XBGR2101010 = 0x30334258,
+	/**
+	 * 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
+	 */
+	WL_SHM_FORMAT_RGBX1010102 = 0x30335852,
+	/**
+	 * 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
+	 */
+	WL_SHM_FORMAT_BGRX1010102 = 0x30335842,
+	/**
+	 * 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
+	 */
+	WL_SHM_FORMAT_ARGB2101010 = 0x30335241,
+	/**
+	 * 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
+	 */
+	WL_SHM_FORMAT_ABGR2101010 = 0x30334241,
+	/**
+	 * 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
+	 */
+	WL_SHM_FORMAT_RGBA1010102 = 0x30334152,
+	/**
+	 * 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
+	 */
+	WL_SHM_FORMAT_BGRA1010102 = 0x30334142,
+	/**
+	 * packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_YUYV = 0x56595559,
+	/**
+	 * packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_YVYU = 0x55595659,
+	/**
+	 * packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_UYVY = 0x59565955,
+	/**
+	 * packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_VYUY = 0x59555956,
+	/**
+	 * packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
+	 */
+	WL_SHM_FORMAT_AYUV = 0x56555941,
+	/**
+	 * 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
+	 */
+	WL_SHM_FORMAT_NV12 = 0x3231564e,
+	/**
+	 * 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
+	 */
+	WL_SHM_FORMAT_NV21 = 0x3132564e,
+	/**
+	 * 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
+	 */
+	WL_SHM_FORMAT_NV16 = 0x3631564e,
+	/**
+	 * 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
+	 */
+	WL_SHM_FORMAT_NV61 = 0x3136564e,
+	/**
+	 * 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
+	 */
+	WL_SHM_FORMAT_YUV410 = 0x39565559,
+	/**
+	 * 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
+	 */
+	WL_SHM_FORMAT_YVU410 = 0x39555659,
+	/**
+	 * 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
+	 */
+	WL_SHM_FORMAT_YUV411 = 0x31315559,
+	/**
+	 * 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
+	 */
+	WL_SHM_FORMAT_YVU411 = 0x31315659,
+	/**
+	 * 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
+	 */
+	WL_SHM_FORMAT_YUV420 = 0x32315559,
+	/**
+	 * 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
+	 */
+	WL_SHM_FORMAT_YVU420 = 0x32315659,
+	/**
+	 * 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
+	 */
+	WL_SHM_FORMAT_YUV422 = 0x36315559,
+	/**
+	 * 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
+	 */
+	WL_SHM_FORMAT_YVU422 = 0x36315659,
+	/**
+	 * 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
+	 */
+	WL_SHM_FORMAT_YUV444 = 0x34325559,
+	/**
+	 * 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
+	 */
+	WL_SHM_FORMAT_YVU444 = 0x34325659,
+};
+#endif /* WL_SHM_FORMAT_ENUM */
+
+/**
+ * @ingroup iface_wl_shm
+ * @struct wl_shm_listener
+ */
+struct wl_shm_listener {
+	/**
+	 * pixel format description
+	 *
+	 * Informs the client about a valid pixel format that can be used
+	 * for buffers. Known formats include argb8888 and xrgb8888.
+	 * @param format buffer pixel format
+	 */
+	void (*format)(void *data,
+		       struct wl_shm *wl_shm,
+		       uint32_t format);
+};
+
+/**
+ * @ingroup iface_wl_shm
+ */
+static inline int
+wl_shm_add_listener(struct wl_shm *wl_shm,
+		    const struct wl_shm_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_shm,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_SHM_CREATE_POOL 0
+
+/**
+ * @ingroup iface_wl_shm
+ */
+#define WL_SHM_FORMAT_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_wl_shm
+ */
+#define WL_SHM_CREATE_POOL_SINCE_VERSION 1
+
+/** @ingroup iface_wl_shm */
+static inline void
+wl_shm_set_user_data(struct wl_shm *wl_shm, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_shm, user_data);
+}
+
+/** @ingroup iface_wl_shm */
+static inline void *
+wl_shm_get_user_data(struct wl_shm *wl_shm)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_shm);
+}
+
+static inline uint32_t
+wl_shm_get_version(struct wl_shm *wl_shm)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_shm);
+}
+
+/** @ingroup iface_wl_shm */
+static inline void
+wl_shm_destroy(struct wl_shm *wl_shm)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_shm);
+}
+
+/**
+ * @ingroup iface_wl_shm
+ *
+ * Create a new wl_shm_pool object.
+ *
+ * The pool can be used to create shared memory based buffer
+ * objects.  The server will mmap size bytes of the passed file
+ * descriptor, to use as backing memory for the pool.
+ */
+static inline struct wl_shm_pool *
+wl_shm_create_pool(struct wl_shm *wl_shm, int32_t fd, int32_t size)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_shm,
+			 WL_SHM_CREATE_POOL, &wl_shm_pool_interface, NULL, fd, size);
+
+	return (struct wl_shm_pool *) id;
+}
+
+/**
+ * @ingroup iface_wl_buffer
+ * @struct wl_buffer_listener
+ */
+struct wl_buffer_listener {
+	/**
+	 * compositor releases buffer
+	 *
+	 * Sent when this wl_buffer is no longer used by the compositor.
+	 * The client is now free to reuse or destroy this buffer and its
+	 * backing storage.
+	 *
+	 * If a client receives a release event before the frame callback
+	 * requested in the same wl_surface.commit that attaches this
+	 * wl_buffer to a surface, then the client is immediately free to
+	 * reuse the buffer and its backing storage, and does not need a
+	 * second buffer for the next surface content update. Typically
+	 * this is possible, when the compositor maintains a copy of the
+	 * wl_surface contents, e.g. as a GL texture. This is an important
+	 * optimization for GL(ES) compositors with wl_shm clients.
+	 */
+	void (*release)(void *data,
+			struct wl_buffer *wl_buffer);
+};
+
+/**
+ * @ingroup iface_wl_buffer
+ */
+static inline int
+wl_buffer_add_listener(struct wl_buffer *wl_buffer,
+		       const struct wl_buffer_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_buffer,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_BUFFER_DESTROY 0
+
+/**
+ * @ingroup iface_wl_buffer
+ */
+#define WL_BUFFER_RELEASE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_wl_buffer
+ */
+#define WL_BUFFER_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_wl_buffer */
+static inline void
+wl_buffer_set_user_data(struct wl_buffer *wl_buffer, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_buffer, user_data);
+}
+
+/** @ingroup iface_wl_buffer */
+static inline void *
+wl_buffer_get_user_data(struct wl_buffer *wl_buffer)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_buffer);
+}
+
+static inline uint32_t
+wl_buffer_get_version(struct wl_buffer *wl_buffer)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_buffer);
+}
+
+/**
+ * @ingroup iface_wl_buffer
+ *
+ * Destroy a buffer. If and how you need to release the backing
+ * storage is defined by the buffer factory interface.
+ *
+ * For possible side-effects to a surface, see wl_surface.attach.
+ */
+static inline void
+wl_buffer_destroy(struct wl_buffer *wl_buffer)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_buffer,
+			 WL_BUFFER_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_buffer);
+}
+
+#ifndef WL_DATA_OFFER_ERROR_ENUM
+#define WL_DATA_OFFER_ERROR_ENUM
+enum wl_data_offer_error {
+	/**
+	 * finish request was called untimely
+	 */
+	WL_DATA_OFFER_ERROR_INVALID_FINISH = 0,
+	/**
+	 * action mask contains invalid values
+	 */
+	WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK = 1,
+	/**
+	 * action argument has an invalid value
+	 */
+	WL_DATA_OFFER_ERROR_INVALID_ACTION = 2,
+	/**
+	 * offer doesn't accept this request
+	 */
+	WL_DATA_OFFER_ERROR_INVALID_OFFER = 3,
+};
+#endif /* WL_DATA_OFFER_ERROR_ENUM */
+
+/**
+ * @ingroup iface_wl_data_offer
+ * @struct wl_data_offer_listener
+ */
+struct wl_data_offer_listener {
+	/**
+	 * advertise offered mime type
+	 *
+	 * Sent immediately after creating the wl_data_offer object. One
+	 * event per offered mime type.
+	 * @param mime_type offered mime type
+	 */
+	void (*offer)(void *data,
+		      struct wl_data_offer *wl_data_offer,
+		      const char *mime_type);
+	/**
+	 * notify the source-side available actions
+	 *
+	 * This event indicates the actions offered by the data source.
+	 * It will be sent right after wl_data_device.enter, or anytime the
+	 * source side changes its offered actions through
+	 * wl_data_source.set_actions.
+	 * @param source_actions actions offered by the data source
+	 * @since 3
+	 */
+	void (*source_actions)(void *data,
+			       struct wl_data_offer *wl_data_offer,
+			       uint32_t source_actions);
+	/**
+	 * notify the selected action
+	 *
+	 * This event indicates the action selected by the compositor
+	 * after matching the source/destination side actions. Only one
+	 * action (or none) will be offered here.
+	 *
+	 * This event can be emitted multiple times during the
+	 * drag-and-drop operation in response to destination side action
+	 * changes through wl_data_offer.set_actions.
+	 *
+	 * This event will no longer be emitted after wl_data_device.drop
+	 * happened on the drag-and-drop destination, the client must honor
+	 * the last action received, or the last preferred one set through
+	 * wl_data_offer.set_actions when handling an "ask" action.
+	 *
+	 * Compositors may also change the selected action on the fly,
+	 * mainly in response to keyboard modifier changes during the
+	 * drag-and-drop operation.
+	 *
+	 * The most recent action received is always the valid one. Prior
+	 * to receiving wl_data_device.drop, the chosen action may change
+	 * (e.g. due to keyboard modifiers being pressed). At the time of
+	 * receiving wl_data_device.drop the drag-and-drop destination must
+	 * honor the last action received.
+	 *
+	 * Action changes may still happen after wl_data_device.drop,
+	 * especially on "ask" actions, where the drag-and-drop destination
+	 * may choose another action afterwards. Action changes happening
+	 * at this stage are always the result of inter-client negotiation,
+	 * the compositor shall no longer be able to induce a different
+	 * action.
+	 *
+	 * Upon "ask" actions, it is expected that the drag-and-drop
+	 * destination may potentially choose a different action and/or
+	 * mime type, based on wl_data_offer.source_actions and finally
+	 * chosen by the user (e.g. popping up a menu with the available
+	 * options). The final wl_data_offer.set_actions and
+	 * wl_data_offer.accept requests must happen before the call to
+	 * wl_data_offer.finish.
+	 * @param dnd_action action selected by the compositor
+	 * @since 3
+	 */
+	void (*action)(void *data,
+		       struct wl_data_offer *wl_data_offer,
+		       uint32_t dnd_action);
+};
+
+/**
+ * @ingroup iface_wl_data_offer
+ */
+static inline int
+wl_data_offer_add_listener(struct wl_data_offer *wl_data_offer,
+			   const struct wl_data_offer_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_data_offer,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_DATA_OFFER_ACCEPT 0
+#define WL_DATA_OFFER_RECEIVE 1
+#define WL_DATA_OFFER_DESTROY 2
+#define WL_DATA_OFFER_FINISH 3
+#define WL_DATA_OFFER_SET_ACTIONS 4
+
+/**
+ * @ingroup iface_wl_data_offer
+ */
+#define WL_DATA_OFFER_OFFER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_offer
+ */
+#define WL_DATA_OFFER_SOURCE_ACTIONS_SINCE_VERSION 3
+/**
+ * @ingroup iface_wl_data_offer
+ */
+#define WL_DATA_OFFER_ACTION_SINCE_VERSION 3
+
+/**
+ * @ingroup iface_wl_data_offer
+ */
+#define WL_DATA_OFFER_ACCEPT_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_offer
+ */
+#define WL_DATA_OFFER_RECEIVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_offer
+ */
+#define WL_DATA_OFFER_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_offer
+ */
+#define WL_DATA_OFFER_FINISH_SINCE_VERSION 3
+/**
+ * @ingroup iface_wl_data_offer
+ */
+#define WL_DATA_OFFER_SET_ACTIONS_SINCE_VERSION 3
+
+/** @ingroup iface_wl_data_offer */
+static inline void
+wl_data_offer_set_user_data(struct wl_data_offer *wl_data_offer, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_data_offer, user_data);
+}
+
+/** @ingroup iface_wl_data_offer */
+static inline void *
+wl_data_offer_get_user_data(struct wl_data_offer *wl_data_offer)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_data_offer);
+}
+
+static inline uint32_t
+wl_data_offer_get_version(struct wl_data_offer *wl_data_offer)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_data_offer);
+}
+
+/**
+ * @ingroup iface_wl_data_offer
+ *
+ * Indicate that the client can accept the given mime type, or
+ * NULL for not accepted.
+ *
+ * For objects of version 2 or older, this request is used by the
+ * client to give feedback whether the client can receive the given
+ * mime type, or NULL if none is accepted; the feedback does not
+ * determine whether the drag-and-drop operation succeeds or not.
+ *
+ * For objects of version 3 or newer, this request determines the
+ * final result of the drag-and-drop operation. If the end result
+ * is that no mime types were accepted, the drag-and-drop operation
+ * will be cancelled and the corresponding drag source will receive
+ * wl_data_source.cancelled. Clients may still use this event in
+ * conjunction with wl_data_source.action for feedback.
+ */
+static inline void
+wl_data_offer_accept(struct wl_data_offer *wl_data_offer, uint32_t serial, const char *mime_type)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_offer,
+			 WL_DATA_OFFER_ACCEPT, serial, mime_type);
+}
+
+/**
+ * @ingroup iface_wl_data_offer
+ *
+ * To transfer the offered data, the client issues this request
+ * and indicates the mime type it wants to receive.  The transfer
+ * happens through the passed file descriptor (typically created
+ * with the pipe system call).  The source client writes the data
+ * in the mime type representation requested and then closes the
+ * file descriptor.
+ *
+ * The receiving client reads from the read end of the pipe until
+ * EOF and then closes its end, at which point the transfer is
+ * complete.
+ *
+ * This request may happen multiple times for different mime types,
+ * both before and after wl_data_device.drop. Drag-and-drop destination
+ * clients may preemptively fetch data or examine it more closely to
+ * determine acceptance.
+ */
+static inline void
+wl_data_offer_receive(struct wl_data_offer *wl_data_offer, const char *mime_type, int32_t fd)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_offer,
+			 WL_DATA_OFFER_RECEIVE, mime_type, fd);
+}
+
+/**
+ * @ingroup iface_wl_data_offer
+ *
+ * Destroy the data offer.
+ */
+static inline void
+wl_data_offer_destroy(struct wl_data_offer *wl_data_offer)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_offer,
+			 WL_DATA_OFFER_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_data_offer);
+}
+
+/**
+ * @ingroup iface_wl_data_offer
+ *
+ * Notifies the compositor that the drag destination successfully
+ * finished the drag-and-drop operation.
+ *
+ * Upon receiving this request, the compositor will emit
+ * wl_data_source.dnd_finished on the drag source client.
+ *
+ * It is a client error to perform other requests than
+ * wl_data_offer.destroy after this one. It is also an error to perform
+ * this request after a NULL mime type has been set in
+ * wl_data_offer.accept or no action was received through
+ * wl_data_offer.action.
+ */
+static inline void
+wl_data_offer_finish(struct wl_data_offer *wl_data_offer)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_offer,
+			 WL_DATA_OFFER_FINISH);
+}
+
+/**
+ * @ingroup iface_wl_data_offer
+ *
+ * Sets the actions that the destination side client supports for
+ * this operation. This request may trigger the emission of
+ * wl_data_source.action and wl_data_offer.action events if the compositor
+ * needs to change the selected action.
+ *
+ * This request can be called multiple times throughout the
+ * drag-and-drop operation, typically in response to wl_data_device.enter
+ * or wl_data_device.motion events.
+ *
+ * This request determines the final result of the drag-and-drop
+ * operation. If the end result is that no action is accepted,
+ * the drag source will receive wl_drag_source.cancelled.
+ *
+ * The dnd_actions argument must contain only values expressed in the
+ * wl_data_device_manager.dnd_actions enum, and the preferred_action
+ * argument must only contain one of those values set, otherwise it
+ * will result in a protocol error.
+ *
+ * While managing an "ask" action, the destination drag-and-drop client
+ * may perform further wl_data_offer.receive requests, and is expected
+ * to perform one last wl_data_offer.set_actions request with a preferred
+ * action other than "ask" (and optionally wl_data_offer.accept) before
+ * requesting wl_data_offer.finish, in order to convey the action selected
+ * by the user. If the preferred action is not in the
+ * wl_data_offer.source_actions mask, an error will be raised.
+ *
+ * If the "ask" action is dismissed (e.g. user cancellation), the client
+ * is expected to perform wl_data_offer.destroy right away.
+ *
+ * This request can only be made on drag-and-drop offers, a protocol error
+ * will be raised otherwise.
+ */
+static inline void
+wl_data_offer_set_actions(struct wl_data_offer *wl_data_offer, uint32_t dnd_actions, uint32_t preferred_action)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_offer,
+			 WL_DATA_OFFER_SET_ACTIONS, dnd_actions, preferred_action);
+}
+
+#ifndef WL_DATA_SOURCE_ERROR_ENUM
+#define WL_DATA_SOURCE_ERROR_ENUM
+enum wl_data_source_error {
+	/**
+	 * action mask contains invalid values
+	 */
+	WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK = 0,
+	/**
+	 * source doesn't accept this request
+	 */
+	WL_DATA_SOURCE_ERROR_INVALID_SOURCE = 1,
+};
+#endif /* WL_DATA_SOURCE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_wl_data_source
+ * @struct wl_data_source_listener
+ */
+struct wl_data_source_listener {
+	/**
+	 * a target accepts an offered mime type
+	 *
+	 * Sent when a target accepts pointer_focus or motion events. If
+	 * a target does not accept any of the offered types, type is NULL.
+	 *
+	 * Used for feedback during drag-and-drop.
+	 * @param mime_type mime type accepted by the target
+	 */
+	void (*target)(void *data,
+		       struct wl_data_source *wl_data_source,
+		       const char *mime_type);
+	/**
+	 * send the data
+	 *
+	 * Request for data from the client. Send the data as the
+	 * specified mime type over the passed file descriptor, then close
+	 * it.
+	 * @param mime_type mime type for the data
+	 * @param fd file descriptor for the data
+	 */
+	void (*send)(void *data,
+		     struct wl_data_source *wl_data_source,
+		     const char *mime_type,
+		     int32_t fd);
+	/**
+	 * selection was cancelled
+	 *
+	 * This data source is no longer valid. There are several reasons
+	 * why this could happen:
+	 *
+	 * - The data source has been replaced by another data source. -
+	 * The drag-and-drop operation was performed, but the drop
+	 * destination did not accept any of the mime types offered through
+	 * wl_data_source.target. - The drag-and-drop operation was
+	 * performed, but the drop destination did not select any of the
+	 * actions present in the mask offered through
+	 * wl_data_source.action. - The drag-and-drop operation was
+	 * performed but didn't happen over a surface. - The compositor
+	 * cancelled the drag-and-drop operation (e.g. compositor dependent
+	 * timeouts to avoid stale drag-and-drop transfers).
+	 *
+	 * The client should clean up and destroy this data source.
+	 *
+	 * For objects of version 2 or older, wl_data_source.cancelled will
+	 * only be emitted if the data source was replaced by another data
+	 * source.
+	 */
+	void (*cancelled)(void *data,
+			  struct wl_data_source *wl_data_source);
+	/**
+	 * the drag-and-drop operation physically finished
+	 *
+	 * The user performed the drop action. This event does not
+	 * indicate acceptance, wl_data_source.cancelled may still be
+	 * emitted afterwards if the drop destination does not accept any
+	 * mime type.
+	 *
+	 * However, this event might however not be received if the
+	 * compositor cancelled the drag-and-drop operation before this
+	 * event could happen.
+	 *
+	 * Note that the data_source may still be used in the future and
+	 * should not be destroyed here.
+	 * @since 3
+	 */
+	void (*dnd_drop_performed)(void *data,
+				   struct wl_data_source *wl_data_source);
+	/**
+	 * the drag-and-drop operation concluded
+	 *
+	 * The drop destination finished interoperating with this data
+	 * source, so the client is now free to destroy this data source
+	 * and free all associated data.
+	 *
+	 * If the action used to perform the operation was "move", the
+	 * source can now delete the transferred data.
+	 * @since 3
+	 */
+	void (*dnd_finished)(void *data,
+			     struct wl_data_source *wl_data_source);
+	/**
+	 * notify the selected action
+	 *
+	 * This event indicates the action selected by the compositor
+	 * after matching the source/destination side actions. Only one
+	 * action (or none) will be offered here.
+	 *
+	 * This event can be emitted multiple times during the
+	 * drag-and-drop operation, mainly in response to destination side
+	 * changes through wl_data_offer.set_actions, and as the data
+	 * device enters/leaves surfaces.
+	 *
+	 * It is only possible to receive this event after
+	 * wl_data_source.dnd_drop_performed if the drag-and-drop operation
+	 * ended in an "ask" action, in which case the final
+	 * wl_data_source.action event will happen immediately before
+	 * wl_data_source.dnd_finished.
+	 *
+	 * Compositors may also change the selected action on the fly,
+	 * mainly in response to keyboard modifier changes during the
+	 * drag-and-drop operation.
+	 *
+	 * The most recent action received is always the valid one. The
+	 * chosen action may change alongside negotiation (e.g. an "ask"
+	 * action can turn into a "move" operation), so the effects of the
+	 * final action must always be applied in
+	 * wl_data_offer.dnd_finished.
+	 *
+	 * Clients can trigger cursor surface changes from this point, so
+	 * they reflect the current action.
+	 * @param dnd_action action selected by the compositor
+	 * @since 3
+	 */
+	void (*action)(void *data,
+		       struct wl_data_source *wl_data_source,
+		       uint32_t dnd_action);
+};
+
+/**
+ * @ingroup iface_wl_data_source
+ */
+static inline int
+wl_data_source_add_listener(struct wl_data_source *wl_data_source,
+			    const struct wl_data_source_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_data_source,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_DATA_SOURCE_OFFER 0
+#define WL_DATA_SOURCE_DESTROY 1
+#define WL_DATA_SOURCE_SET_ACTIONS 2
+
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_TARGET_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_SEND_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_CANCELLED_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_DND_DROP_PERFORMED_SINCE_VERSION 3
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_DND_FINISHED_SINCE_VERSION 3
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_ACTION_SINCE_VERSION 3
+
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_OFFER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_source
+ */
+#define WL_DATA_SOURCE_SET_ACTIONS_SINCE_VERSION 3
+
+/** @ingroup iface_wl_data_source */
+static inline void
+wl_data_source_set_user_data(struct wl_data_source *wl_data_source, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_data_source, user_data);
+}
+
+/** @ingroup iface_wl_data_source */
+static inline void *
+wl_data_source_get_user_data(struct wl_data_source *wl_data_source)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_data_source);
+}
+
+static inline uint32_t
+wl_data_source_get_version(struct wl_data_source *wl_data_source)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_data_source);
+}
+
+/**
+ * @ingroup iface_wl_data_source
+ *
+ * This request adds a mime type to the set of mime types
+ * advertised to targets.  Can be called several times to offer
+ * multiple types.
+ */
+static inline void
+wl_data_source_offer(struct wl_data_source *wl_data_source, const char *mime_type)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_source,
+			 WL_DATA_SOURCE_OFFER, mime_type);
+}
+
+/**
+ * @ingroup iface_wl_data_source
+ *
+ * Destroy the data source.
+ */
+static inline void
+wl_data_source_destroy(struct wl_data_source *wl_data_source)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_source,
+			 WL_DATA_SOURCE_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_data_source);
+}
+
+/**
+ * @ingroup iface_wl_data_source
+ *
+ * Sets the actions that the source side client supports for this
+ * operation. This request may trigger wl_data_source.action and
+ * wl_data_offer.action events if the compositor needs to change the
+ * selected action.
+ *
+ * The dnd_actions argument must contain only values expressed in the
+ * wl_data_device_manager.dnd_actions enum, otherwise it will result
+ * in a protocol error.
+ *
+ * This request must be made once only, and can only be made on sources
+ * used in drag-and-drop, so it must be performed before
+ * wl_data_device.start_drag. Attempting to use the source other than
+ * for drag-and-drop will raise a protocol error.
+ */
+static inline void
+wl_data_source_set_actions(struct wl_data_source *wl_data_source, uint32_t dnd_actions)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_source,
+			 WL_DATA_SOURCE_SET_ACTIONS, dnd_actions);
+}
+
+#ifndef WL_DATA_DEVICE_ERROR_ENUM
+#define WL_DATA_DEVICE_ERROR_ENUM
+enum wl_data_device_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	WL_DATA_DEVICE_ERROR_ROLE = 0,
+};
+#endif /* WL_DATA_DEVICE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_wl_data_device
+ * @struct wl_data_device_listener
+ */
+struct wl_data_device_listener {
+	/**
+	 * introduce a new wl_data_offer
+	 *
+	 * The data_offer event introduces a new wl_data_offer object,
+	 * which will subsequently be used in either the data_device.enter
+	 * event (for drag-and-drop) or the data_device.selection event
+	 * (for selections). Immediately following the
+	 * data_device_data_offer event, the new data_offer object will
+	 * send out data_offer.offer events to describe the mime types it
+	 * offers.
+	 * @param id the new data_offer object
+	 */
+	void (*data_offer)(void *data,
+			   struct wl_data_device *wl_data_device,
+			   struct wl_data_offer *id);
+	/**
+	 * initiate drag-and-drop session
+	 *
+	 * This event is sent when an active drag-and-drop pointer enters
+	 * a surface owned by the client. The position of the pointer at
+	 * enter time is provided by the x and y arguments, in
+	 * surface-local coordinates.
+	 * @param serial serial number of the enter event
+	 * @param surface client surface entered
+	 * @param x surface-local x coordinate
+	 * @param y surface-local y coordinate
+	 * @param id source data_offer object
+	 */
+	void (*enter)(void *data,
+		      struct wl_data_device *wl_data_device,
+		      uint32_t serial,
+		      struct wl_surface *surface,
+		      wl_fixed_t x,
+		      wl_fixed_t y,
+		      struct wl_data_offer *id);
+	/**
+	 * end drag-and-drop session
+	 *
+	 * This event is sent when the drag-and-drop pointer leaves the
+	 * surface and the session ends. The client must destroy the
+	 * wl_data_offer introduced at enter time at this point.
+	 */
+	void (*leave)(void *data,
+		      struct wl_data_device *wl_data_device);
+	/**
+	 * drag-and-drop session motion
+	 *
+	 * This event is sent when the drag-and-drop pointer moves within
+	 * the currently focused surface. The new position of the pointer
+	 * is provided by the x and y arguments, in surface-local
+	 * coordinates.
+	 * @param time timestamp with millisecond granularity
+	 * @param x surface-local x coordinate
+	 * @param y surface-local y coordinate
+	 */
+	void (*motion)(void *data,
+		       struct wl_data_device *wl_data_device,
+		       uint32_t time,
+		       wl_fixed_t x,
+		       wl_fixed_t y);
+	/**
+	 * end drag-and-drop session successfully
+	 *
+	 * The event is sent when a drag-and-drop operation is ended
+	 * because the implicit grab is removed.
+	 *
+	 * The drag-and-drop destination is expected to honor the last
+	 * action received through wl_data_offer.action, if the resulting
+	 * action is "copy" or "move", the destination can still perform
+	 * wl_data_offer.receive requests, and is expected to end all
+	 * transfers with a wl_data_offer.finish request.
+	 *
+	 * If the resulting action is "ask", the action will not be
+	 * considered final. The drag-and-drop destination is expected to
+	 * perform one last wl_data_offer.set_actions request, or
+	 * wl_data_offer.destroy in order to cancel the operation.
+	 */
+	void (*drop)(void *data,
+		     struct wl_data_device *wl_data_device);
+	/**
+	 * advertise new selection
+	 *
+	 * The selection event is sent out to notify the client of a new
+	 * wl_data_offer for the selection for this device. The
+	 * data_device.data_offer and the data_offer.offer events are sent
+	 * out immediately before this event to introduce the data offer
+	 * object. The selection event is sent to a client immediately
+	 * before receiving keyboard focus and when a new selection is set
+	 * while the client has keyboard focus. The data_offer is valid
+	 * until a new data_offer or NULL is received or until the client
+	 * loses keyboard focus. The client must destroy the previous
+	 * selection data_offer, if any, upon receiving this event.
+	 * @param id selection data_offer object
+	 */
+	void (*selection)(void *data,
+			  struct wl_data_device *wl_data_device,
+			  struct wl_data_offer *id);
+};
+
+/**
+ * @ingroup iface_wl_data_device
+ */
+static inline int
+wl_data_device_add_listener(struct wl_data_device *wl_data_device,
+			    const struct wl_data_device_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_data_device,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_DATA_DEVICE_START_DRAG 0
+#define WL_DATA_DEVICE_SET_SELECTION 1
+#define WL_DATA_DEVICE_RELEASE 2
+
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_DATA_OFFER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_ENTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_LEAVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_MOTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_DROP_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_SELECTION_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_START_DRAG_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_SET_SELECTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_device
+ */
+#define WL_DATA_DEVICE_RELEASE_SINCE_VERSION 2
+
+/** @ingroup iface_wl_data_device */
+static inline void
+wl_data_device_set_user_data(struct wl_data_device *wl_data_device, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_data_device, user_data);
+}
+
+/** @ingroup iface_wl_data_device */
+static inline void *
+wl_data_device_get_user_data(struct wl_data_device *wl_data_device)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_data_device);
+}
+
+static inline uint32_t
+wl_data_device_get_version(struct wl_data_device *wl_data_device)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_data_device);
+}
+
+/** @ingroup iface_wl_data_device */
+static inline void
+wl_data_device_destroy(struct wl_data_device *wl_data_device)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_data_device);
+}
+
+/**
+ * @ingroup iface_wl_data_device
+ *
+ * This request asks the compositor to start a drag-and-drop
+ * operation on behalf of the client.
+ *
+ * The source argument is the data source that provides the data
+ * for the eventual data transfer. If source is NULL, enter, leave
+ * and motion events are sent only to the client that initiated the
+ * drag and the client is expected to handle the data passing
+ * internally.
+ *
+ * The origin surface is the surface where the drag originates and
+ * the client must have an active implicit grab that matches the
+ * serial.
+ *
+ * The icon surface is an optional (can be NULL) surface that
+ * provides an icon to be moved around with the cursor.  Initially,
+ * the top-left corner of the icon surface is placed at the cursor
+ * hotspot, but subsequent wl_surface.attach request can move the
+ * relative position. Attach requests must be confirmed with
+ * wl_surface.commit as usual. The icon surface is given the role of
+ * a drag-and-drop icon. If the icon surface already has another role,
+ * it raises a protocol error.
+ *
+ * The current and pending input regions of the icon wl_surface are
+ * cleared, and wl_surface.set_input_region is ignored until the
+ * wl_surface is no longer used as the icon surface. When the use
+ * as an icon ends, the current and pending input regions become
+ * undefined, and the wl_surface is unmapped.
+ */
+static inline void
+wl_data_device_start_drag(struct wl_data_device *wl_data_device, struct wl_data_source *source, struct wl_surface *origin, struct wl_surface *icon, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_device,
+			 WL_DATA_DEVICE_START_DRAG, source, origin, icon, serial);
+}
+
+/**
+ * @ingroup iface_wl_data_device
+ *
+ * This request asks the compositor to set the selection
+ * to the data from the source on behalf of the client.
+ *
+ * To unset the selection, set the source to NULL.
+ */
+static inline void
+wl_data_device_set_selection(struct wl_data_device *wl_data_device, struct wl_data_source *source, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_device,
+			 WL_DATA_DEVICE_SET_SELECTION, source, serial);
+}
+
+/**
+ * @ingroup iface_wl_data_device
+ *
+ * This request destroys the data device.
+ */
+static inline void
+wl_data_device_release(struct wl_data_device *wl_data_device)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_data_device,
+			 WL_DATA_DEVICE_RELEASE);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_data_device);
+}
+
+#ifndef WL_DATA_DEVICE_MANAGER_DND_ACTION_ENUM
+#define WL_DATA_DEVICE_MANAGER_DND_ACTION_ENUM
+/**
+ * @ingroup iface_wl_data_device_manager
+ * drag and drop actions
+ *
+ * This is a bitmask of the available/preferred actions in a
+ * drag-and-drop operation.
+ *
+ * In the compositor, the selected action is a result of matching the
+ * actions offered by the source and destination sides.  "action" events
+ * with a "none" action will be sent to both source and destination if
+ * there is no match. All further checks will effectively happen on
+ * (source actions ∩ destination actions).
+ *
+ * In addition, compositors may also pick different actions in
+ * reaction to key modifiers being pressed. One common design that
+ * is used in major toolkits (and the behavior recommended for
+ * compositors) is:
+ *
+ * - If no modifiers are pressed, the first match (in bit order)
+ * will be used.
+ * - Pressing Shift selects "move", if enabled in the mask.
+ * - Pressing Control selects "copy", if enabled in the mask.
+ *
+ * Behavior beyond that is considered implementation-dependent.
+ * Compositors may for example bind other modifiers (like Alt/Meta)
+ * or drags initiated with other buttons than BTN_LEFT to specific
+ * actions (e.g. "ask").
+ */
+enum wl_data_device_manager_dnd_action {
+	/**
+	 * no action
+	 */
+	WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE = 0,
+	/**
+	 * copy action
+	 */
+	WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY = 1,
+	/**
+	 * move action
+	 */
+	WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE = 2,
+	/**
+	 * ask action
+	 */
+	WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK = 4,
+};
+#endif /* WL_DATA_DEVICE_MANAGER_DND_ACTION_ENUM */
+
+#define WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE 0
+#define WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE 1
+
+
+/**
+ * @ingroup iface_wl_data_device_manager
+ */
+#define WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_data_device_manager
+ */
+#define WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE_SINCE_VERSION 1
+
+/** @ingroup iface_wl_data_device_manager */
+static inline void
+wl_data_device_manager_set_user_data(struct wl_data_device_manager *wl_data_device_manager, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_data_device_manager, user_data);
+}
+
+/** @ingroup iface_wl_data_device_manager */
+static inline void *
+wl_data_device_manager_get_user_data(struct wl_data_device_manager *wl_data_device_manager)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_data_device_manager);
+}
+
+static inline uint32_t
+wl_data_device_manager_get_version(struct wl_data_device_manager *wl_data_device_manager)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_data_device_manager);
+}
+
+/** @ingroup iface_wl_data_device_manager */
+static inline void
+wl_data_device_manager_destroy(struct wl_data_device_manager *wl_data_device_manager)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_data_device_manager);
+}
+
+/**
+ * @ingroup iface_wl_data_device_manager
+ *
+ * Create a new data source.
+ */
+static inline struct wl_data_source *
+wl_data_device_manager_create_data_source(struct wl_data_device_manager *wl_data_device_manager)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_data_device_manager,
+			 WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE, &wl_data_source_interface, NULL);
+
+	return (struct wl_data_source *) id;
+}
+
+/**
+ * @ingroup iface_wl_data_device_manager
+ *
+ * Create a new data device for a given seat.
+ */
+static inline struct wl_data_device *
+wl_data_device_manager_get_data_device(struct wl_data_device_manager *wl_data_device_manager, struct wl_seat *seat)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_data_device_manager,
+			 WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE, &wl_data_device_interface, NULL, seat);
+
+	return (struct wl_data_device *) id;
+}
+
+#ifndef WL_SHELL_ERROR_ENUM
+#define WL_SHELL_ERROR_ENUM
+enum wl_shell_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	WL_SHELL_ERROR_ROLE = 0,
+};
+#endif /* WL_SHELL_ERROR_ENUM */
+
+#define WL_SHELL_GET_SHELL_SURFACE 0
+
+
+/**
+ * @ingroup iface_wl_shell
+ */
+#define WL_SHELL_GET_SHELL_SURFACE_SINCE_VERSION 1
+
+/** @ingroup iface_wl_shell */
+static inline void
+wl_shell_set_user_data(struct wl_shell *wl_shell, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_shell, user_data);
+}
+
+/** @ingroup iface_wl_shell */
+static inline void *
+wl_shell_get_user_data(struct wl_shell *wl_shell)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_shell);
+}
+
+static inline uint32_t
+wl_shell_get_version(struct wl_shell *wl_shell)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_shell);
+}
+
+/** @ingroup iface_wl_shell */
+static inline void
+wl_shell_destroy(struct wl_shell *wl_shell)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_shell);
+}
+
+/**
+ * @ingroup iface_wl_shell
+ *
+ * Create a shell surface for an existing surface. This gives
+ * the wl_surface the role of a shell surface. If the wl_surface
+ * already has another role, it raises a protocol error.
+ *
+ * Only one shell surface can be associated with a given surface.
+ */
+static inline struct wl_shell_surface *
+wl_shell_get_shell_surface(struct wl_shell *wl_shell, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_shell,
+			 WL_SHELL_GET_SHELL_SURFACE, &wl_shell_surface_interface, NULL, surface);
+
+	return (struct wl_shell_surface *) id;
+}
+
+#ifndef WL_SHELL_SURFACE_RESIZE_ENUM
+#define WL_SHELL_SURFACE_RESIZE_ENUM
+/**
+ * @ingroup iface_wl_shell_surface
+ * edge values for resizing
+ *
+ * These values are used to indicate which edge of a surface
+ * is being dragged in a resize operation. The server may
+ * use this information to adapt its behavior, e.g. choose
+ * an appropriate cursor image.
+ */
+enum wl_shell_surface_resize {
+	/**
+	 * no edge
+	 */
+	WL_SHELL_SURFACE_RESIZE_NONE = 0,
+	/**
+	 * top edge
+	 */
+	WL_SHELL_SURFACE_RESIZE_TOP = 1,
+	/**
+	 * bottom edge
+	 */
+	WL_SHELL_SURFACE_RESIZE_BOTTOM = 2,
+	/**
+	 * left edge
+	 */
+	WL_SHELL_SURFACE_RESIZE_LEFT = 4,
+	/**
+	 * top and left edges
+	 */
+	WL_SHELL_SURFACE_RESIZE_TOP_LEFT = 5,
+	/**
+	 * bottom and left edges
+	 */
+	WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT = 6,
+	/**
+	 * right edge
+	 */
+	WL_SHELL_SURFACE_RESIZE_RIGHT = 8,
+	/**
+	 * top and right edges
+	 */
+	WL_SHELL_SURFACE_RESIZE_TOP_RIGHT = 9,
+	/**
+	 * bottom and right edges
+	 */
+	WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT = 10,
+};
+#endif /* WL_SHELL_SURFACE_RESIZE_ENUM */
+
+#ifndef WL_SHELL_SURFACE_TRANSIENT_ENUM
+#define WL_SHELL_SURFACE_TRANSIENT_ENUM
+/**
+ * @ingroup iface_wl_shell_surface
+ * details of transient behaviour
+ *
+ * These flags specify details of the expected behaviour
+ * of transient surfaces. Used in the set_transient request.
+ */
+enum wl_shell_surface_transient {
+	/**
+	 * do not set keyboard focus
+	 */
+	WL_SHELL_SURFACE_TRANSIENT_INACTIVE = 0x1,
+};
+#endif /* WL_SHELL_SURFACE_TRANSIENT_ENUM */
+
+#ifndef WL_SHELL_SURFACE_FULLSCREEN_METHOD_ENUM
+#define WL_SHELL_SURFACE_FULLSCREEN_METHOD_ENUM
+/**
+ * @ingroup iface_wl_shell_surface
+ * different method to set the surface fullscreen
+ *
+ * Hints to indicate to the compositor how to deal with a conflict
+ * between the dimensions of the surface and the dimensions of the
+ * output. The compositor is free to ignore this parameter.
+ */
+enum wl_shell_surface_fullscreen_method {
+	/**
+	 * no preference, apply default policy
+	 */
+	WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT = 0,
+	/**
+	 * scale, preserve the surface's aspect ratio and center on output
+	 */
+	WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE = 1,
+	/**
+	 * switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
+	 */
+	WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER = 2,
+	/**
+	 * no upscaling, center on output and add black borders to compensate size mismatch
+	 */
+	WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL = 3,
+};
+#endif /* WL_SHELL_SURFACE_FULLSCREEN_METHOD_ENUM */
+
+/**
+ * @ingroup iface_wl_shell_surface
+ * @struct wl_shell_surface_listener
+ */
+struct wl_shell_surface_listener {
+	/**
+	 * ping client
+	 *
+	 * Ping a client to check if it is receiving events and sending
+	 * requests. A client is expected to reply with a pong request.
+	 * @param serial serial number of the ping
+	 */
+	void (*ping)(void *data,
+		     struct wl_shell_surface *wl_shell_surface,
+		     uint32_t serial);
+	/**
+	 * suggest resize
+	 *
+	 * The configure event asks the client to resize its surface.
+	 *
+	 * The size is a hint, in the sense that the client is free to
+	 * ignore it if it doesn't resize, pick a smaller size (to satisfy
+	 * aspect ratio or resize in steps of NxM pixels).
+	 *
+	 * The edges parameter provides a hint about how the surface was
+	 * resized. The client may use this information to decide how to
+	 * adjust its content to the new size (e.g. a scrolling area might
+	 * adjust its content position to leave the viewable content
+	 * unmoved).
+	 *
+	 * The client is free to dismiss all but the last configure event
+	 * it received.
+	 *
+	 * The width and height arguments specify the size of the window in
+	 * surface-local coordinates.
+	 * @param edges how the surface was resized
+	 * @param width new width of the surface
+	 * @param height new height of the surface
+	 */
+	void (*configure)(void *data,
+			  struct wl_shell_surface *wl_shell_surface,
+			  uint32_t edges,
+			  int32_t width,
+			  int32_t height);
+	/**
+	 * popup interaction is done
+	 *
+	 * The popup_done event is sent out when a popup grab is broken,
+	 * that is, when the user clicks a surface that doesn't belong to
+	 * the client owning the popup surface.
+	 */
+	void (*popup_done)(void *data,
+			   struct wl_shell_surface *wl_shell_surface);
+};
+
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+static inline int
+wl_shell_surface_add_listener(struct wl_shell_surface *wl_shell_surface,
+			      const struct wl_shell_surface_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_shell_surface,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_SHELL_SURFACE_PONG 0
+#define WL_SHELL_SURFACE_MOVE 1
+#define WL_SHELL_SURFACE_RESIZE 2
+#define WL_SHELL_SURFACE_SET_TOPLEVEL 3
+#define WL_SHELL_SURFACE_SET_TRANSIENT 4
+#define WL_SHELL_SURFACE_SET_FULLSCREEN 5
+#define WL_SHELL_SURFACE_SET_POPUP 6
+#define WL_SHELL_SURFACE_SET_MAXIMIZED 7
+#define WL_SHELL_SURFACE_SET_TITLE 8
+#define WL_SHELL_SURFACE_SET_CLASS 9
+
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_PING_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_POPUP_DONE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_PONG_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_MOVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_RESIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_SET_TOPLEVEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_SET_TRANSIENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_SET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_SET_POPUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_SET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_SET_TITLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_shell_surface
+ */
+#define WL_SHELL_SURFACE_SET_CLASS_SINCE_VERSION 1
+
+/** @ingroup iface_wl_shell_surface */
+static inline void
+wl_shell_surface_set_user_data(struct wl_shell_surface *wl_shell_surface, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_shell_surface, user_data);
+}
+
+/** @ingroup iface_wl_shell_surface */
+static inline void *
+wl_shell_surface_get_user_data(struct wl_shell_surface *wl_shell_surface)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_shell_surface);
+}
+
+static inline uint32_t
+wl_shell_surface_get_version(struct wl_shell_surface *wl_shell_surface)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_shell_surface);
+}
+
+/** @ingroup iface_wl_shell_surface */
+static inline void
+wl_shell_surface_destroy(struct wl_shell_surface *wl_shell_surface)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_shell_surface);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * A client must respond to a ping event with a pong request or
+ * the client may be deemed unresponsive.
+ */
+static inline void
+wl_shell_surface_pong(struct wl_shell_surface *wl_shell_surface, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_PONG, serial);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Start a pointer-driven move of the surface.
+ *
+ * This request must be used in response to a button press event.
+ * The server may ignore move requests depending on the state of
+ * the surface (e.g. fullscreen or maximized).
+ */
+static inline void
+wl_shell_surface_move(struct wl_shell_surface *wl_shell_surface, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_MOVE, seat, serial);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Start a pointer-driven resizing of the surface.
+ *
+ * This request must be used in response to a button press event.
+ * The server may ignore resize requests depending on the state of
+ * the surface (e.g. fullscreen or maximized).
+ */
+static inline void
+wl_shell_surface_resize(struct wl_shell_surface *wl_shell_surface, struct wl_seat *seat, uint32_t serial, uint32_t edges)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_RESIZE, seat, serial, edges);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Map the surface as a toplevel surface.
+ *
+ * A toplevel surface is not fullscreen, maximized or transient.
+ */
+static inline void
+wl_shell_surface_set_toplevel(struct wl_shell_surface *wl_shell_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_SET_TOPLEVEL);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Map the surface relative to an existing surface.
+ *
+ * The x and y arguments specify the location of the upper left
+ * corner of the surface relative to the upper left corner of the
+ * parent surface, in surface-local coordinates.
+ *
+ * The flags argument controls details of the transient behaviour.
+ */
+static inline void
+wl_shell_surface_set_transient(struct wl_shell_surface *wl_shell_surface, struct wl_surface *parent, int32_t x, int32_t y, uint32_t flags)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_SET_TRANSIENT, parent, x, y, flags);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Map the surface as a fullscreen surface.
+ *
+ * If an output parameter is given then the surface will be made
+ * fullscreen on that output. If the client does not specify the
+ * output then the compositor will apply its policy - usually
+ * choosing the output on which the surface has the biggest surface
+ * area.
+ *
+ * The client may specify a method to resolve a size conflict
+ * between the output size and the surface size - this is provided
+ * through the method parameter.
+ *
+ * The framerate parameter is used only when the method is set
+ * to "driver", to indicate the preferred framerate. A value of 0
+ * indicates that the client does not care about framerate.  The
+ * framerate is specified in mHz, that is framerate of 60000 is 60Hz.
+ *
+ * A method of "scale" or "driver" implies a scaling operation of
+ * the surface, either via a direct scaling operation or a change of
+ * the output mode. This will override any kind of output scaling, so
+ * that mapping a surface with a buffer size equal to the mode can
+ * fill the screen independent of buffer_scale.
+ *
+ * A method of "fill" means we don't scale up the buffer, however
+ * any output scale is applied. This means that you may run into
+ * an edge case where the application maps a buffer with the same
+ * size of the output mode but buffer_scale 1 (thus making a
+ * surface larger than the output). In this case it is allowed to
+ * downscale the results to fit the screen.
+ *
+ * The compositor must reply to this request with a configure event
+ * with the dimensions for the output on which the surface will
+ * be made fullscreen.
+ */
+static inline void
+wl_shell_surface_set_fullscreen(struct wl_shell_surface *wl_shell_surface, uint32_t method, uint32_t framerate, struct wl_output *output)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_SET_FULLSCREEN, method, framerate, output);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Map the surface as a popup.
+ *
+ * A popup surface is a transient surface with an added pointer
+ * grab.
+ *
+ * An existing implicit grab will be changed to owner-events mode,
+ * and the popup grab will continue after the implicit grab ends
+ * (i.e. releasing the mouse button does not cause the popup to
+ * be unmapped).
+ *
+ * The popup grab continues until the window is destroyed or a
+ * mouse button is pressed in any other client's window. A click
+ * in any of the client's surfaces is reported as normal, however,
+ * clicks in other clients' surfaces will be discarded and trigger
+ * the callback.
+ *
+ * The x and y arguments specify the location of the upper left
+ * corner of the surface relative to the upper left corner of the
+ * parent surface, in surface-local coordinates.
+ */
+static inline void
+wl_shell_surface_set_popup(struct wl_shell_surface *wl_shell_surface, struct wl_seat *seat, uint32_t serial, struct wl_surface *parent, int32_t x, int32_t y, uint32_t flags)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_SET_POPUP, seat, serial, parent, x, y, flags);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Map the surface as a maximized surface.
+ *
+ * If an output parameter is given then the surface will be
+ * maximized on that output. If the client does not specify the
+ * output then the compositor will apply its policy - usually
+ * choosing the output on which the surface has the biggest surface
+ * area.
+ *
+ * The compositor will reply with a configure event telling
+ * the expected new surface size. The operation is completed
+ * on the next buffer attach to this surface.
+ *
+ * A maximized surface typically fills the entire output it is
+ * bound to, except for desktop elements such as panels. This is
+ * the main difference between a maximized shell surface and a
+ * fullscreen shell surface.
+ *
+ * The details depend on the compositor implementation.
+ */
+static inline void
+wl_shell_surface_set_maximized(struct wl_shell_surface *wl_shell_surface, struct wl_output *output)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_SET_MAXIMIZED, output);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Set a short title for the surface.
+ *
+ * This string may be used to identify the surface in a task bar,
+ * window list, or other user interface elements provided by the
+ * compositor.
+ *
+ * The string must be encoded in UTF-8.
+ */
+static inline void
+wl_shell_surface_set_title(struct wl_shell_surface *wl_shell_surface, const char *title)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_SET_TITLE, title);
+}
+
+/**
+ * @ingroup iface_wl_shell_surface
+ *
+ * Set a class for the surface.
+ *
+ * The surface class identifies the general class of applications
+ * to which the surface belongs. A common convention is to use the
+ * file name (or the full path if it is a non-standard location) of
+ * the application's .desktop file as the class.
+ */
+static inline void
+wl_shell_surface_set_class(struct wl_shell_surface *wl_shell_surface, const char *class_)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_shell_surface,
+			 WL_SHELL_SURFACE_SET_CLASS, class_);
+}
+
+#ifndef WL_SURFACE_ERROR_ENUM
+#define WL_SURFACE_ERROR_ENUM
+/**
+ * @ingroup iface_wl_surface
+ * wl_surface error values
+ *
+ * These errors can be emitted in response to wl_surface requests.
+ */
+enum wl_surface_error {
+	/**
+	 * buffer scale value is invalid
+	 */
+	WL_SURFACE_ERROR_INVALID_SCALE = 0,
+	/**
+	 * buffer transform value is invalid
+	 */
+	WL_SURFACE_ERROR_INVALID_TRANSFORM = 1,
+};
+#endif /* WL_SURFACE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_wl_surface
+ * @struct wl_surface_listener
+ */
+struct wl_surface_listener {
+	/**
+	 * surface enters an output
+	 *
+	 * This is emitted whenever a surface's creation, movement, or
+	 * resizing results in some part of it being within the scanout
+	 * region of an output.
+	 *
+	 * Note that a surface may be overlapping with zero or more
+	 * outputs.
+	 * @param output output entered by the surface
+	 */
+	void (*enter)(void *data,
+		      struct wl_surface *wl_surface,
+		      struct wl_output *output);
+	/**
+	 * surface leaves an output
+	 *
+	 * This is emitted whenever a surface's creation, movement, or
+	 * resizing results in it no longer having any part of it within
+	 * the scanout region of an output.
+	 * @param output output left by the surface
+	 */
+	void (*leave)(void *data,
+		      struct wl_surface *wl_surface,
+		      struct wl_output *output);
+};
+
+/**
+ * @ingroup iface_wl_surface
+ */
+static inline int
+wl_surface_add_listener(struct wl_surface *wl_surface,
+			const struct wl_surface_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_surface,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_SURFACE_DESTROY 0
+#define WL_SURFACE_ATTACH 1
+#define WL_SURFACE_DAMAGE 2
+#define WL_SURFACE_FRAME 3
+#define WL_SURFACE_SET_OPAQUE_REGION 4
+#define WL_SURFACE_SET_INPUT_REGION 5
+#define WL_SURFACE_COMMIT 6
+#define WL_SURFACE_SET_BUFFER_TRANSFORM 7
+#define WL_SURFACE_SET_BUFFER_SCALE 8
+#define WL_SURFACE_DAMAGE_BUFFER 9
+
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_ENTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_LEAVE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_ATTACH_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_DAMAGE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_FRAME_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_SET_OPAQUE_REGION_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_SET_INPUT_REGION_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_COMMIT_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_SET_BUFFER_TRANSFORM_SINCE_VERSION 2
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_SET_BUFFER_SCALE_SINCE_VERSION 3
+/**
+ * @ingroup iface_wl_surface
+ */
+#define WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION 4
+
+/** @ingroup iface_wl_surface */
+static inline void
+wl_surface_set_user_data(struct wl_surface *wl_surface, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_surface, user_data);
+}
+
+/** @ingroup iface_wl_surface */
+static inline void *
+wl_surface_get_user_data(struct wl_surface *wl_surface)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_surface);
+}
+
+static inline uint32_t
+wl_surface_get_version(struct wl_surface *wl_surface)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_surface);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * Deletes the surface and invalidates its object ID.
+ */
+static inline void
+wl_surface_destroy(struct wl_surface *wl_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_surface);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * Set a buffer as the content of this surface.
+ *
+ * The new size of the surface is calculated based on the buffer
+ * size transformed by the inverse buffer_transform and the
+ * inverse buffer_scale. This means that the supplied buffer
+ * must be an integer multiple of the buffer_scale.
+ *
+ * The x and y arguments specify the location of the new pending
+ * buffer's upper left corner, relative to the current buffer's upper
+ * left corner, in surface-local coordinates. In other words, the
+ * x and y, combined with the new surface size define in which
+ * directions the surface's size changes.
+ *
+ * Surface contents are double-buffered state, see wl_surface.commit.
+ *
+ * The initial surface contents are void; there is no content.
+ * wl_surface.attach assigns the given wl_buffer as the pending
+ * wl_buffer. wl_surface.commit makes the pending wl_buffer the new
+ * surface contents, and the size of the surface becomes the size
+ * calculated from the wl_buffer, as described above. After commit,
+ * there is no pending buffer until the next attach.
+ *
+ * Committing a pending wl_buffer allows the compositor to read the
+ * pixels in the wl_buffer. The compositor may access the pixels at
+ * any time after the wl_surface.commit request. When the compositor
+ * will not access the pixels anymore, it will send the
+ * wl_buffer.release event. Only after receiving wl_buffer.release,
+ * the client may reuse the wl_buffer. A wl_buffer that has been
+ * attached and then replaced by another attach instead of committed
+ * will not receive a release event, and is not used by the
+ * compositor.
+ *
+ * Destroying the wl_buffer after wl_buffer.release does not change
+ * the surface contents. However, if the client destroys the
+ * wl_buffer before receiving the wl_buffer.release event, the surface
+ * contents become undefined immediately.
+ *
+ * If wl_surface.attach is sent with a NULL wl_buffer, the
+ * following wl_surface.commit will remove the surface content.
+ */
+static inline void
+wl_surface_attach(struct wl_surface *wl_surface, struct wl_buffer *buffer, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_ATTACH, buffer, x, y);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * This request is used to describe the regions where the pending
+ * buffer is different from the current surface contents, and where
+ * the surface therefore needs to be repainted. The compositor
+ * ignores the parts of the damage that fall outside of the surface.
+ *
+ * Damage is double-buffered state, see wl_surface.commit.
+ *
+ * The damage rectangle is specified in surface-local coordinates,
+ * where x and y specify the upper left corner of the damage rectangle.
+ *
+ * The initial value for pending damage is empty: no damage.
+ * wl_surface.damage adds pending damage: the new pending damage
+ * is the union of old pending damage and the given rectangle.
+ *
+ * wl_surface.commit assigns pending damage as the current damage,
+ * and clears pending damage. The server will clear the current
+ * damage as it repaints the surface.
+ *
+ * Alternatively, damage can be posted with wl_surface.damage_buffer
+ * which uses buffer coordinates instead of surface coordinates,
+ * and is probably the preferred and intuitive way of doing this.
+ */
+static inline void
+wl_surface_damage(struct wl_surface *wl_surface, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_DAMAGE, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * Request a notification when it is a good time to start drawing a new
+ * frame, by creating a frame callback. This is useful for throttling
+ * redrawing operations, and driving animations.
+ *
+ * When a client is animating on a wl_surface, it can use the 'frame'
+ * request to get notified when it is a good time to draw and commit the
+ * next frame of animation. If the client commits an update earlier than
+ * that, it is likely that some updates will not make it to the display,
+ * and the client is wasting resources by drawing too often.
+ *
+ * The frame request will take effect on the next wl_surface.commit.
+ * The notification will only be posted for one frame unless
+ * requested again. For a wl_surface, the notifications are posted in
+ * the order the frame requests were committed.
+ *
+ * The server must send the notifications so that a client
+ * will not send excessive updates, while still allowing
+ * the highest possible update rate for clients that wait for the reply
+ * before drawing again. The server should give some time for the client
+ * to draw and commit after sending the frame callback events to let it
+ * hit the next output refresh.
+ *
+ * A server should avoid signaling the frame callbacks if the
+ * surface is not visible in any way, e.g. the surface is off-screen,
+ * or completely obscured by other opaque surfaces.
+ *
+ * The object returned by this request will be destroyed by the
+ * compositor after the callback is fired and as such the client must not
+ * attempt to use it after that point.
+ *
+ * The callback_data passed in the callback is the current time, in
+ * milliseconds, with an undefined base.
+ */
+static inline struct wl_callback *
+wl_surface_frame(struct wl_surface *wl_surface)
+{
+	struct wl_proxy *callback;
+
+	callback = wl_proxy_marshal_constructor((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_FRAME, &wl_callback_interface, NULL);
+
+	return (struct wl_callback *) callback;
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * This request sets the region of the surface that contains
+ * opaque content.
+ *
+ * The opaque region is an optimization hint for the compositor
+ * that lets it optimize the redrawing of content behind opaque
+ * regions.  Setting an opaque region is not required for correct
+ * behaviour, but marking transparent content as opaque will result
+ * in repaint artifacts.
+ *
+ * The opaque region is specified in surface-local coordinates.
+ *
+ * The compositor ignores the parts of the opaque region that fall
+ * outside of the surface.
+ *
+ * Opaque region is double-buffered state, see wl_surface.commit.
+ *
+ * wl_surface.set_opaque_region changes the pending opaque region.
+ * wl_surface.commit copies the pending region to the current region.
+ * Otherwise, the pending and current regions are never changed.
+ *
+ * The initial value for an opaque region is empty. Setting the pending
+ * opaque region has copy semantics, and the wl_region object can be
+ * destroyed immediately. A NULL wl_region causes the pending opaque
+ * region to be set to empty.
+ */
+static inline void
+wl_surface_set_opaque_region(struct wl_surface *wl_surface, struct wl_region *region)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_SET_OPAQUE_REGION, region);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * This request sets the region of the surface that can receive
+ * pointer and touch events.
+ *
+ * Input events happening outside of this region will try the next
+ * surface in the server surface stack. The compositor ignores the
+ * parts of the input region that fall outside of the surface.
+ *
+ * The input region is specified in surface-local coordinates.
+ *
+ * Input region is double-buffered state, see wl_surface.commit.
+ *
+ * wl_surface.set_input_region changes the pending input region.
+ * wl_surface.commit copies the pending region to the current region.
+ * Otherwise the pending and current regions are never changed,
+ * except cursor and icon surfaces are special cases, see
+ * wl_pointer.set_cursor and wl_data_device.start_drag.
+ *
+ * The initial value for an input region is infinite. That means the
+ * whole surface will accept input. Setting the pending input region
+ * has copy semantics, and the wl_region object can be destroyed
+ * immediately. A NULL wl_region causes the input region to be set
+ * to infinite.
+ */
+static inline void
+wl_surface_set_input_region(struct wl_surface *wl_surface, struct wl_region *region)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_SET_INPUT_REGION, region);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * Surface state (input, opaque, and damage regions, attached buffers,
+ * etc.) is double-buffered. Protocol requests modify the pending state,
+ * as opposed to the current state in use by the compositor. A commit
+ * request atomically applies all pending state, replacing the current
+ * state. After commit, the new pending state is as documented for each
+ * related request.
+ *
+ * On commit, a pending wl_buffer is applied first, and all other state
+ * second. This means that all coordinates in double-buffered state are
+ * relative to the new wl_buffer coming into use, except for
+ * wl_surface.attach itself. If there is no pending wl_buffer, the
+ * coordinates are relative to the current surface contents.
+ *
+ * All requests that need a commit to become effective are documented
+ * to affect double-buffered state.
+ *
+ * Other interfaces may add further double-buffered surface state.
+ */
+static inline void
+wl_surface_commit(struct wl_surface *wl_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_COMMIT);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * This request sets an optional transformation on how the compositor
+ * interprets the contents of the buffer attached to the surface. The
+ * accepted values for the transform parameter are the values for
+ * wl_output.transform.
+ *
+ * Buffer transform is double-buffered state, see wl_surface.commit.
+ *
+ * A newly created surface has its buffer transformation set to normal.
+ *
+ * wl_surface.set_buffer_transform changes the pending buffer
+ * transformation. wl_surface.commit copies the pending buffer
+ * transformation to the current one. Otherwise, the pending and current
+ * values are never changed.
+ *
+ * The purpose of this request is to allow clients to render content
+ * according to the output transform, thus permitting the compositor to
+ * use certain optimizations even if the display is rotated. Using
+ * hardware overlays and scanning out a client buffer for fullscreen
+ * surfaces are examples of such optimizations. Those optimizations are
+ * highly dependent on the compositor implementation, so the use of this
+ * request should be considered on a case-by-case basis.
+ *
+ * Note that if the transform value includes 90 or 270 degree rotation,
+ * the width of the buffer will become the surface height and the height
+ * of the buffer will become the surface width.
+ *
+ * If transform is not one of the values from the
+ * wl_output.transform enum the invalid_transform protocol error
+ * is raised.
+ */
+static inline void
+wl_surface_set_buffer_transform(struct wl_surface *wl_surface, int32_t transform)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_SET_BUFFER_TRANSFORM, transform);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * This request sets an optional scaling factor on how the compositor
+ * interprets the contents of the buffer attached to the window.
+ *
+ * Buffer scale is double-buffered state, see wl_surface.commit.
+ *
+ * A newly created surface has its buffer scale set to 1.
+ *
+ * wl_surface.set_buffer_scale changes the pending buffer scale.
+ * wl_surface.commit copies the pending buffer scale to the current one.
+ * Otherwise, the pending and current values are never changed.
+ *
+ * The purpose of this request is to allow clients to supply higher
+ * resolution buffer data for use on high resolution outputs. It is
+ * intended that you pick the same buffer scale as the scale of the
+ * output that the surface is displayed on. This means the compositor
+ * can avoid scaling when rendering the surface on that output.
+ *
+ * Note that if the scale is larger than 1, then you have to attach
+ * a buffer that is larger (by a factor of scale in each dimension)
+ * than the desired surface size.
+ *
+ * If scale is not positive the invalid_scale protocol error is
+ * raised.
+ */
+static inline void
+wl_surface_set_buffer_scale(struct wl_surface *wl_surface, int32_t scale)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_SET_BUFFER_SCALE, scale);
+}
+
+/**
+ * @ingroup iface_wl_surface
+ *
+ * This request is used to describe the regions where the pending
+ * buffer is different from the current surface contents, and where
+ * the surface therefore needs to be repainted. The compositor
+ * ignores the parts of the damage that fall outside of the surface.
+ *
+ * Damage is double-buffered state, see wl_surface.commit.
+ *
+ * The damage rectangle is specified in buffer coordinates,
+ * where x and y specify the upper left corner of the damage rectangle.
+ *
+ * The initial value for pending damage is empty: no damage.
+ * wl_surface.damage_buffer adds pending damage: the new pending
+ * damage is the union of old pending damage and the given rectangle.
+ *
+ * wl_surface.commit assigns pending damage as the current damage,
+ * and clears pending damage. The server will clear the current
+ * damage as it repaints the surface.
+ *
+ * This request differs from wl_surface.damage in only one way - it
+ * takes damage in buffer coordinates instead of surface-local
+ * coordinates. While this generally is more intuitive than surface
+ * coordinates, it is especially desirable when using wp_viewport
+ * or when a drawing library (like EGL) is unaware of buffer scale
+ * and buffer transform.
+ *
+ * Note: Because buffer transformation changes and damage requests may
+ * be interleaved in the protocol stream, it is impossible to determine
+ * the actual mapping between surface and buffer damage until
+ * wl_surface.commit time. Therefore, compositors wishing to take both
+ * kinds of damage into account will have to accumulate damage from the
+ * two requests separately and only transform from one to the other
+ * after receiving the wl_surface.commit.
+ */
+static inline void
+wl_surface_damage_buffer(struct wl_surface *wl_surface, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_surface,
+			 WL_SURFACE_DAMAGE_BUFFER, x, y, width, height);
+}
+
+#ifndef WL_SEAT_CAPABILITY_ENUM
+#define WL_SEAT_CAPABILITY_ENUM
+/**
+ * @ingroup iface_wl_seat
+ * seat capability bitmask
+ *
+ * This is a bitmask of capabilities this seat has; if a member is
+ * set, then it is present on the seat.
+ */
+enum wl_seat_capability {
+	/**
+	 * the seat has pointer devices
+	 */
+	WL_SEAT_CAPABILITY_POINTER = 1,
+	/**
+	 * the seat has one or more keyboards
+	 */
+	WL_SEAT_CAPABILITY_KEYBOARD = 2,
+	/**
+	 * the seat has touch devices
+	 */
+	WL_SEAT_CAPABILITY_TOUCH = 4,
+};
+#endif /* WL_SEAT_CAPABILITY_ENUM */
+
+/**
+ * @ingroup iface_wl_seat
+ * @struct wl_seat_listener
+ */
+struct wl_seat_listener {
+	/**
+	 * seat capabilities changed
+	 *
+	 * This is emitted whenever a seat gains or loses the pointer,
+	 * keyboard or touch capabilities. The argument is a capability
+	 * enum containing the complete set of capabilities this seat has.
+	 *
+	 * When the pointer capability is added, a client may create a
+	 * wl_pointer object using the wl_seat.get_pointer request. This
+	 * object will receive pointer events until the capability is
+	 * removed in the future.
+	 *
+	 * When the pointer capability is removed, a client should destroy
+	 * the wl_pointer objects associated with the seat where the
+	 * capability was removed, using the wl_pointer.release request. No
+	 * further pointer events will be received on these objects.
+	 *
+	 * In some compositors, if a seat regains the pointer capability
+	 * and a client has a previously obtained wl_pointer object of
+	 * version 4 or less, that object may start sending pointer events
+	 * again. This behavior is considered a misinterpretation of the
+	 * intended behavior and must not be relied upon by the client.
+	 * wl_pointer objects of version 5 or later must not send events if
+	 * created before the most recent event notifying the client of an
+	 * added pointer capability.
+	 *
+	 * The above behavior also applies to wl_keyboard and wl_touch with
+	 * the keyboard and touch capabilities, respectively.
+	 * @param capabilities capabilities of the seat
+	 */
+	void (*capabilities)(void *data,
+			     struct wl_seat *wl_seat,
+			     uint32_t capabilities);
+	/**
+	 * unique identifier for this seat
+	 *
+	 * In a multiseat configuration this can be used by the client to
+	 * help identify which physical devices the seat represents. Based
+	 * on the seat configuration used by the compositor.
+	 * @param name seat identifier
+	 * @since 2
+	 */
+	void (*name)(void *data,
+		     struct wl_seat *wl_seat,
+		     const char *name);
+};
+
+/**
+ * @ingroup iface_wl_seat
+ */
+static inline int
+wl_seat_add_listener(struct wl_seat *wl_seat,
+		     const struct wl_seat_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_seat,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_SEAT_GET_POINTER 0
+#define WL_SEAT_GET_KEYBOARD 1
+#define WL_SEAT_GET_TOUCH 2
+#define WL_SEAT_RELEASE 3
+
+/**
+ * @ingroup iface_wl_seat
+ */
+#define WL_SEAT_CAPABILITIES_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_seat
+ */
+#define WL_SEAT_NAME_SINCE_VERSION 2
+
+/**
+ * @ingroup iface_wl_seat
+ */
+#define WL_SEAT_GET_POINTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_seat
+ */
+#define WL_SEAT_GET_KEYBOARD_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_seat
+ */
+#define WL_SEAT_GET_TOUCH_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_seat
+ */
+#define WL_SEAT_RELEASE_SINCE_VERSION 5
+
+/** @ingroup iface_wl_seat */
+static inline void
+wl_seat_set_user_data(struct wl_seat *wl_seat, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_seat, user_data);
+}
+
+/** @ingroup iface_wl_seat */
+static inline void *
+wl_seat_get_user_data(struct wl_seat *wl_seat)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_seat);
+}
+
+static inline uint32_t
+wl_seat_get_version(struct wl_seat *wl_seat)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_seat);
+}
+
+/** @ingroup iface_wl_seat */
+static inline void
+wl_seat_destroy(struct wl_seat *wl_seat)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_seat);
+}
+
+/**
+ * @ingroup iface_wl_seat
+ *
+ * The ID provided will be initialized to the wl_pointer interface
+ * for this seat.
+ *
+ * This request only takes effect if the seat has the pointer
+ * capability, or has had the pointer capability in the past.
+ * It is a protocol violation to issue this request on a seat that has
+ * never had the pointer capability.
+ */
+static inline struct wl_pointer *
+wl_seat_get_pointer(struct wl_seat *wl_seat)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_seat,
+			 WL_SEAT_GET_POINTER, &wl_pointer_interface, NULL);
+
+	return (struct wl_pointer *) id;
+}
+
+/**
+ * @ingroup iface_wl_seat
+ *
+ * The ID provided will be initialized to the wl_keyboard interface
+ * for this seat.
+ *
+ * This request only takes effect if the seat has the keyboard
+ * capability, or has had the keyboard capability in the past.
+ * It is a protocol violation to issue this request on a seat that has
+ * never had the keyboard capability.
+ */
+static inline struct wl_keyboard *
+wl_seat_get_keyboard(struct wl_seat *wl_seat)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_seat,
+			 WL_SEAT_GET_KEYBOARD, &wl_keyboard_interface, NULL);
+
+	return (struct wl_keyboard *) id;
+}
+
+/**
+ * @ingroup iface_wl_seat
+ *
+ * The ID provided will be initialized to the wl_touch interface
+ * for this seat.
+ *
+ * This request only takes effect if the seat has the touch
+ * capability, or has had the touch capability in the past.
+ * It is a protocol violation to issue this request on a seat that has
+ * never had the touch capability.
+ */
+static inline struct wl_touch *
+wl_seat_get_touch(struct wl_seat *wl_seat)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_seat,
+			 WL_SEAT_GET_TOUCH, &wl_touch_interface, NULL);
+
+	return (struct wl_touch *) id;
+}
+
+/**
+ * @ingroup iface_wl_seat
+ *
+ * Using this request a client can tell the server that it is not going to
+ * use the seat object anymore.
+ */
+static inline void
+wl_seat_release(struct wl_seat *wl_seat)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_seat,
+			 WL_SEAT_RELEASE);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_seat);
+}
+
+#ifndef WL_POINTER_ERROR_ENUM
+#define WL_POINTER_ERROR_ENUM
+enum wl_pointer_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	WL_POINTER_ERROR_ROLE = 0,
+};
+#endif /* WL_POINTER_ERROR_ENUM */
+
+#ifndef WL_POINTER_BUTTON_STATE_ENUM
+#define WL_POINTER_BUTTON_STATE_ENUM
+/**
+ * @ingroup iface_wl_pointer
+ * physical button state
+ *
+ * Describes the physical state of a button that produced the button
+ * event.
+ */
+enum wl_pointer_button_state {
+	/**
+	 * the button is not pressed
+	 */
+	WL_POINTER_BUTTON_STATE_RELEASED = 0,
+	/**
+	 * the button is pressed
+	 */
+	WL_POINTER_BUTTON_STATE_PRESSED = 1,
+};
+#endif /* WL_POINTER_BUTTON_STATE_ENUM */
+
+#ifndef WL_POINTER_AXIS_ENUM
+#define WL_POINTER_AXIS_ENUM
+/**
+ * @ingroup iface_wl_pointer
+ * axis types
+ *
+ * Describes the axis types of scroll events.
+ */
+enum wl_pointer_axis {
+	/**
+	 * vertical axis
+	 */
+	WL_POINTER_AXIS_VERTICAL_SCROLL = 0,
+	/**
+	 * horizontal axis
+	 */
+	WL_POINTER_AXIS_HORIZONTAL_SCROLL = 1,
+};
+#endif /* WL_POINTER_AXIS_ENUM */
+
+#ifndef WL_POINTER_AXIS_SOURCE_ENUM
+#define WL_POINTER_AXIS_SOURCE_ENUM
+/**
+ * @ingroup iface_wl_pointer
+ * axis source types
+ *
+ * Describes the source types for axis events. This indicates to the
+ * client how an axis event was physically generated; a client may
+ * adjust the user interface accordingly. For example, scroll events
+ * from a "finger" source may be in a smooth coordinate space with
+ * kinetic scrolling whereas a "wheel" source may be in discrete steps
+ * of a number of lines.
+ *
+ * The "continuous" axis source is a device generating events in a
+ * continuous coordinate space, but using something other than a
+ * finger. One example for this source is button-based scrolling where
+ * the vertical motion of a device is converted to scroll events while
+ * a button is held down.
+ *
+ * The "wheel tilt" axis source indicates that the actual device is a
+ * wheel but the scroll event is not caused by a rotation but a
+ * (usually sideways) tilt of the wheel.
+ */
+enum wl_pointer_axis_source {
+	/**
+	 * a physical wheel rotation
+	 */
+	WL_POINTER_AXIS_SOURCE_WHEEL = 0,
+	/**
+	 * finger on a touch surface
+	 */
+	WL_POINTER_AXIS_SOURCE_FINGER = 1,
+	/**
+	 * continuous coordinate space
+	 */
+	WL_POINTER_AXIS_SOURCE_CONTINUOUS = 2,
+	/**
+	 * a physical wheel tilt
+	 * @since 6
+	 */
+	WL_POINTER_AXIS_SOURCE_WHEEL_TILT = 3,
+};
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_AXIS_SOURCE_WHEEL_TILT_SINCE_VERSION 6
+#endif /* WL_POINTER_AXIS_SOURCE_ENUM */
+
+/**
+ * @ingroup iface_wl_pointer
+ * @struct wl_pointer_listener
+ */
+struct wl_pointer_listener {
+	/**
+	 * enter event
+	 *
+	 * Notification that this seat's pointer is focused on a certain
+	 * surface.
+	 *
+	 * When a seat's focus enters a surface, the pointer image is
+	 * undefined and a client should respond to this event by setting
+	 * an appropriate pointer image with the set_cursor request.
+	 * @param serial serial number of the enter event
+	 * @param surface surface entered by the pointer
+	 * @param surface_x surface-local x coordinate
+	 * @param surface_y surface-local y coordinate
+	 */
+	void (*enter)(void *data,
+		      struct wl_pointer *wl_pointer,
+		      uint32_t serial,
+		      struct wl_surface *surface,
+		      wl_fixed_t surface_x,
+		      wl_fixed_t surface_y);
+	/**
+	 * leave event
+	 *
+	 * Notification that this seat's pointer is no longer focused on
+	 * a certain surface.
+	 *
+	 * The leave notification is sent before the enter notification for
+	 * the new focus.
+	 * @param serial serial number of the leave event
+	 * @param surface surface left by the pointer
+	 */
+	void (*leave)(void *data,
+		      struct wl_pointer *wl_pointer,
+		      uint32_t serial,
+		      struct wl_surface *surface);
+	/**
+	 * pointer motion event
+	 *
+	 * Notification of pointer location change. The arguments
+	 * surface_x and surface_y are the location relative to the focused
+	 * surface.
+	 * @param time timestamp with millisecond granularity
+	 * @param surface_x surface-local x coordinate
+	 * @param surface_y surface-local y coordinate
+	 */
+	void (*motion)(void *data,
+		       struct wl_pointer *wl_pointer,
+		       uint32_t time,
+		       wl_fixed_t surface_x,
+		       wl_fixed_t surface_y);
+	/**
+	 * pointer button event
+	 *
+	 * Mouse button click and release notifications.
+	 *
+	 * The location of the click is given by the last motion or enter
+	 * event. The time argument is a timestamp with millisecond
+	 * granularity, with an undefined base.
+	 *
+	 * The button is a button code as defined in the Linux kernel's
+	 * linux/input-event-codes.h header file, e.g. BTN_LEFT.
+	 *
+	 * Any 16-bit button code value is reserved for future additions to
+	 * the kernel's event code list. All other button codes above
+	 * 0xFFFF are currently undefined but may be used in future
+	 * versions of this protocol.
+	 * @param serial serial number of the button event
+	 * @param time timestamp with millisecond granularity
+	 * @param button button that produced the event
+	 * @param state physical state of the button
+	 */
+	void (*button)(void *data,
+		       struct wl_pointer *wl_pointer,
+		       uint32_t serial,
+		       uint32_t time,
+		       uint32_t button,
+		       uint32_t state);
+	/**
+	 * axis event
+	 *
+	 * Scroll and other axis notifications.
+	 *
+	 * For scroll events (vertical and horizontal scroll axes), the
+	 * value parameter is the length of a vector along the specified
+	 * axis in a coordinate space identical to those of motion events,
+	 * representing a relative movement along the specified axis.
+	 *
+	 * For devices that support movements non-parallel to axes multiple
+	 * axis events will be emitted.
+	 *
+	 * When applicable, for example for touch pads, the server can
+	 * choose to emit scroll events where the motion vector is
+	 * equivalent to a motion event vector.
+	 *
+	 * When applicable, a client can transform its content relative to
+	 * the scroll distance.
+	 * @param time timestamp with millisecond granularity
+	 * @param axis axis type
+	 * @param value length of vector in surface-local coordinate space
+	 */
+	void (*axis)(void *data,
+		     struct wl_pointer *wl_pointer,
+		     uint32_t time,
+		     uint32_t axis,
+		     wl_fixed_t value);
+	/**
+	 * end of a pointer event sequence
+	 *
+	 * Indicates the end of a set of events that logically belong
+	 * together. A client is expected to accumulate the data in all
+	 * events within the frame before proceeding.
+	 *
+	 * All wl_pointer events before a wl_pointer.frame event belong
+	 * logically together. For example, in a diagonal scroll motion the
+	 * compositor will send an optional wl_pointer.axis_source event,
+	 * two wl_pointer.axis events (horizontal and vertical) and finally
+	 * a wl_pointer.frame event. The client may use this information to
+	 * calculate a diagonal vector for scrolling.
+	 *
+	 * When multiple wl_pointer.axis events occur within the same
+	 * frame, the motion vector is the combined motion of all events.
+	 * When a wl_pointer.axis and a wl_pointer.axis_stop event occur
+	 * within the same frame, this indicates that axis movement in one
+	 * axis has stopped but continues in the other axis. When multiple
+	 * wl_pointer.axis_stop events occur within the same frame, this
+	 * indicates that these axes stopped in the same instance.
+	 *
+	 * A wl_pointer.frame event is sent for every logical event group,
+	 * even if the group only contains a single wl_pointer event.
+	 * Specifically, a client may get a sequence: motion, frame,
+	 * button, frame, axis, frame, axis_stop, frame.
+	 *
+	 * The wl_pointer.enter and wl_pointer.leave events are logical
+	 * events generated by the compositor and not the hardware. These
+	 * events are also grouped by a wl_pointer.frame. When a pointer
+	 * moves from one surface to another, a compositor should group the
+	 * wl_pointer.leave event within the same wl_pointer.frame.
+	 * However, a client must not rely on wl_pointer.leave and
+	 * wl_pointer.enter being in the same wl_pointer.frame.
+	 * Compositor-specific policies may require the wl_pointer.leave
+	 * and wl_pointer.enter event being split across multiple
+	 * wl_pointer.frame groups.
+	 * @since 5
+	 */
+	void (*frame)(void *data,
+		      struct wl_pointer *wl_pointer);
+	/**
+	 * axis source event
+	 *
+	 * Source information for scroll and other axes.
+	 *
+	 * This event does not occur on its own. It is sent before a
+	 * wl_pointer.frame event and carries the source information for
+	 * all events within that frame.
+	 *
+	 * The source specifies how this event was generated. If the source
+	 * is wl_pointer.axis_source.finger, a wl_pointer.axis_stop event
+	 * will be sent when the user lifts the finger off the device.
+	 *
+	 * If the source is wl_pointer.axis_source.wheel,
+	 * wl_pointer.axis_source.wheel_tilt or
+	 * wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event
+	 * may or may not be sent. Whether a compositor sends an axis_stop
+	 * event for these sources is hardware-specific and
+	 * implementation-dependent; clients must not rely on receiving an
+	 * axis_stop event for these scroll sources and should treat scroll
+	 * sequences from these scroll sources as unterminated by default.
+	 *
+	 * This event is optional. If the source is unknown for a
+	 * particular axis event sequence, no event is sent. Only one
+	 * wl_pointer.axis_source event is permitted per frame.
+	 *
+	 * The order of wl_pointer.axis_discrete and wl_pointer.axis_source
+	 * is not guaranteed.
+	 * @param axis_source source of the axis event
+	 * @since 5
+	 */
+	void (*axis_source)(void *data,
+			    struct wl_pointer *wl_pointer,
+			    uint32_t axis_source);
+	/**
+	 * axis stop event
+	 *
+	 * Stop notification for scroll and other axes.
+	 *
+	 * For some wl_pointer.axis_source types, a wl_pointer.axis_stop
+	 * event is sent to notify a client that the axis sequence has
+	 * terminated. This enables the client to implement kinetic
+	 * scrolling. See the wl_pointer.axis_source documentation for
+	 * information on when this event may be generated.
+	 *
+	 * Any wl_pointer.axis events with the same axis_source after this
+	 * event should be considered as the start of a new axis motion.
+	 *
+	 * The timestamp is to be interpreted identical to the timestamp in
+	 * the wl_pointer.axis event. The timestamp value may be the same
+	 * as a preceding wl_pointer.axis event.
+	 * @param time timestamp with millisecond granularity
+	 * @param axis the axis stopped with this event
+	 * @since 5
+	 */
+	void (*axis_stop)(void *data,
+			  struct wl_pointer *wl_pointer,
+			  uint32_t time,
+			  uint32_t axis);
+	/**
+	 * axis click event
+	 *
+	 * Discrete step information for scroll and other axes.
+	 *
+	 * This event carries the axis value of the wl_pointer.axis event
+	 * in discrete steps (e.g. mouse wheel clicks).
+	 *
+	 * This event does not occur on its own, it is coupled with a
+	 * wl_pointer.axis event that represents this axis value on a
+	 * continuous scale. The protocol guarantees that each
+	 * axis_discrete event is always followed by exactly one axis event
+	 * with the same axis number within the same wl_pointer.frame. Note
+	 * that the protocol allows for other events to occur between the
+	 * axis_discrete and its coupled axis event, including other
+	 * axis_discrete or axis events.
+	 *
+	 * This event is optional; continuous scrolling devices like
+	 * two-finger scrolling on touchpads do not have discrete steps and
+	 * do not generate this event.
+	 *
+	 * The discrete value carries the directional information. e.g. a
+	 * value of -2 is two steps towards the negative direction of this
+	 * axis.
+	 *
+	 * The axis number is identical to the axis number in the
+	 * associated axis event.
+	 *
+	 * The order of wl_pointer.axis_discrete and wl_pointer.axis_source
+	 * is not guaranteed.
+	 * @param axis axis type
+	 * @param discrete number of steps
+	 * @since 5
+	 */
+	void (*axis_discrete)(void *data,
+			      struct wl_pointer *wl_pointer,
+			      uint32_t axis,
+			      int32_t discrete);
+};
+
+/**
+ * @ingroup iface_wl_pointer
+ */
+static inline int
+wl_pointer_add_listener(struct wl_pointer *wl_pointer,
+			const struct wl_pointer_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_pointer,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_POINTER_SET_CURSOR 0
+#define WL_POINTER_RELEASE 1
+
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_ENTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_LEAVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_MOTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_BUTTON_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_AXIS_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_FRAME_SINCE_VERSION 5
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_AXIS_SOURCE_SINCE_VERSION 5
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_AXIS_STOP_SINCE_VERSION 5
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_AXIS_DISCRETE_SINCE_VERSION 5
+
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_SET_CURSOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_pointer
+ */
+#define WL_POINTER_RELEASE_SINCE_VERSION 3
+
+/** @ingroup iface_wl_pointer */
+static inline void
+wl_pointer_set_user_data(struct wl_pointer *wl_pointer, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_pointer, user_data);
+}
+
+/** @ingroup iface_wl_pointer */
+static inline void *
+wl_pointer_get_user_data(struct wl_pointer *wl_pointer)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_pointer);
+}
+
+static inline uint32_t
+wl_pointer_get_version(struct wl_pointer *wl_pointer)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_pointer);
+}
+
+/** @ingroup iface_wl_pointer */
+static inline void
+wl_pointer_destroy(struct wl_pointer *wl_pointer)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_pointer);
+}
+
+/**
+ * @ingroup iface_wl_pointer
+ *
+ * Set the pointer surface, i.e., the surface that contains the
+ * pointer image (cursor). This request gives the surface the role
+ * of a cursor. If the surface already has another role, it raises
+ * a protocol error.
+ *
+ * The cursor actually changes only if the pointer
+ * focus for this device is one of the requesting client's surfaces
+ * or the surface parameter is the current pointer surface. If
+ * there was a previous surface set with this request it is
+ * replaced. If surface is NULL, the pointer image is hidden.
+ *
+ * The parameters hotspot_x and hotspot_y define the position of
+ * the pointer surface relative to the pointer location. Its
+ * top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
+ * where (x, y) are the coordinates of the pointer location, in
+ * surface-local coordinates.
+ *
+ * On surface.attach requests to the pointer surface, hotspot_x
+ * and hotspot_y are decremented by the x and y parameters
+ * passed to the request. Attach must be confirmed by
+ * wl_surface.commit as usual.
+ *
+ * The hotspot can also be updated by passing the currently set
+ * pointer surface to this request with new values for hotspot_x
+ * and hotspot_y.
+ *
+ * The current and pending input regions of the wl_surface are
+ * cleared, and wl_surface.set_input_region is ignored until the
+ * wl_surface is no longer used as the cursor. When the use as a
+ * cursor ends, the current and pending input regions become
+ * undefined, and the wl_surface is unmapped.
+ */
+static inline void
+wl_pointer_set_cursor(struct wl_pointer *wl_pointer, uint32_t serial, struct wl_surface *surface, int32_t hotspot_x, int32_t hotspot_y)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_pointer,
+			 WL_POINTER_SET_CURSOR, serial, surface, hotspot_x, hotspot_y);
+}
+
+/**
+ * @ingroup iface_wl_pointer
+ *
+ * Using this request a client can tell the server that it is not going to
+ * use the pointer object anymore.
+ *
+ * This request destroys the pointer proxy object, so clients must not call
+ * wl_pointer_destroy() after using this request.
+ */
+static inline void
+wl_pointer_release(struct wl_pointer *wl_pointer)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_pointer,
+			 WL_POINTER_RELEASE);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_pointer);
+}
+
+#ifndef WL_KEYBOARD_KEYMAP_FORMAT_ENUM
+#define WL_KEYBOARD_KEYMAP_FORMAT_ENUM
+/**
+ * @ingroup iface_wl_keyboard
+ * keyboard mapping format
+ *
+ * This specifies the format of the keymap provided to the
+ * client with the wl_keyboard.keymap event.
+ */
+enum wl_keyboard_keymap_format {
+	/**
+	 * no keymap; client must understand how to interpret the raw keycode
+	 */
+	WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP = 0,
+	/**
+	 * libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
+	 */
+	WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 = 1,
+};
+#endif /* WL_KEYBOARD_KEYMAP_FORMAT_ENUM */
+
+#ifndef WL_KEYBOARD_KEY_STATE_ENUM
+#define WL_KEYBOARD_KEY_STATE_ENUM
+/**
+ * @ingroup iface_wl_keyboard
+ * physical key state
+ *
+ * Describes the physical state of a key that produced the key event.
+ */
+enum wl_keyboard_key_state {
+	/**
+	 * key is not pressed
+	 */
+	WL_KEYBOARD_KEY_STATE_RELEASED = 0,
+	/**
+	 * key is pressed
+	 */
+	WL_KEYBOARD_KEY_STATE_PRESSED = 1,
+};
+#endif /* WL_KEYBOARD_KEY_STATE_ENUM */
+
+/**
+ * @ingroup iface_wl_keyboard
+ * @struct wl_keyboard_listener
+ */
+struct wl_keyboard_listener {
+	/**
+	 * keyboard mapping
+	 *
+	 * This event provides a file descriptor to the client which can
+	 * be memory-mapped to provide a keyboard mapping description.
+	 * @param format keymap format
+	 * @param fd keymap file descriptor
+	 * @param size keymap size, in bytes
+	 */
+	void (*keymap)(void *data,
+		       struct wl_keyboard *wl_keyboard,
+		       uint32_t format,
+		       int32_t fd,
+		       uint32_t size);
+	/**
+	 * enter event
+	 *
+	 * Notification that this seat's keyboard focus is on a certain
+	 * surface.
+	 * @param serial serial number of the enter event
+	 * @param surface surface gaining keyboard focus
+	 * @param keys the currently pressed keys
+	 */
+	void (*enter)(void *data,
+		      struct wl_keyboard *wl_keyboard,
+		      uint32_t serial,
+		      struct wl_surface *surface,
+		      struct wl_array *keys);
+	/**
+	 * leave event
+	 *
+	 * Notification that this seat's keyboard focus is no longer on a
+	 * certain surface.
+	 *
+	 * The leave notification is sent before the enter notification for
+	 * the new focus.
+	 * @param serial serial number of the leave event
+	 * @param surface surface that lost keyboard focus
+	 */
+	void (*leave)(void *data,
+		      struct wl_keyboard *wl_keyboard,
+		      uint32_t serial,
+		      struct wl_surface *surface);
+	/**
+	 * key event
+	 *
+	 * A key was pressed or released. The time argument is a
+	 * timestamp with millisecond granularity, with an undefined base.
+	 * @param serial serial number of the key event
+	 * @param time timestamp with millisecond granularity
+	 * @param key key that produced the event
+	 * @param state physical state of the key
+	 */
+	void (*key)(void *data,
+		    struct wl_keyboard *wl_keyboard,
+		    uint32_t serial,
+		    uint32_t time,
+		    uint32_t key,
+		    uint32_t state);
+	/**
+	 * modifier and group state
+	 *
+	 * Notifies clients that the modifier and/or group state has
+	 * changed, and it should update its local state.
+	 * @param serial serial number of the modifiers event
+	 * @param mods_depressed depressed modifiers
+	 * @param mods_latched latched modifiers
+	 * @param mods_locked locked modifiers
+	 * @param group keyboard layout
+	 */
+	void (*modifiers)(void *data,
+			  struct wl_keyboard *wl_keyboard,
+			  uint32_t serial,
+			  uint32_t mods_depressed,
+			  uint32_t mods_latched,
+			  uint32_t mods_locked,
+			  uint32_t group);
+	/**
+	 * repeat rate and delay
+	 *
+	 * Informs the client about the keyboard's repeat rate and delay.
+	 *
+	 * This event is sent as soon as the wl_keyboard object has been
+	 * created, and is guaranteed to be received by the client before
+	 * any key press event.
+	 *
+	 * Negative values for either rate or delay are illegal. A rate of
+	 * zero will disable any repeating (regardless of the value of
+	 * delay).
+	 *
+	 * This event can be sent later on as well with a new value if
+	 * necessary, so clients should continue listening for the event
+	 * past the creation of wl_keyboard.
+	 * @param rate the rate of repeating keys in characters per second
+	 * @param delay delay in milliseconds since key down until repeating starts
+	 * @since 4
+	 */
+	void (*repeat_info)(void *data,
+			    struct wl_keyboard *wl_keyboard,
+			    int32_t rate,
+			    int32_t delay);
+};
+
+/**
+ * @ingroup iface_wl_keyboard
+ */
+static inline int
+wl_keyboard_add_listener(struct wl_keyboard *wl_keyboard,
+			 const struct wl_keyboard_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_keyboard,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_KEYBOARD_RELEASE 0
+
+/**
+ * @ingroup iface_wl_keyboard
+ */
+#define WL_KEYBOARD_KEYMAP_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_keyboard
+ */
+#define WL_KEYBOARD_ENTER_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_keyboard
+ */
+#define WL_KEYBOARD_LEAVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_keyboard
+ */
+#define WL_KEYBOARD_KEY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_keyboard
+ */
+#define WL_KEYBOARD_MODIFIERS_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_keyboard
+ */
+#define WL_KEYBOARD_REPEAT_INFO_SINCE_VERSION 4
+
+/**
+ * @ingroup iface_wl_keyboard
+ */
+#define WL_KEYBOARD_RELEASE_SINCE_VERSION 3
+
+/** @ingroup iface_wl_keyboard */
+static inline void
+wl_keyboard_set_user_data(struct wl_keyboard *wl_keyboard, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_keyboard, user_data);
+}
+
+/** @ingroup iface_wl_keyboard */
+static inline void *
+wl_keyboard_get_user_data(struct wl_keyboard *wl_keyboard)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_keyboard);
+}
+
+static inline uint32_t
+wl_keyboard_get_version(struct wl_keyboard *wl_keyboard)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_keyboard);
+}
+
+/** @ingroup iface_wl_keyboard */
+static inline void
+wl_keyboard_destroy(struct wl_keyboard *wl_keyboard)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_keyboard);
+}
+
+/**
+ * @ingroup iface_wl_keyboard
+ */
+static inline void
+wl_keyboard_release(struct wl_keyboard *wl_keyboard)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_keyboard,
+			 WL_KEYBOARD_RELEASE);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_keyboard);
+}
+
+/**
+ * @ingroup iface_wl_touch
+ * @struct wl_touch_listener
+ */
+struct wl_touch_listener {
+	/**
+	 * touch down event and beginning of a touch sequence
+	 *
+	 * A new touch point has appeared on the surface. This touch
+	 * point is assigned a unique ID. Future events from this touch
+	 * point reference this ID. The ID ceases to be valid after a touch
+	 * up event and may be reused in the future.
+	 * @param serial serial number of the touch down event
+	 * @param time timestamp with millisecond granularity
+	 * @param surface surface touched
+	 * @param id the unique ID of this touch point
+	 * @param x surface-local x coordinate
+	 * @param y surface-local y coordinate
+	 */
+	void (*down)(void *data,
+		     struct wl_touch *wl_touch,
+		     uint32_t serial,
+		     uint32_t time,
+		     struct wl_surface *surface,
+		     int32_t id,
+		     wl_fixed_t x,
+		     wl_fixed_t y);
+	/**
+	 * end of a touch event sequence
+	 *
+	 * The touch point has disappeared. No further events will be
+	 * sent for this touch point and the touch point's ID is released
+	 * and may be reused in a future touch down event.
+	 * @param serial serial number of the touch up event
+	 * @param time timestamp with millisecond granularity
+	 * @param id the unique ID of this touch point
+	 */
+	void (*up)(void *data,
+		   struct wl_touch *wl_touch,
+		   uint32_t serial,
+		   uint32_t time,
+		   int32_t id);
+	/**
+	 * update of touch point coordinates
+	 *
+	 * A touch point has changed coordinates.
+	 * @param time timestamp with millisecond granularity
+	 * @param id the unique ID of this touch point
+	 * @param x surface-local x coordinate
+	 * @param y surface-local y coordinate
+	 */
+	void (*motion)(void *data,
+		       struct wl_touch *wl_touch,
+		       uint32_t time,
+		       int32_t id,
+		       wl_fixed_t x,
+		       wl_fixed_t y);
+	/**
+	 * end of touch frame event
+	 *
+	 * Indicates the end of a set of events that logically belong
+	 * together. A client is expected to accumulate the data in all
+	 * events within the frame before proceeding.
+	 *
+	 * A wl_touch.frame terminates at least one event but otherwise no
+	 * guarantee is provided about the set of events within a frame. A
+	 * client must assume that any state not updated in a frame is
+	 * unchanged from the previously known state.
+	 */
+	void (*frame)(void *data,
+		      struct wl_touch *wl_touch);
+	/**
+	 * touch session cancelled
+	 *
+	 * Sent if the compositor decides the touch stream is a global
+	 * gesture. No further events are sent to the clients from that
+	 * particular gesture. Touch cancellation applies to all touch
+	 * points currently active on this client's surface. The client is
+	 * responsible for finalizing the touch points, future touch points
+	 * on this surface may reuse the touch point ID.
+	 */
+	void (*cancel)(void *data,
+		       struct wl_touch *wl_touch);
+	/**
+	 * update shape of touch point
+	 *
+	 * Sent when a touchpoint has changed its shape.
+	 *
+	 * This event does not occur on its own. It is sent before a
+	 * wl_touch.frame event and carries the new shape information for
+	 * any previously reported, or new touch points of that frame.
+	 *
+	 * Other events describing the touch point such as wl_touch.down,
+	 * wl_touch.motion or wl_touch.orientation may be sent within the
+	 * same wl_touch.frame. A client should treat these events as a
+	 * single logical touch point update. The order of wl_touch.shape,
+	 * wl_touch.orientation and wl_touch.motion is not guaranteed. A
+	 * wl_touch.down event is guaranteed to occur before the first
+	 * wl_touch.shape event for this touch ID but both events may occur
+	 * within the same wl_touch.frame.
+	 *
+	 * A touchpoint shape is approximated by an ellipse through the
+	 * major and minor axis length. The major axis length describes the
+	 * longer diameter of the ellipse, while the minor axis length
+	 * describes the shorter diameter. Major and minor are orthogonal
+	 * and both are specified in surface-local coordinates. The center
+	 * of the ellipse is always at the touchpoint location as reported
+	 * by wl_touch.down or wl_touch.move.
+	 *
+	 * This event is only sent by the compositor if the touch device
+	 * supports shape reports. The client has to make reasonable
+	 * assumptions about the shape if it did not receive this event.
+	 * @param id the unique ID of this touch point
+	 * @param major length of the major axis in surface-local coordinates
+	 * @param minor length of the minor axis in surface-local coordinates
+	 * @since 6
+	 */
+	void (*shape)(void *data,
+		      struct wl_touch *wl_touch,
+		      int32_t id,
+		      wl_fixed_t major,
+		      wl_fixed_t minor);
+	/**
+	 * update orientation of touch point
+	 *
+	 * Sent when a touchpoint has changed its orientation.
+	 *
+	 * This event does not occur on its own. It is sent before a
+	 * wl_touch.frame event and carries the new shape information for
+	 * any previously reported, or new touch points of that frame.
+	 *
+	 * Other events describing the touch point such as wl_touch.down,
+	 * wl_touch.motion or wl_touch.shape may be sent within the same
+	 * wl_touch.frame. A client should treat these events as a single
+	 * logical touch point update. The order of wl_touch.shape,
+	 * wl_touch.orientation and wl_touch.motion is not guaranteed. A
+	 * wl_touch.down event is guaranteed to occur before the first
+	 * wl_touch.orientation event for this touch ID but both events may
+	 * occur within the same wl_touch.frame.
+	 *
+	 * The orientation describes the clockwise angle of a touchpoint's
+	 * major axis to the positive surface y-axis and is normalized to
+	 * the -180 to +180 degree range. The granularity of orientation
+	 * depends on the touch device, some devices only support binary
+	 * rotation values between 0 and 90 degrees.
+	 *
+	 * This event is only sent by the compositor if the touch device
+	 * supports orientation reports.
+	 * @param id the unique ID of this touch point
+	 * @param orientation angle between major axis and positive surface y-axis in degrees
+	 * @since 6
+	 */
+	void (*orientation)(void *data,
+			    struct wl_touch *wl_touch,
+			    int32_t id,
+			    wl_fixed_t orientation);
+};
+
+/**
+ * @ingroup iface_wl_touch
+ */
+static inline int
+wl_touch_add_listener(struct wl_touch *wl_touch,
+		      const struct wl_touch_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_touch,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_TOUCH_RELEASE 0
+
+/**
+ * @ingroup iface_wl_touch
+ */
+#define WL_TOUCH_DOWN_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_touch
+ */
+#define WL_TOUCH_UP_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_touch
+ */
+#define WL_TOUCH_MOTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_touch
+ */
+#define WL_TOUCH_FRAME_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_touch
+ */
+#define WL_TOUCH_CANCEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_touch
+ */
+#define WL_TOUCH_SHAPE_SINCE_VERSION 6
+/**
+ * @ingroup iface_wl_touch
+ */
+#define WL_TOUCH_ORIENTATION_SINCE_VERSION 6
+
+/**
+ * @ingroup iface_wl_touch
+ */
+#define WL_TOUCH_RELEASE_SINCE_VERSION 3
+
+/** @ingroup iface_wl_touch */
+static inline void
+wl_touch_set_user_data(struct wl_touch *wl_touch, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_touch, user_data);
+}
+
+/** @ingroup iface_wl_touch */
+static inline void *
+wl_touch_get_user_data(struct wl_touch *wl_touch)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_touch);
+}
+
+static inline uint32_t
+wl_touch_get_version(struct wl_touch *wl_touch)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_touch);
+}
+
+/** @ingroup iface_wl_touch */
+static inline void
+wl_touch_destroy(struct wl_touch *wl_touch)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_touch);
+}
+
+/**
+ * @ingroup iface_wl_touch
+ */
+static inline void
+wl_touch_release(struct wl_touch *wl_touch)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_touch,
+			 WL_TOUCH_RELEASE);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_touch);
+}
+
+#ifndef WL_OUTPUT_SUBPIXEL_ENUM
+#define WL_OUTPUT_SUBPIXEL_ENUM
+/**
+ * @ingroup iface_wl_output
+ * subpixel geometry information
+ *
+ * This enumeration describes how the physical
+ * pixels on an output are laid out.
+ */
+enum wl_output_subpixel {
+	/**
+	 * unknown geometry
+	 */
+	WL_OUTPUT_SUBPIXEL_UNKNOWN = 0,
+	/**
+	 * no geometry
+	 */
+	WL_OUTPUT_SUBPIXEL_NONE = 1,
+	/**
+	 * horizontal RGB
+	 */
+	WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB = 2,
+	/**
+	 * horizontal BGR
+	 */
+	WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR = 3,
+	/**
+	 * vertical RGB
+	 */
+	WL_OUTPUT_SUBPIXEL_VERTICAL_RGB = 4,
+	/**
+	 * vertical BGR
+	 */
+	WL_OUTPUT_SUBPIXEL_VERTICAL_BGR = 5,
+};
+#endif /* WL_OUTPUT_SUBPIXEL_ENUM */
+
+#ifndef WL_OUTPUT_TRANSFORM_ENUM
+#define WL_OUTPUT_TRANSFORM_ENUM
+/**
+ * @ingroup iface_wl_output
+ * transform from framebuffer to output
+ *
+ * This describes the transform that a compositor will apply to a
+ * surface to compensate for the rotation or mirroring of an
+ * output device.
+ *
+ * The flipped values correspond to an initial flip around a
+ * vertical axis followed by rotation.
+ *
+ * The purpose is mainly to allow clients to render accordingly and
+ * tell the compositor, so that for fullscreen surfaces, the
+ * compositor will still be able to scan out directly from client
+ * surfaces.
+ */
+enum wl_output_transform {
+	/**
+	 * no transform
+	 */
+	WL_OUTPUT_TRANSFORM_NORMAL = 0,
+	/**
+	 * 90 degrees counter-clockwise
+	 */
+	WL_OUTPUT_TRANSFORM_90 = 1,
+	/**
+	 * 180 degrees counter-clockwise
+	 */
+	WL_OUTPUT_TRANSFORM_180 = 2,
+	/**
+	 * 270 degrees counter-clockwise
+	 */
+	WL_OUTPUT_TRANSFORM_270 = 3,
+	/**
+	 * 180 degree flip around a vertical axis
+	 */
+	WL_OUTPUT_TRANSFORM_FLIPPED = 4,
+	/**
+	 * flip and rotate 90 degrees counter-clockwise
+	 */
+	WL_OUTPUT_TRANSFORM_FLIPPED_90 = 5,
+	/**
+	 * flip and rotate 180 degrees counter-clockwise
+	 */
+	WL_OUTPUT_TRANSFORM_FLIPPED_180 = 6,
+	/**
+	 * flip and rotate 270 degrees counter-clockwise
+	 */
+	WL_OUTPUT_TRANSFORM_FLIPPED_270 = 7,
+};
+#endif /* WL_OUTPUT_TRANSFORM_ENUM */
+
+#ifndef WL_OUTPUT_MODE_ENUM
+#define WL_OUTPUT_MODE_ENUM
+/**
+ * @ingroup iface_wl_output
+ * mode information
+ *
+ * These flags describe properties of an output mode.
+ * They are used in the flags bitfield of the mode event.
+ */
+enum wl_output_mode {
+	/**
+	 * indicates this is the current mode
+	 */
+	WL_OUTPUT_MODE_CURRENT = 0x1,
+	/**
+	 * indicates this is the preferred mode
+	 */
+	WL_OUTPUT_MODE_PREFERRED = 0x2,
+};
+#endif /* WL_OUTPUT_MODE_ENUM */
+
+/**
+ * @ingroup iface_wl_output
+ * @struct wl_output_listener
+ */
+struct wl_output_listener {
+	/**
+	 * properties of the output
+	 *
+	 * The geometry event describes geometric properties of the
+	 * output. The event is sent when binding to the output object and
+	 * whenever any of the properties change.
+	 *
+	 * The physical size can be set to zero if it doesn't make sense
+	 * for this output (e.g. for projectors or virtual outputs).
+	 * @param x x position within the global compositor space
+	 * @param y y position within the global compositor space
+	 * @param physical_width width in millimeters of the output
+	 * @param physical_height height in millimeters of the output
+	 * @param subpixel subpixel orientation of the output
+	 * @param make textual description of the manufacturer
+	 * @param model textual description of the model
+	 * @param transform transform that maps framebuffer to output
+	 */
+	void (*geometry)(void *data,
+			 struct wl_output *wl_output,
+			 int32_t x,
+			 int32_t y,
+			 int32_t physical_width,
+			 int32_t physical_height,
+			 int32_t subpixel,
+			 const char *make,
+			 const char *model,
+			 int32_t transform);
+	/**
+	 * advertise available modes for the output
+	 *
+	 * The mode event describes an available mode for the output.
+	 *
+	 * The event is sent when binding to the output object and there
+	 * will always be one mode, the current mode. The event is sent
+	 * again if an output changes mode, for the mode that is now
+	 * current. In other words, the current mode is always the last
+	 * mode that was received with the current flag set.
+	 *
+	 * The size of a mode is given in physical hardware units of the
+	 * output device. This is not necessarily the same as the output
+	 * size in the global compositor space. For instance, the output
+	 * may be scaled, as described in wl_output.scale, or transformed,
+	 * as described in wl_output.transform.
+	 * @param flags bitfield of mode flags
+	 * @param width width of the mode in hardware units
+	 * @param height height of the mode in hardware units
+	 * @param refresh vertical refresh rate in mHz
+	 */
+	void (*mode)(void *data,
+		     struct wl_output *wl_output,
+		     uint32_t flags,
+		     int32_t width,
+		     int32_t height,
+		     int32_t refresh);
+	/**
+	 * sent all information about output
+	 *
+	 * This event is sent after all other properties have been sent
+	 * after binding to the output object and after any other property
+	 * changes done after that. This allows changes to the output
+	 * properties to be seen as atomic, even if they happen via
+	 * multiple events.
+	 * @since 2
+	 */
+	void (*done)(void *data,
+		     struct wl_output *wl_output);
+	/**
+	 * output scaling properties
+	 *
+	 * This event contains scaling geometry information that is not
+	 * in the geometry event. It may be sent after binding the output
+	 * object or if the output scale changes later. If it is not sent,
+	 * the client should assume a scale of 1.
+	 *
+	 * A scale larger than 1 means that the compositor will
+	 * automatically scale surface buffers by this amount when
+	 * rendering. This is used for very high resolution displays where
+	 * applications rendering at the native resolution would be too
+	 * small to be legible.
+	 *
+	 * It is intended that scaling aware clients track the current
+	 * output of a surface, and if it is on a scaled output it should
+	 * use wl_surface.set_buffer_scale with the scale of the output.
+	 * That way the compositor can avoid scaling the surface, and the
+	 * client can supply a higher detail image.
+	 * @param factor scaling factor of output
+	 * @since 2
+	 */
+	void (*scale)(void *data,
+		      struct wl_output *wl_output,
+		      int32_t factor);
+};
+
+/**
+ * @ingroup iface_wl_output
+ */
+static inline int
+wl_output_add_listener(struct wl_output *wl_output,
+		       const struct wl_output_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) wl_output,
+				     (void (**)(void)) listener, data);
+}
+
+#define WL_OUTPUT_RELEASE 0
+
+/**
+ * @ingroup iface_wl_output
+ */
+#define WL_OUTPUT_GEOMETRY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_output
+ */
+#define WL_OUTPUT_MODE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_output
+ */
+#define WL_OUTPUT_DONE_SINCE_VERSION 2
+/**
+ * @ingroup iface_wl_output
+ */
+#define WL_OUTPUT_SCALE_SINCE_VERSION 2
+
+/**
+ * @ingroup iface_wl_output
+ */
+#define WL_OUTPUT_RELEASE_SINCE_VERSION 3
+
+/** @ingroup iface_wl_output */
+static inline void
+wl_output_set_user_data(struct wl_output *wl_output, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_output, user_data);
+}
+
+/** @ingroup iface_wl_output */
+static inline void *
+wl_output_get_user_data(struct wl_output *wl_output)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_output);
+}
+
+static inline uint32_t
+wl_output_get_version(struct wl_output *wl_output)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_output);
+}
+
+/** @ingroup iface_wl_output */
+static inline void
+wl_output_destroy(struct wl_output *wl_output)
+{
+	wl_proxy_destroy((struct wl_proxy *) wl_output);
+}
+
+/**
+ * @ingroup iface_wl_output
+ *
+ * Using this request a client can tell the server that it is not going to
+ * use the output object anymore.
+ */
+static inline void
+wl_output_release(struct wl_output *wl_output)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_output,
+			 WL_OUTPUT_RELEASE);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_output);
+}
+
+#define WL_REGION_DESTROY 0
+#define WL_REGION_ADD 1
+#define WL_REGION_SUBTRACT 2
+
+
+/**
+ * @ingroup iface_wl_region
+ */
+#define WL_REGION_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_region
+ */
+#define WL_REGION_ADD_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_region
+ */
+#define WL_REGION_SUBTRACT_SINCE_VERSION 1
+
+/** @ingroup iface_wl_region */
+static inline void
+wl_region_set_user_data(struct wl_region *wl_region, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_region, user_data);
+}
+
+/** @ingroup iface_wl_region */
+static inline void *
+wl_region_get_user_data(struct wl_region *wl_region)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_region);
+}
+
+static inline uint32_t
+wl_region_get_version(struct wl_region *wl_region)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_region);
+}
+
+/**
+ * @ingroup iface_wl_region
+ *
+ * Destroy the region.  This will invalidate the object ID.
+ */
+static inline void
+wl_region_destroy(struct wl_region *wl_region)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_region,
+			 WL_REGION_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_region);
+}
+
+/**
+ * @ingroup iface_wl_region
+ *
+ * Add the specified rectangle to the region.
+ */
+static inline void
+wl_region_add(struct wl_region *wl_region, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_region,
+			 WL_REGION_ADD, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_wl_region
+ *
+ * Subtract the specified rectangle from the region.
+ */
+static inline void
+wl_region_subtract(struct wl_region *wl_region, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_region,
+			 WL_REGION_SUBTRACT, x, y, width, height);
+}
+
+#ifndef WL_SUBCOMPOSITOR_ERROR_ENUM
+#define WL_SUBCOMPOSITOR_ERROR_ENUM
+enum wl_subcompositor_error {
+	/**
+	 * the to-be sub-surface is invalid
+	 */
+	WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE = 0,
+};
+#endif /* WL_SUBCOMPOSITOR_ERROR_ENUM */
+
+#define WL_SUBCOMPOSITOR_DESTROY 0
+#define WL_SUBCOMPOSITOR_GET_SUBSURFACE 1
+
+
+/**
+ * @ingroup iface_wl_subcompositor
+ */
+#define WL_SUBCOMPOSITOR_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_subcompositor
+ */
+#define WL_SUBCOMPOSITOR_GET_SUBSURFACE_SINCE_VERSION 1
+
+/** @ingroup iface_wl_subcompositor */
+static inline void
+wl_subcompositor_set_user_data(struct wl_subcompositor *wl_subcompositor, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_subcompositor, user_data);
+}
+
+/** @ingroup iface_wl_subcompositor */
+static inline void *
+wl_subcompositor_get_user_data(struct wl_subcompositor *wl_subcompositor)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_subcompositor);
+}
+
+static inline uint32_t
+wl_subcompositor_get_version(struct wl_subcompositor *wl_subcompositor)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_subcompositor);
+}
+
+/**
+ * @ingroup iface_wl_subcompositor
+ *
+ * Informs the server that the client will not be using this
+ * protocol object anymore. This does not affect any other
+ * objects, wl_subsurface objects included.
+ */
+static inline void
+wl_subcompositor_destroy(struct wl_subcompositor *wl_subcompositor)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_subcompositor,
+			 WL_SUBCOMPOSITOR_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_subcompositor);
+}
+
+/**
+ * @ingroup iface_wl_subcompositor
+ *
+ * Create a sub-surface interface for the given surface, and
+ * associate it with the given parent surface. This turns a
+ * plain wl_surface into a sub-surface.
+ *
+ * The to-be sub-surface must not already have another role, and it
+ * must not have an existing wl_subsurface object. Otherwise a protocol
+ * error is raised.
+ *
+ * Adding sub-surfaces to a parent is a double-buffered operation on the
+ * parent (see wl_surface.commit). The effect of adding a sub-surface
+ * becomes visible on the next time the state of the parent surface is
+ * applied.
+ *
+ * This request modifies the behaviour of wl_surface.commit request on
+ * the sub-surface, see the documentation on wl_subsurface interface.
+ */
+static inline struct wl_subsurface *
+wl_subcompositor_get_subsurface(struct wl_subcompositor *wl_subcompositor, struct wl_surface *surface, struct wl_surface *parent)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) wl_subcompositor,
+			 WL_SUBCOMPOSITOR_GET_SUBSURFACE, &wl_subsurface_interface, NULL, surface, parent);
+
+	return (struct wl_subsurface *) id;
+}
+
+#ifndef WL_SUBSURFACE_ERROR_ENUM
+#define WL_SUBSURFACE_ERROR_ENUM
+enum wl_subsurface_error {
+	/**
+	 * wl_surface is not a sibling or the parent
+	 */
+	WL_SUBSURFACE_ERROR_BAD_SURFACE = 0,
+};
+#endif /* WL_SUBSURFACE_ERROR_ENUM */
+
+#define WL_SUBSURFACE_DESTROY 0
+#define WL_SUBSURFACE_SET_POSITION 1
+#define WL_SUBSURFACE_PLACE_ABOVE 2
+#define WL_SUBSURFACE_PLACE_BELOW 3
+#define WL_SUBSURFACE_SET_SYNC 4
+#define WL_SUBSURFACE_SET_DESYNC 5
+
+
+/**
+ * @ingroup iface_wl_subsurface
+ */
+#define WL_SUBSURFACE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_subsurface
+ */
+#define WL_SUBSURFACE_SET_POSITION_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_subsurface
+ */
+#define WL_SUBSURFACE_PLACE_ABOVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_subsurface
+ */
+#define WL_SUBSURFACE_PLACE_BELOW_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_subsurface
+ */
+#define WL_SUBSURFACE_SET_SYNC_SINCE_VERSION 1
+/**
+ * @ingroup iface_wl_subsurface
+ */
+#define WL_SUBSURFACE_SET_DESYNC_SINCE_VERSION 1
+
+/** @ingroup iface_wl_subsurface */
+static inline void
+wl_subsurface_set_user_data(struct wl_subsurface *wl_subsurface, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) wl_subsurface, user_data);
+}
+
+/** @ingroup iface_wl_subsurface */
+static inline void *
+wl_subsurface_get_user_data(struct wl_subsurface *wl_subsurface)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) wl_subsurface);
+}
+
+static inline uint32_t
+wl_subsurface_get_version(struct wl_subsurface *wl_subsurface)
+{
+	return wl_proxy_get_version((struct wl_proxy *) wl_subsurface);
+}
+
+/**
+ * @ingroup iface_wl_subsurface
+ *
+ * The sub-surface interface is removed from the wl_surface object
+ * that was turned into a sub-surface with a
+ * wl_subcompositor.get_subsurface request. The wl_surface's association
+ * to the parent is deleted, and the wl_surface loses its role as
+ * a sub-surface. The wl_surface is unmapped immediately.
+ */
+static inline void
+wl_subsurface_destroy(struct wl_subsurface *wl_subsurface)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_subsurface,
+			 WL_SUBSURFACE_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) wl_subsurface);
+}
+
+/**
+ * @ingroup iface_wl_subsurface
+ *
+ * This schedules a sub-surface position change.
+ * The sub-surface will be moved so that its origin (top left
+ * corner pixel) will be at the location x, y of the parent surface
+ * coordinate system. The coordinates are not restricted to the parent
+ * surface area. Negative values are allowed.
+ *
+ * The scheduled coordinates will take effect whenever the state of the
+ * parent surface is applied. When this happens depends on whether the
+ * parent surface is in synchronized mode or not. See
+ * wl_subsurface.set_sync and wl_subsurface.set_desync for details.
+ *
+ * If more than one set_position request is invoked by the client before
+ * the commit of the parent surface, the position of a new request always
+ * replaces the scheduled position from any previous request.
+ *
+ * The initial position is 0, 0.
+ */
+static inline void
+wl_subsurface_set_position(struct wl_subsurface *wl_subsurface, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_subsurface,
+			 WL_SUBSURFACE_SET_POSITION, x, y);
+}
+
+/**
+ * @ingroup iface_wl_subsurface
+ *
+ * This sub-surface is taken from the stack, and put back just
+ * above the reference surface, changing the z-order of the sub-surfaces.
+ * The reference surface must be one of the sibling surfaces, or the
+ * parent surface. Using any other surface, including this sub-surface,
+ * will cause a protocol error.
+ *
+ * The z-order is double-buffered. Requests are handled in order and
+ * applied immediately to a pending state. The final pending state is
+ * copied to the active state the next time the state of the parent
+ * surface is applied. When this happens depends on whether the parent
+ * surface is in synchronized mode or not. See wl_subsurface.set_sync and
+ * wl_subsurface.set_desync for details.
+ *
+ * A new sub-surface is initially added as the top-most in the stack
+ * of its siblings and parent.
+ */
+static inline void
+wl_subsurface_place_above(struct wl_subsurface *wl_subsurface, struct wl_surface *sibling)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_subsurface,
+			 WL_SUBSURFACE_PLACE_ABOVE, sibling);
+}
+
+/**
+ * @ingroup iface_wl_subsurface
+ *
+ * The sub-surface is placed just below the reference surface.
+ * See wl_subsurface.place_above.
+ */
+static inline void
+wl_subsurface_place_below(struct wl_subsurface *wl_subsurface, struct wl_surface *sibling)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_subsurface,
+			 WL_SUBSURFACE_PLACE_BELOW, sibling);
+}
+
+/**
+ * @ingroup iface_wl_subsurface
+ *
+ * Change the commit behaviour of the sub-surface to synchronized
+ * mode, also described as the parent dependent mode.
+ *
+ * In synchronized mode, wl_surface.commit on a sub-surface will
+ * accumulate the committed state in a cache, but the state will
+ * not be applied and hence will not change the compositor output.
+ * The cached state is applied to the sub-surface immediately after
+ * the parent surface's state is applied. This ensures atomic
+ * updates of the parent and all its synchronized sub-surfaces.
+ * Applying the cached state will invalidate the cache, so further
+ * parent surface commits do not (re-)apply old state.
+ *
+ * See wl_subsurface for the recursive effect of this mode.
+ */
+static inline void
+wl_subsurface_set_sync(struct wl_subsurface *wl_subsurface)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_subsurface,
+			 WL_SUBSURFACE_SET_SYNC);
+}
+
+/**
+ * @ingroup iface_wl_subsurface
+ *
+ * Change the commit behaviour of the sub-surface to desynchronized
+ * mode, also described as independent or freely running mode.
+ *
+ * In desynchronized mode, wl_surface.commit on a sub-surface will
+ * apply the pending state directly, without caching, as happens
+ * normally with a wl_surface. Calling wl_surface.commit on the
+ * parent surface has no effect on the sub-surface's wl_surface
+ * state. This mode allows a sub-surface to be updated on its own.
+ *
+ * If cached state exists when wl_surface.commit is called in
+ * desynchronized mode, the pending state is added to the cached
+ * state, and applied as a whole. This invalidates the cache.
+ *
+ * Note: even if a sub-surface is set to desynchronized, a parent
+ * sub-surface may override it to behave as synchronized. For details,
+ * see wl_subsurface.
+ *
+ * If a surface's parent surface behaves as desynchronized, then
+ * the cached state is applied on set_desync.
+ */
+static inline void
+wl_subsurface_set_desync(struct wl_subsurface *wl_subsurface)
+{
+	wl_proxy_marshal((struct wl_proxy *) wl_subsurface,
+			 WL_SUBSURFACE_SET_DESYNC);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-wayland-protocol.c b/src/client/wayland-wayland-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..5f322641c7305cd5cb8cadd1b5243b0068c2e81a
--- /dev/null
+++ a/qtwayland/src/client/wayland-wayland-protocol.c
@@ -0,0 +1,507 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2010-2011 Intel Corporation
+ * Copyright © 2012-2013 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_buffer_interface;
+extern const struct wl_interface wl_callback_interface;
+extern const struct wl_interface wl_data_device_interface;
+extern const struct wl_interface wl_data_offer_interface;
+extern const struct wl_interface wl_data_source_interface;
+extern const struct wl_interface wl_keyboard_interface;
+extern const struct wl_interface wl_output_interface;
+extern const struct wl_interface wl_pointer_interface;
+extern const struct wl_interface wl_region_interface;
+extern const struct wl_interface wl_registry_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_shell_surface_interface;
+extern const struct wl_interface wl_shm_pool_interface;
+extern const struct wl_interface wl_subsurface_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface wl_touch_interface;
+
+static const struct wl_interface *wayland_types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&wl_callback_interface,
+	&wl_registry_interface,
+	&wl_surface_interface,
+	&wl_region_interface,
+	&wl_buffer_interface,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&wl_shm_pool_interface,
+	NULL,
+	NULL,
+	&wl_data_source_interface,
+	&wl_surface_interface,
+	&wl_surface_interface,
+	NULL,
+	&wl_data_source_interface,
+	NULL,
+	&wl_data_offer_interface,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	&wl_data_offer_interface,
+	&wl_data_offer_interface,
+	&wl_data_source_interface,
+	&wl_data_device_interface,
+	&wl_seat_interface,
+	&wl_shell_surface_interface,
+	&wl_surface_interface,
+	&wl_seat_interface,
+	NULL,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&wl_output_interface,
+	&wl_seat_interface,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	&wl_output_interface,
+	&wl_buffer_interface,
+	NULL,
+	NULL,
+	&wl_callback_interface,
+	&wl_region_interface,
+	&wl_region_interface,
+	&wl_output_interface,
+	&wl_output_interface,
+	&wl_pointer_interface,
+	&wl_keyboard_interface,
+	&wl_touch_interface,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	&wl_surface_interface,
+	NULL,
+	NULL,
+	NULL,
+	&wl_subsurface_interface,
+	&wl_surface_interface,
+	&wl_surface_interface,
+	&wl_surface_interface,
+	&wl_surface_interface,
+};
+
+static const struct wl_message wl_display_requests[] = {
+	{ "sync", "n", wayland_types + 8 },
+	{ "get_registry", "n", wayland_types + 9 },
+};
+
+static const struct wl_message wl_display_events[] = {
+	{ "error", "ous", wayland_types + 0 },
+	{ "delete_id", "u", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_display_interface = {
+	"wl_display", 1,
+	2, wl_display_requests,
+	2, wl_display_events,
+};
+
+static const struct wl_message wl_registry_requests[] = {
+	{ "bind", "usun", wayland_types + 0 },
+};
+
+static const struct wl_message wl_registry_events[] = {
+	{ "global", "usu", wayland_types + 0 },
+	{ "global_remove", "u", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_registry_interface = {
+	"wl_registry", 1,
+	1, wl_registry_requests,
+	2, wl_registry_events,
+};
+
+static const struct wl_message wl_callback_events[] = {
+	{ "done", "u", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_callback_interface = {
+	"wl_callback", 1,
+	0, NULL,
+	1, wl_callback_events,
+};
+
+static const struct wl_message wl_compositor_requests[] = {
+	{ "create_surface", "n", wayland_types + 10 },
+	{ "create_region", "n", wayland_types + 11 },
+};
+
+WL_EXPORT const struct wl_interface wl_compositor_interface = {
+	"wl_compositor", 4,
+	2, wl_compositor_requests,
+	0, NULL,
+};
+
+static const struct wl_message wl_shm_pool_requests[] = {
+	{ "create_buffer", "niiiiu", wayland_types + 12 },
+	{ "destroy", "", wayland_types + 0 },
+	{ "resize", "i", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_shm_pool_interface = {
+	"wl_shm_pool", 1,
+	3, wl_shm_pool_requests,
+	0, NULL,
+};
+
+static const struct wl_message wl_shm_requests[] = {
+	{ "create_pool", "nhi", wayland_types + 18 },
+};
+
+static const struct wl_message wl_shm_events[] = {
+	{ "format", "u", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_shm_interface = {
+	"wl_shm", 1,
+	1, wl_shm_requests,
+	1, wl_shm_events,
+};
+
+static const struct wl_message wl_buffer_requests[] = {
+	{ "destroy", "", wayland_types + 0 },
+};
+
+static const struct wl_message wl_buffer_events[] = {
+	{ "release", "", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_buffer_interface = {
+	"wl_buffer", 1,
+	1, wl_buffer_requests,
+	1, wl_buffer_events,
+};
+
+static const struct wl_message wl_data_offer_requests[] = {
+	{ "accept", "u?s", wayland_types + 0 },
+	{ "receive", "sh", wayland_types + 0 },
+	{ "destroy", "", wayland_types + 0 },
+	{ "finish", "3", wayland_types + 0 },
+	{ "set_actions", "3uu", wayland_types + 0 },
+};
+
+static const struct wl_message wl_data_offer_events[] = {
+	{ "offer", "s", wayland_types + 0 },
+	{ "source_actions", "3u", wayland_types + 0 },
+	{ "action", "3u", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_data_offer_interface = {
+	"wl_data_offer", 3,
+	5, wl_data_offer_requests,
+	3, wl_data_offer_events,
+};
+
+static const struct wl_message wl_data_source_requests[] = {
+	{ "offer", "s", wayland_types + 0 },
+	{ "destroy", "", wayland_types + 0 },
+	{ "set_actions", "3u", wayland_types + 0 },
+};
+
+static const struct wl_message wl_data_source_events[] = {
+	{ "target", "?s", wayland_types + 0 },
+	{ "send", "sh", wayland_types + 0 },
+	{ "cancelled", "", wayland_types + 0 },
+	{ "dnd_drop_performed", "3", wayland_types + 0 },
+	{ "dnd_finished", "3", wayland_types + 0 },
+	{ "action", "3u", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_data_source_interface = {
+	"wl_data_source", 3,
+	3, wl_data_source_requests,
+	6, wl_data_source_events,
+};
+
+static const struct wl_message wl_data_device_requests[] = {
+	{ "start_drag", "?oo?ou", wayland_types + 21 },
+	{ "set_selection", "?ou", wayland_types + 25 },
+	{ "release", "2", wayland_types + 0 },
+};
+
+static const struct wl_message wl_data_device_events[] = {
+	{ "data_offer", "n", wayland_types + 27 },
+	{ "enter", "uoff?o", wayland_types + 28 },
+	{ "leave", "", wayland_types + 0 },
+	{ "motion", "uff", wayland_types + 0 },
+	{ "drop", "", wayland_types + 0 },
+	{ "selection", "?o", wayland_types + 33 },
+};
+
+WL_EXPORT const struct wl_interface wl_data_device_interface = {
+	"wl_data_device", 3,
+	3, wl_data_device_requests,
+	6, wl_data_device_events,
+};
+
+static const struct wl_message wl_data_device_manager_requests[] = {
+	{ "create_data_source", "n", wayland_types + 34 },
+	{ "get_data_device", "no", wayland_types + 35 },
+};
+
+WL_EXPORT const struct wl_interface wl_data_device_manager_interface = {
+	"wl_data_device_manager", 3,
+	2, wl_data_device_manager_requests,
+	0, NULL,
+};
+
+static const struct wl_message wl_shell_requests[] = {
+	{ "get_shell_surface", "no", wayland_types + 37 },
+};
+
+WL_EXPORT const struct wl_interface wl_shell_interface = {
+	"wl_shell", 1,
+	1, wl_shell_requests,
+	0, NULL,
+};
+
+static const struct wl_message wl_shell_surface_requests[] = {
+	{ "pong", "u", wayland_types + 0 },
+	{ "move", "ou", wayland_types + 39 },
+	{ "resize", "ouu", wayland_types + 41 },
+	{ "set_toplevel", "", wayland_types + 0 },
+	{ "set_transient", "oiiu", wayland_types + 44 },
+	{ "set_fullscreen", "uu?o", wayland_types + 48 },
+	{ "set_popup", "ouoiiu", wayland_types + 51 },
+	{ "set_maximized", "?o", wayland_types + 57 },
+	{ "set_title", "s", wayland_types + 0 },
+	{ "set_class", "s", wayland_types + 0 },
+};
+
+static const struct wl_message wl_shell_surface_events[] = {
+	{ "ping", "u", wayland_types + 0 },
+	{ "configure", "uii", wayland_types + 0 },
+	{ "popup_done", "", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_shell_surface_interface = {
+	"wl_shell_surface", 1,
+	10, wl_shell_surface_requests,
+	3, wl_shell_surface_events,
+};
+
+static const struct wl_message wl_surface_requests[] = {
+	{ "destroy", "", wayland_types + 0 },
+	{ "attach", "?oii", wayland_types + 58 },
+	{ "damage", "iiii", wayland_types + 0 },
+	{ "frame", "n", wayland_types + 61 },
+	{ "set_opaque_region", "?o", wayland_types + 62 },
+	{ "set_input_region", "?o", wayland_types + 63 },
+	{ "commit", "", wayland_types + 0 },
+	{ "set_buffer_transform", "2i", wayland_types + 0 },
+	{ "set_buffer_scale", "3i", wayland_types + 0 },
+	{ "damage_buffer", "4iiii", wayland_types + 0 },
+};
+
+static const struct wl_message wl_surface_events[] = {
+	{ "enter", "o", wayland_types + 64 },
+	{ "leave", "o", wayland_types + 65 },
+};
+
+WL_EXPORT const struct wl_interface wl_surface_interface = {
+	"wl_surface", 4,
+	10, wl_surface_requests,
+	2, wl_surface_events,
+};
+
+static const struct wl_message wl_seat_requests[] = {
+	{ "get_pointer", "n", wayland_types + 66 },
+	{ "get_keyboard", "n", wayland_types + 67 },
+	{ "get_touch", "n", wayland_types + 68 },
+	{ "release", "5", wayland_types + 0 },
+};
+
+static const struct wl_message wl_seat_events[] = {
+	{ "capabilities", "u", wayland_types + 0 },
+	{ "name", "2s", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_seat_interface = {
+	"wl_seat", 6,
+	4, wl_seat_requests,
+	2, wl_seat_events,
+};
+
+static const struct wl_message wl_pointer_requests[] = {
+	{ "set_cursor", "u?oii", wayland_types + 69 },
+	{ "release", "3", wayland_types + 0 },
+};
+
+static const struct wl_message wl_pointer_events[] = {
+	{ "enter", "uoff", wayland_types + 73 },
+	{ "leave", "uo", wayland_types + 77 },
+	{ "motion", "uff", wayland_types + 0 },
+	{ "button", "uuuu", wayland_types + 0 },
+	{ "axis", "uuf", wayland_types + 0 },
+	{ "frame", "5", wayland_types + 0 },
+	{ "axis_source", "5u", wayland_types + 0 },
+	{ "axis_stop", "5uu", wayland_types + 0 },
+	{ "axis_discrete", "5ui", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_pointer_interface = {
+	"wl_pointer", 6,
+	2, wl_pointer_requests,
+	9, wl_pointer_events,
+};
+
+static const struct wl_message wl_keyboard_requests[] = {
+	{ "release", "3", wayland_types + 0 },
+};
+
+static const struct wl_message wl_keyboard_events[] = {
+	{ "keymap", "uhu", wayland_types + 0 },
+	{ "enter", "uoa", wayland_types + 79 },
+	{ "leave", "uo", wayland_types + 82 },
+	{ "key", "uuuu", wayland_types + 0 },
+	{ "modifiers", "uuuuu", wayland_types + 0 },
+	{ "repeat_info", "4ii", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_keyboard_interface = {
+	"wl_keyboard", 6,
+	1, wl_keyboard_requests,
+	6, wl_keyboard_events,
+};
+
+static const struct wl_message wl_touch_requests[] = {
+	{ "release", "3", wayland_types + 0 },
+};
+
+static const struct wl_message wl_touch_events[] = {
+	{ "down", "uuoiff", wayland_types + 84 },
+	{ "up", "uui", wayland_types + 0 },
+	{ "motion", "uiff", wayland_types + 0 },
+	{ "frame", "", wayland_types + 0 },
+	{ "cancel", "", wayland_types + 0 },
+	{ "shape", "6iff", wayland_types + 0 },
+	{ "orientation", "6if", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_touch_interface = {
+	"wl_touch", 6,
+	1, wl_touch_requests,
+	7, wl_touch_events,
+};
+
+static const struct wl_message wl_output_requests[] = {
+	{ "release", "3", wayland_types + 0 },
+};
+
+static const struct wl_message wl_output_events[] = {
+	{ "geometry", "iiiiissi", wayland_types + 0 },
+	{ "mode", "uiii", wayland_types + 0 },
+	{ "done", "2", wayland_types + 0 },
+	{ "scale", "2i", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_output_interface = {
+	"wl_output", 3,
+	1, wl_output_requests,
+	4, wl_output_events,
+};
+
+static const struct wl_message wl_region_requests[] = {
+	{ "destroy", "", wayland_types + 0 },
+	{ "add", "iiii", wayland_types + 0 },
+	{ "subtract", "iiii", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_region_interface = {
+	"wl_region", 1,
+	3, wl_region_requests,
+	0, NULL,
+};
+
+static const struct wl_message wl_subcompositor_requests[] = {
+	{ "destroy", "", wayland_types + 0 },
+	{ "get_subsurface", "noo", wayland_types + 90 },
+};
+
+WL_EXPORT const struct wl_interface wl_subcompositor_interface = {
+	"wl_subcompositor", 1,
+	2, wl_subcompositor_requests,
+	0, NULL,
+};
+
+static const struct wl_message wl_subsurface_requests[] = {
+	{ "destroy", "", wayland_types + 0 },
+	{ "set_position", "ii", wayland_types + 0 },
+	{ "place_above", "o", wayland_types + 93 },
+	{ "place_below", "o", wayland_types + 94 },
+	{ "set_sync", "", wayland_types + 0 },
+	{ "set_desync", "", wayland_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface wl_subsurface_interface = {
+	"wl_subsurface", 1,
+	6, wl_subsurface_requests,
+	0, NULL,
+};
+
diff --git a/src/client/wayland-wp-primary-selection-unstable-v1-client-protocol.h b/src/client/wayland-wp-primary-selection-unstable-v1-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..0030ae41f7b7e03c1ef78434a77bb8d70ba110d5
--- /dev/null
+++ a/qtwayland/src/client/wayland-wp-primary-selection-unstable-v1-client-protocol.h
@@ -0,0 +1,590 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef WP_PRIMARY_SELECTION_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define WP_PRIMARY_SELECTION_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_wp_primary_selection_unstable_v1 The wp_primary_selection_unstable_v1 protocol
+ * Primary selection protocol
+ *
+ * @section page_desc_wp_primary_selection_unstable_v1 Description
+ *
+ * This protocol provides the ability to have a primary selection device to
+ * match that of the X server. This primary selection is a shortcut to the
+ * common clipboard selection, where text just needs to be selected in order
+ * to allow copying it elsewhere. The de facto way to perform this action
+ * is the middle mouse button, although it is not limited to this one.
+ *
+ * Clients wishing to honor primary selection should create a primary
+ * selection source and set it as the selection through
+ * wp_primary_selection_device.set_selection whenever the text selection
+ * changes. In order to minimize calls in pointer-driven text selection,
+ * it should happen only once after the operation finished. Similarly,
+ * a NULL source should be set when text is unselected.
+ *
+ * wp_primary_selection_offer objects are first announced through the
+ * wp_primary_selection_device.data_offer event. Immediately after this event,
+ * the primary data offer will emit wp_primary_selection_offer.offer events
+ * to let know of the mime types being offered.
+ *
+ * When the primary selection changes, the client with the keyboard focus
+ * will receive wp_primary_selection_device.selection events. Only the client
+ * with the keyboard focus will receive such events with a non-NULL
+ * wp_primary_selection_offer. Across keyboard focus changes, previously
+ * focused clients will receive wp_primary_selection_device.events with a
+ * NULL wp_primary_selection_offer.
+ *
+ * In order to request the primary selection data, the client must pass
+ * a recent serial pertaining to the press event that is triggering the
+ * operation, if the compositor deems the serial valid and recent, the
+ * wp_primary_selection_source.send event will happen in the other end
+ * to let the transfer begin. The client owning the primary selection
+ * should write the requested data, and close the file descriptor
+ * immediately.
+ *
+ * If the primary selection owner client disappeared during the transfer,
+ * the client reading the data will receive a
+ * wp_primary_selection_device.selection event with a NULL
+ * wp_primary_selection_offer, the client should take this as a hint
+ * to finish the reads related to the no longer existing offer.
+ *
+ * The primary selection owner should be checking for errors during
+ * writes, merely cancelling the ongoing transfer if any happened.
+ *
+ * @section page_ifaces_wp_primary_selection_unstable_v1 Interfaces
+ * - @subpage page_iface_zwp_primary_selection_device_manager_v1 - X primary selection emulation
+ * - @subpage page_iface_zwp_primary_selection_device_v1 - 
+ * - @subpage page_iface_zwp_primary_selection_offer_v1 - offer to transfer primary selection contents
+ * - @subpage page_iface_zwp_primary_selection_source_v1 - offer to replace the contents of the primary selection
+ * @section page_copyright_wp_primary_selection_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright © 2015, 2016 Red Hat
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_seat;
+struct zwp_primary_selection_device_manager_v1;
+struct zwp_primary_selection_device_v1;
+struct zwp_primary_selection_offer_v1;
+struct zwp_primary_selection_source_v1;
+
+#ifndef ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_INTERFACE
+#define ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_INTERFACE
+/**
+ * @page page_iface_zwp_primary_selection_device_manager_v1 zwp_primary_selection_device_manager_v1
+ * @section page_iface_zwp_primary_selection_device_manager_v1_desc Description
+ *
+ * The primary selection device manager is a singleton global object that
+ * provides access to the primary selection. It allows to create
+ * wp_primary_selection_source objects, as well as retrieving the per-seat
+ * wp_primary_selection_device objects.
+ * @section page_iface_zwp_primary_selection_device_manager_v1_api API
+ * See @ref iface_zwp_primary_selection_device_manager_v1.
+ */
+/**
+ * @defgroup iface_zwp_primary_selection_device_manager_v1 The zwp_primary_selection_device_manager_v1 interface
+ *
+ * The primary selection device manager is a singleton global object that
+ * provides access to the primary selection. It allows to create
+ * wp_primary_selection_source objects, as well as retrieving the per-seat
+ * wp_primary_selection_device objects.
+ */
+extern const struct wl_interface zwp_primary_selection_device_manager_v1_interface;
+#endif
+#ifndef ZWP_PRIMARY_SELECTION_DEVICE_V1_INTERFACE
+#define ZWP_PRIMARY_SELECTION_DEVICE_V1_INTERFACE
+/**
+ * @page page_iface_zwp_primary_selection_device_v1 zwp_primary_selection_device_v1
+ * @section page_iface_zwp_primary_selection_device_v1_api API
+ * See @ref iface_zwp_primary_selection_device_v1.
+ */
+/**
+ * @defgroup iface_zwp_primary_selection_device_v1 The zwp_primary_selection_device_v1 interface
+ */
+extern const struct wl_interface zwp_primary_selection_device_v1_interface;
+#endif
+#ifndef ZWP_PRIMARY_SELECTION_OFFER_V1_INTERFACE
+#define ZWP_PRIMARY_SELECTION_OFFER_V1_INTERFACE
+/**
+ * @page page_iface_zwp_primary_selection_offer_v1 zwp_primary_selection_offer_v1
+ * @section page_iface_zwp_primary_selection_offer_v1_desc Description
+ *
+ * A wp_primary_selection_offer represents an offer to transfer the contents
+ * of the primary selection clipboard to the client. Similar to
+ * wl_data_offer, the offer also describes the mime types that the data can
+ * be converted to and provides the mechanisms for transferring the data
+ * directly to the client.
+ * @section page_iface_zwp_primary_selection_offer_v1_api API
+ * See @ref iface_zwp_primary_selection_offer_v1.
+ */
+/**
+ * @defgroup iface_zwp_primary_selection_offer_v1 The zwp_primary_selection_offer_v1 interface
+ *
+ * A wp_primary_selection_offer represents an offer to transfer the contents
+ * of the primary selection clipboard to the client. Similar to
+ * wl_data_offer, the offer also describes the mime types that the data can
+ * be converted to and provides the mechanisms for transferring the data
+ * directly to the client.
+ */
+extern const struct wl_interface zwp_primary_selection_offer_v1_interface;
+#endif
+#ifndef ZWP_PRIMARY_SELECTION_SOURCE_V1_INTERFACE
+#define ZWP_PRIMARY_SELECTION_SOURCE_V1_INTERFACE
+/**
+ * @page page_iface_zwp_primary_selection_source_v1 zwp_primary_selection_source_v1
+ * @section page_iface_zwp_primary_selection_source_v1_desc Description
+ *
+ * The source side of a wp_primary_selection_offer, it provides a way to
+ * describe the offered data and respond to requests to transfer the
+ * requested contents of the primary selection clipboard.
+ * @section page_iface_zwp_primary_selection_source_v1_api API
+ * See @ref iface_zwp_primary_selection_source_v1.
+ */
+/**
+ * @defgroup iface_zwp_primary_selection_source_v1 The zwp_primary_selection_source_v1 interface
+ *
+ * The source side of a wp_primary_selection_offer, it provides a way to
+ * describe the offered data and respond to requests to transfer the
+ * requested contents of the primary selection clipboard.
+ */
+extern const struct wl_interface zwp_primary_selection_source_v1_interface;
+#endif
+
+#define ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_CREATE_SOURCE 0
+#define ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_GET_DEVICE 1
+#define ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_DESTROY 2
+
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_manager_v1
+ */
+#define ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_CREATE_SOURCE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_primary_selection_device_manager_v1
+ */
+#define ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_GET_DEVICE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_primary_selection_device_manager_v1
+ */
+#define ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_primary_selection_device_manager_v1 */
+static inline void
+zwp_primary_selection_device_manager_v1_set_user_data(struct zwp_primary_selection_device_manager_v1 *zwp_primary_selection_device_manager_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_primary_selection_device_manager_v1, user_data);
+}
+
+/** @ingroup iface_zwp_primary_selection_device_manager_v1 */
+static inline void *
+zwp_primary_selection_device_manager_v1_get_user_data(struct zwp_primary_selection_device_manager_v1 *zwp_primary_selection_device_manager_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_primary_selection_device_manager_v1);
+}
+
+static inline uint32_t
+zwp_primary_selection_device_manager_v1_get_version(struct zwp_primary_selection_device_manager_v1 *zwp_primary_selection_device_manager_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_primary_selection_device_manager_v1);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_manager_v1
+ *
+ * Create a new primary selection source.
+ */
+static inline struct zwp_primary_selection_source_v1 *
+zwp_primary_selection_device_manager_v1_create_source(struct zwp_primary_selection_device_manager_v1 *zwp_primary_selection_device_manager_v1)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_primary_selection_device_manager_v1,
+			 ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_CREATE_SOURCE, &zwp_primary_selection_source_v1_interface, NULL);
+
+	return (struct zwp_primary_selection_source_v1 *) id;
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_manager_v1
+ *
+ * Create a new data device for a given seat.
+ */
+static inline struct zwp_primary_selection_device_v1 *
+zwp_primary_selection_device_manager_v1_get_device(struct zwp_primary_selection_device_manager_v1 *zwp_primary_selection_device_manager_v1, struct wl_seat *seat)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zwp_primary_selection_device_manager_v1,
+			 ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_GET_DEVICE, &zwp_primary_selection_device_v1_interface, NULL, seat);
+
+	return (struct zwp_primary_selection_device_v1 *) id;
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_manager_v1
+ *
+ * Destroy the primary selection device manager.
+ */
+static inline void
+zwp_primary_selection_device_manager_v1_destroy(struct zwp_primary_selection_device_manager_v1 *zwp_primary_selection_device_manager_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_primary_selection_device_manager_v1,
+			 ZWP_PRIMARY_SELECTION_DEVICE_MANAGER_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_primary_selection_device_manager_v1);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_v1
+ * @struct zwp_primary_selection_device_v1_listener
+ */
+struct zwp_primary_selection_device_v1_listener {
+	/**
+	 * introduce a new wp_primary_selection_offer
+	 *
+	 * Introduces a new wp_primary_selection_offer object that may be
+	 * used to receive the current primary selection. Immediately
+	 * following this event, the new wp_primary_selection_offer object
+	 * will send wp_primary_selection_offer.offer events to describe
+	 * the offered mime types.
+	 */
+	void (*data_offer)(void *data,
+			   struct zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1,
+			   struct zwp_primary_selection_offer_v1 *offer);
+	/**
+	 * advertise a new primary selection
+	 *
+	 * The wp_primary_selection_device.selection event is sent to
+	 * notify the client of a new primary selection. This event is sent
+	 * after the wp_primary_selection.data_offer event introducing this
+	 * object, and after the offer has announced its mimetypes through
+	 * wp_primary_selection_offer.offer.
+	 *
+	 * The data_offer is valid until a new offer or NULL is received or
+	 * until the client loses keyboard focus. The client must destroy
+	 * the previous selection data_offer, if any, upon receiving this
+	 * event.
+	 */
+	void (*selection)(void *data,
+			  struct zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1,
+			  struct zwp_primary_selection_offer_v1 *id);
+};
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_v1
+ */
+static inline int
+zwp_primary_selection_device_v1_add_listener(struct zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1,
+					     const struct zwp_primary_selection_device_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_primary_selection_device_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_PRIMARY_SELECTION_DEVICE_V1_SET_SELECTION 0
+#define ZWP_PRIMARY_SELECTION_DEVICE_V1_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_v1
+ */
+#define ZWP_PRIMARY_SELECTION_DEVICE_V1_DATA_OFFER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_primary_selection_device_v1
+ */
+#define ZWP_PRIMARY_SELECTION_DEVICE_V1_SELECTION_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_v1
+ */
+#define ZWP_PRIMARY_SELECTION_DEVICE_V1_SET_SELECTION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_primary_selection_device_v1
+ */
+#define ZWP_PRIMARY_SELECTION_DEVICE_V1_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_primary_selection_device_v1 */
+static inline void
+zwp_primary_selection_device_v1_set_user_data(struct zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_primary_selection_device_v1, user_data);
+}
+
+/** @ingroup iface_zwp_primary_selection_device_v1 */
+static inline void *
+zwp_primary_selection_device_v1_get_user_data(struct zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_primary_selection_device_v1);
+}
+
+static inline uint32_t
+zwp_primary_selection_device_v1_get_version(struct zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_primary_selection_device_v1);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_v1
+ *
+ * Replaces the current selection. The previous owner of the primary
+ * selection will receive a wp_primary_selection_source.cancelled event.
+ *
+ * To unset the selection, set the source to NULL.
+ */
+static inline void
+zwp_primary_selection_device_v1_set_selection(struct zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1, struct zwp_primary_selection_source_v1 *source, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_primary_selection_device_v1,
+			 ZWP_PRIMARY_SELECTION_DEVICE_V1_SET_SELECTION, source, serial);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_device_v1
+ *
+ * Destroy the primary selection device.
+ */
+static inline void
+zwp_primary_selection_device_v1_destroy(struct zwp_primary_selection_device_v1 *zwp_primary_selection_device_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_primary_selection_device_v1,
+			 ZWP_PRIMARY_SELECTION_DEVICE_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_primary_selection_device_v1);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_offer_v1
+ * @struct zwp_primary_selection_offer_v1_listener
+ */
+struct zwp_primary_selection_offer_v1_listener {
+	/**
+	 * advertise offered mime type
+	 *
+	 * Sent immediately after creating announcing the
+	 * wp_primary_selection_offer through
+	 * wp_primary_selection_device.data_offer. One event is sent per
+	 * offered mime type.
+	 */
+	void (*offer)(void *data,
+		      struct zwp_primary_selection_offer_v1 *zwp_primary_selection_offer_v1,
+		      const char *mime_type);
+};
+
+/**
+ * @ingroup iface_zwp_primary_selection_offer_v1
+ */
+static inline int
+zwp_primary_selection_offer_v1_add_listener(struct zwp_primary_selection_offer_v1 *zwp_primary_selection_offer_v1,
+					    const struct zwp_primary_selection_offer_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_primary_selection_offer_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_PRIMARY_SELECTION_OFFER_V1_RECEIVE 0
+#define ZWP_PRIMARY_SELECTION_OFFER_V1_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_primary_selection_offer_v1
+ */
+#define ZWP_PRIMARY_SELECTION_OFFER_V1_OFFER_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_primary_selection_offer_v1
+ */
+#define ZWP_PRIMARY_SELECTION_OFFER_V1_RECEIVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_primary_selection_offer_v1
+ */
+#define ZWP_PRIMARY_SELECTION_OFFER_V1_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_primary_selection_offer_v1 */
+static inline void
+zwp_primary_selection_offer_v1_set_user_data(struct zwp_primary_selection_offer_v1 *zwp_primary_selection_offer_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_primary_selection_offer_v1, user_data);
+}
+
+/** @ingroup iface_zwp_primary_selection_offer_v1 */
+static inline void *
+zwp_primary_selection_offer_v1_get_user_data(struct zwp_primary_selection_offer_v1 *zwp_primary_selection_offer_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_primary_selection_offer_v1);
+}
+
+static inline uint32_t
+zwp_primary_selection_offer_v1_get_version(struct zwp_primary_selection_offer_v1 *zwp_primary_selection_offer_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_primary_selection_offer_v1);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_offer_v1
+ *
+ * To transfer the contents of the primary selection clipboard, the client
+ * issues this request and indicates the mime type that it wants to
+ * receive. The transfer happens through the passed file descriptor
+ * (typically created with the pipe system call). The source client writes
+ * the data in the mime type representation requested and then closes the
+ * file descriptor.
+ *
+ * The receiving client reads from the read end of the pipe until EOF and
+ * closes its end, at which point the transfer is complete.
+ */
+static inline void
+zwp_primary_selection_offer_v1_receive(struct zwp_primary_selection_offer_v1 *zwp_primary_selection_offer_v1, const char *mime_type, int32_t fd)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_primary_selection_offer_v1,
+			 ZWP_PRIMARY_SELECTION_OFFER_V1_RECEIVE, mime_type, fd);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_offer_v1
+ *
+ * Destroy the primary selection offer.
+ */
+static inline void
+zwp_primary_selection_offer_v1_destroy(struct zwp_primary_selection_offer_v1 *zwp_primary_selection_offer_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_primary_selection_offer_v1,
+			 ZWP_PRIMARY_SELECTION_OFFER_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_primary_selection_offer_v1);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_source_v1
+ * @struct zwp_primary_selection_source_v1_listener
+ */
+struct zwp_primary_selection_source_v1_listener {
+	/**
+	 * send the primary selection contents
+	 *
+	 * Request for the current primary selection contents from the
+	 * client. Send the specified mime type over the passed file
+	 * descriptor, then close it.
+	 */
+	void (*send)(void *data,
+		     struct zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1,
+		     const char *mime_type,
+		     int32_t fd);
+	/**
+	 * request for primary selection contents was canceled
+	 *
+	 * This primary selection source is no longer valid. The client
+	 * should clean up and destroy this primary selection source.
+	 */
+	void (*cancelled)(void *data,
+			  struct zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1);
+};
+
+/**
+ * @ingroup iface_zwp_primary_selection_source_v1
+ */
+static inline int
+zwp_primary_selection_source_v1_add_listener(struct zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1,
+					     const struct zwp_primary_selection_source_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zwp_primary_selection_source_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZWP_PRIMARY_SELECTION_SOURCE_V1_OFFER 0
+#define ZWP_PRIMARY_SELECTION_SOURCE_V1_DESTROY 1
+
+/**
+ * @ingroup iface_zwp_primary_selection_source_v1
+ */
+#define ZWP_PRIMARY_SELECTION_SOURCE_V1_SEND_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_primary_selection_source_v1
+ */
+#define ZWP_PRIMARY_SELECTION_SOURCE_V1_CANCELLED_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zwp_primary_selection_source_v1
+ */
+#define ZWP_PRIMARY_SELECTION_SOURCE_V1_OFFER_SINCE_VERSION 1
+/**
+ * @ingroup iface_zwp_primary_selection_source_v1
+ */
+#define ZWP_PRIMARY_SELECTION_SOURCE_V1_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zwp_primary_selection_source_v1 */
+static inline void
+zwp_primary_selection_source_v1_set_user_data(struct zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zwp_primary_selection_source_v1, user_data);
+}
+
+/** @ingroup iface_zwp_primary_selection_source_v1 */
+static inline void *
+zwp_primary_selection_source_v1_get_user_data(struct zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zwp_primary_selection_source_v1);
+}
+
+static inline uint32_t
+zwp_primary_selection_source_v1_get_version(struct zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zwp_primary_selection_source_v1);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_source_v1
+ *
+ * This request adds a mime type to the set of mime types advertised to
+ * targets. Can be called several times to offer multiple types.
+ */
+static inline void
+zwp_primary_selection_source_v1_offer(struct zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1, const char *mime_type)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_primary_selection_source_v1,
+			 ZWP_PRIMARY_SELECTION_SOURCE_V1_OFFER, mime_type);
+}
+
+/**
+ * @ingroup iface_zwp_primary_selection_source_v1
+ *
+ * Destroy the primary selection source.
+ */
+static inline void
+zwp_primary_selection_source_v1_destroy(struct zwp_primary_selection_source_v1 *zwp_primary_selection_source_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zwp_primary_selection_source_v1,
+			 ZWP_PRIMARY_SELECTION_SOURCE_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zwp_primary_selection_source_v1);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-wp-primary-selection-unstable-v1-protocol.c b/src/client/wayland-wp-primary-selection-unstable-v1-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..fbc080e88014007a80a84c66b3125c01ba63e874
--- /dev/null
+++ a/qtwayland/src/client/wayland-wp-primary-selection-unstable-v1-protocol.c
@@ -0,0 +1,105 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright © 2015, 2016 Red Hat
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface zwp_primary_selection_device_v1_interface;
+extern const struct wl_interface zwp_primary_selection_offer_v1_interface;
+extern const struct wl_interface zwp_primary_selection_source_v1_interface;
+
+static const struct wl_interface *wp_primary_selection_unstable_v1_types[] = {
+	NULL,
+	NULL,
+	&zwp_primary_selection_source_v1_interface,
+	&zwp_primary_selection_device_v1_interface,
+	&wl_seat_interface,
+	&zwp_primary_selection_source_v1_interface,
+	NULL,
+	&zwp_primary_selection_offer_v1_interface,
+	&zwp_primary_selection_offer_v1_interface,
+};
+
+static const struct wl_message zwp_primary_selection_device_manager_v1_requests[] = {
+	{ "create_source", "n", wp_primary_selection_unstable_v1_types + 2 },
+	{ "get_device", "no", wp_primary_selection_unstable_v1_types + 3 },
+	{ "destroy", "", wp_primary_selection_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_primary_selection_device_manager_v1_interface = {
+	"zwp_primary_selection_device_manager_v1", 1,
+	3, zwp_primary_selection_device_manager_v1_requests,
+	0, NULL,
+};
+
+static const struct wl_message zwp_primary_selection_device_v1_requests[] = {
+	{ "set_selection", "?ou", wp_primary_selection_unstable_v1_types + 5 },
+	{ "destroy", "", wp_primary_selection_unstable_v1_types + 0 },
+};
+
+static const struct wl_message zwp_primary_selection_device_v1_events[] = {
+	{ "data_offer", "n", wp_primary_selection_unstable_v1_types + 7 },
+	{ "selection", "?o", wp_primary_selection_unstable_v1_types + 8 },
+};
+
+WL_EXPORT const struct wl_interface zwp_primary_selection_device_v1_interface = {
+	"zwp_primary_selection_device_v1", 1,
+	2, zwp_primary_selection_device_v1_requests,
+	2, zwp_primary_selection_device_v1_events,
+};
+
+static const struct wl_message zwp_primary_selection_offer_v1_requests[] = {
+	{ "receive", "sh", wp_primary_selection_unstable_v1_types + 0 },
+	{ "destroy", "", wp_primary_selection_unstable_v1_types + 0 },
+};
+
+static const struct wl_message zwp_primary_selection_offer_v1_events[] = {
+	{ "offer", "s", wp_primary_selection_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_primary_selection_offer_v1_interface = {
+	"zwp_primary_selection_offer_v1", 1,
+	2, zwp_primary_selection_offer_v1_requests,
+	1, zwp_primary_selection_offer_v1_events,
+};
+
+static const struct wl_message zwp_primary_selection_source_v1_requests[] = {
+	{ "offer", "s", wp_primary_selection_unstable_v1_types + 0 },
+	{ "destroy", "", wp_primary_selection_unstable_v1_types + 0 },
+};
+
+static const struct wl_message zwp_primary_selection_source_v1_events[] = {
+	{ "send", "sh", wp_primary_selection_unstable_v1_types + 0 },
+	{ "cancelled", "", wp_primary_selection_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zwp_primary_selection_source_v1_interface = {
+	"zwp_primary_selection_source_v1", 1,
+	2, zwp_primary_selection_source_v1_requests,
+	2, zwp_primary_selection_source_v1_events,
+};
+
diff --git a/src/client/wayland-xdg-output-unstable-v1-client-protocol.h b/src/client/wayland-xdg-output-unstable-v1-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..db66d6da2558162cf98d5c641bc3b960bc584e15
--- /dev/null
+++ a/qtwayland/src/client/wayland-xdg-output-unstable-v1-client-protocol.h
@@ -0,0 +1,415 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef XDG_OUTPUT_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define XDG_OUTPUT_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_output_unstable_v1 The xdg_output_unstable_v1 protocol
+ * Protocol to describe output regions
+ *
+ * @section page_desc_xdg_output_unstable_v1 Description
+ *
+ * This protocol aims at describing outputs in a way which is more in line
+ * with the concept of an output on desktop oriented systems.
+ *
+ * Some information are more specific to the concept of an output for
+ * a desktop oriented system and may not make sense in other applications,
+ * such as IVI systems for example.
+ *
+ * Typically, the global compositor space on a desktop system is made of
+ * a contiguous or overlapping set of rectangular regions.
+ *
+ * Some of the information provided in this protocol might be identical
+ * to their counterparts already available from wl_output, in which case
+ * the information provided by this protocol should be preferred to their
+ * equivalent in wl_output. The goal is to move the desktop specific
+ * concepts (such as output location within the global compositor space,
+ * the connector name and types, etc.) out of the core wl_output protocol.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible
+ * changes may be added together with the corresponding interface
+ * version bump.
+ * Backward incompatible changes are done by bumping the version
+ * number in the protocol and interface names and resetting the
+ * interface version. Once the protocol is to be declared stable,
+ * the 'z' prefix and the version number in the protocol and
+ * interface names are removed and the interface version number is
+ * reset.
+ *
+ * @section page_ifaces_xdg_output_unstable_v1 Interfaces
+ * - @subpage page_iface_zxdg_output_manager_v1 - manage xdg_output objects
+ * - @subpage page_iface_zxdg_output_v1 - compositor logical output region
+ * @section page_copyright_xdg_output_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright © 2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_output;
+struct zxdg_output_manager_v1;
+struct zxdg_output_v1;
+
+#ifndef ZXDG_OUTPUT_MANAGER_V1_INTERFACE
+#define ZXDG_OUTPUT_MANAGER_V1_INTERFACE
+/**
+ * @page page_iface_zxdg_output_manager_v1 zxdg_output_manager_v1
+ * @section page_iface_zxdg_output_manager_v1_desc Description
+ *
+ * A global factory interface for xdg_output objects.
+ * @section page_iface_zxdg_output_manager_v1_api API
+ * See @ref iface_zxdg_output_manager_v1.
+ */
+/**
+ * @defgroup iface_zxdg_output_manager_v1 The zxdg_output_manager_v1 interface
+ *
+ * A global factory interface for xdg_output objects.
+ */
+extern const struct wl_interface zxdg_output_manager_v1_interface;
+#endif
+#ifndef ZXDG_OUTPUT_V1_INTERFACE
+#define ZXDG_OUTPUT_V1_INTERFACE
+/**
+ * @page page_iface_zxdg_output_v1 zxdg_output_v1
+ * @section page_iface_zxdg_output_v1_desc Description
+ *
+ * An xdg_output describes part of the compositor geometry.
+ *
+ * This typically corresponds to a monitor that displays part of the
+ * compositor space.
+ *
+ * For objects version 3 onwards, after all xdg_output properties have been
+ * sent (when the object is created and when properties are updated), a
+ * wl_output.done event is sent. This allows changes to the output
+ * properties to be seen as atomic, even if they happen via multiple events.
+ * @section page_iface_zxdg_output_v1_api API
+ * See @ref iface_zxdg_output_v1.
+ */
+/**
+ * @defgroup iface_zxdg_output_v1 The zxdg_output_v1 interface
+ *
+ * An xdg_output describes part of the compositor geometry.
+ *
+ * This typically corresponds to a monitor that displays part of the
+ * compositor space.
+ *
+ * For objects version 3 onwards, after all xdg_output properties have been
+ * sent (when the object is created and when properties are updated), a
+ * wl_output.done event is sent. This allows changes to the output
+ * properties to be seen as atomic, even if they happen via multiple events.
+ */
+extern const struct wl_interface zxdg_output_v1_interface;
+#endif
+
+#define ZXDG_OUTPUT_MANAGER_V1_DESTROY 0
+#define ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT 1
+
+
+/**
+ * @ingroup iface_zxdg_output_manager_v1
+ */
+#define ZXDG_OUTPUT_MANAGER_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_output_manager_v1
+ */
+#define ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_output_manager_v1 */
+static inline void
+zxdg_output_manager_v1_set_user_data(struct zxdg_output_manager_v1 *zxdg_output_manager_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_output_manager_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_output_manager_v1 */
+static inline void *
+zxdg_output_manager_v1_get_user_data(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_output_manager_v1);
+}
+
+static inline uint32_t
+zxdg_output_manager_v1_get_version(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_output_manager_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_output_manager_v1
+ *
+ * Using this request a client can tell the server that it is not
+ * going to use the xdg_output_manager object anymore.
+ *
+ * Any objects already created through this instance are not affected.
+ */
+static inline void
+zxdg_output_manager_v1_destroy(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_output_manager_v1,
+			 ZXDG_OUTPUT_MANAGER_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_output_manager_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_output_manager_v1
+ *
+ * This creates a new xdg_output object for the given wl_output.
+ */
+static inline struct zxdg_output_v1 *
+zxdg_output_manager_v1_get_xdg_output(struct zxdg_output_manager_v1 *zxdg_output_manager_v1, struct wl_output *output)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_output_manager_v1,
+			 ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT, &zxdg_output_v1_interface, NULL, output);
+
+	return (struct zxdg_output_v1 *) id;
+}
+
+/**
+ * @ingroup iface_zxdg_output_v1
+ * @struct zxdg_output_v1_listener
+ */
+struct zxdg_output_v1_listener {
+	/**
+	 * position of the output within the global compositor space
+	 *
+	 * The position event describes the location of the wl_output
+	 * within the global compositor space.
+	 *
+	 * The logical_position event is sent after creating an xdg_output
+	 * (see xdg_output_manager.get_xdg_output) and whenever the
+	 * location of the output changes within the global compositor
+	 * space.
+	 * @param x x position within the global compositor space
+	 * @param y y position within the global compositor space
+	 */
+	void (*logical_position)(void *data,
+				 struct zxdg_output_v1 *zxdg_output_v1,
+				 int32_t x,
+				 int32_t y);
+	/**
+	 * size of the output in the global compositor space
+	 *
+	 * The logical_size event describes the size of the output in the
+	 * global compositor space.
+	 *
+	 * For example, a surface without any buffer scale, transformation
+	 * nor rotation set, with the size matching the logical_size will
+	 * have the same size as the corresponding output when displayed.
+	 *
+	 * Most regular Wayland clients should not pay attention to the
+	 * logical size and would rather rely on xdg_shell interfaces.
+	 *
+	 * Some clients such as Xwayland, however, need this to configure
+	 * their surfaces in the global compositor space as the compositor
+	 * may apply a different scale from what is advertised by the
+	 * output scaling property (to achieve fractional scaling, for
+	 * example).
+	 *
+	 * For example, for a wl_output mode 3840×2160 and a scale factor
+	 * 2:
+	 *
+	 * - A compositor not scaling the surface buffers will advertise a
+	 * logical size of 3840×2160,
+	 *
+	 * - A compositor automatically scaling the surface buffers will
+	 * advertise a logical size of 1920×1080,
+	 *
+	 * - A compositor using a fractional scale of 1.5 will advertise a
+	 * logical size to 2560×1620.
+	 *
+	 * For example, for a wl_output mode 1920×1080 and a 90 degree
+	 * rotation, the compositor will advertise a logical size of
+	 * 1080x1920.
+	 *
+	 * The logical_size event is sent after creating an xdg_output (see
+	 * xdg_output_manager.get_xdg_output) and whenever the logical size
+	 * of the output changes, either as a result of a change in the
+	 * applied scale or because of a change in the corresponding output
+	 * mode(see wl_output.mode) or transform (see wl_output.transform).
+	 * @param width width in global compositor space
+	 * @param height height in global compositor space
+	 */
+	void (*logical_size)(void *data,
+			     struct zxdg_output_v1 *zxdg_output_v1,
+			     int32_t width,
+			     int32_t height);
+	/**
+	 * all information about the output have been sent
+	 *
+	 * This event is sent after all other properties of an xdg_output
+	 * have been sent.
+	 *
+	 * This allows changes to the xdg_output properties to be seen as
+	 * atomic, even if they happen via multiple events.
+	 *
+	 * For objects version 3 onwards, this event is deprecated.
+	 * Compositors are not required to send it anymore and must send
+	 * wl_output.done instead.
+	 */
+	void (*done)(void *data,
+		     struct zxdg_output_v1 *zxdg_output_v1);
+	/**
+	 * name of this output
+	 *
+	 * Many compositors will assign names to their outputs, show them
+	 * to the user, allow them to be configured by name, etc. The
+	 * client may wish to know this name as well to offer the user
+	 * similar behaviors.
+	 *
+	 * The naming convention is compositor defined, but limited to
+	 * alphanumeric characters and dashes (-). Each name is unique
+	 * among all wl_output globals, but if a wl_output global is
+	 * destroyed the same name may be reused later. The names will also
+	 * remain consistent across sessions with the same hardware and
+	 * software configuration.
+	 *
+	 * Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc.
+	 * However, do not assume that the name is a reflection of an
+	 * underlying DRM connector, X11 connection, etc.
+	 *
+	 * The name event is sent after creating an xdg_output (see
+	 * xdg_output_manager.get_xdg_output). This event is only sent once
+	 * per xdg_output, and the name does not change over the lifetime
+	 * of the wl_output global.
+	 * @param name output name
+	 * @since 2
+	 */
+	void (*name)(void *data,
+		     struct zxdg_output_v1 *zxdg_output_v1,
+		     const char *name);
+	/**
+	 * human-readable description of this output
+	 *
+	 * Many compositors can produce human-readable descriptions of
+	 * their outputs. The client may wish to know this description as
+	 * well, to communicate the user for various purposes.
+	 *
+	 * The description is a UTF-8 string with no convention defined for
+	 * its contents. Examples might include 'Foocorp 11" Display' or
+	 * 'Virtual X11 output via :1'.
+	 *
+	 * The description event is sent after creating an xdg_output (see
+	 * xdg_output_manager.get_xdg_output) and whenever the description
+	 * changes. The description is optional, and may not be sent at
+	 * all.
+	 *
+	 * For objects of version 2 and lower, this event is only sent once
+	 * per xdg_output, and the description does not change over the
+	 * lifetime of the wl_output global.
+	 * @param description output description
+	 * @since 2
+	 */
+	void (*description)(void *data,
+			    struct zxdg_output_v1 *zxdg_output_v1,
+			    const char *description);
+};
+
+/**
+ * @ingroup iface_zxdg_output_v1
+ */
+static inline int
+zxdg_output_v1_add_listener(struct zxdg_output_v1 *zxdg_output_v1,
+			    const struct zxdg_output_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_output_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_OUTPUT_V1_DESTROY 0
+
+/**
+ * @ingroup iface_zxdg_output_v1
+ */
+#define ZXDG_OUTPUT_V1_LOGICAL_POSITION_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_output_v1
+ */
+#define ZXDG_OUTPUT_V1_LOGICAL_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_output_v1
+ */
+#define ZXDG_OUTPUT_V1_DONE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_output_v1
+ */
+#define ZXDG_OUTPUT_V1_NAME_SINCE_VERSION 2
+/**
+ * @ingroup iface_zxdg_output_v1
+ */
+#define ZXDG_OUTPUT_V1_DESCRIPTION_SINCE_VERSION 2
+
+/**
+ * @ingroup iface_zxdg_output_v1
+ */
+#define ZXDG_OUTPUT_V1_DESTROY_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_output_v1 */
+static inline void
+zxdg_output_v1_set_user_data(struct zxdg_output_v1 *zxdg_output_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_output_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_output_v1 */
+static inline void *
+zxdg_output_v1_get_user_data(struct zxdg_output_v1 *zxdg_output_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_output_v1);
+}
+
+static inline uint32_t
+zxdg_output_v1_get_version(struct zxdg_output_v1 *zxdg_output_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_output_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_output_v1
+ *
+ * Using this request a client can tell the server that it is not
+ * going to use the xdg_output object anymore.
+ */
+static inline void
+zxdg_output_v1_destroy(struct zxdg_output_v1 *zxdg_output_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_output_v1,
+			 ZXDG_OUTPUT_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_output_v1);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/client/wayland-xdg-output-unstable-v1-protocol.c b/src/client/wayland-xdg-output-unstable-v1-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..761ae35f77246564f69e4e68ad220842d6d073cf
--- /dev/null
+++ a/qtwayland/src/client/wayland-xdg-output-unstable-v1-protocol.c
@@ -0,0 +1,68 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright © 2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_output_interface;
+extern const struct wl_interface zxdg_output_v1_interface;
+
+static const struct wl_interface *xdg_output_unstable_v1_types[] = {
+	NULL,
+	NULL,
+	&zxdg_output_v1_interface,
+	&wl_output_interface,
+};
+
+static const struct wl_message zxdg_output_manager_v1_requests[] = {
+	{ "destroy", "", xdg_output_unstable_v1_types + 0 },
+	{ "get_xdg_output", "no", xdg_output_unstable_v1_types + 2 },
+};
+
+WL_EXPORT const struct wl_interface zxdg_output_manager_v1_interface = {
+	"zxdg_output_manager_v1", 3,
+	2, zxdg_output_manager_v1_requests,
+	0, NULL,
+};
+
+static const struct wl_message zxdg_output_v1_requests[] = {
+	{ "destroy", "", xdg_output_unstable_v1_types + 0 },
+};
+
+static const struct wl_message zxdg_output_v1_events[] = {
+	{ "logical_position", "ii", xdg_output_unstable_v1_types + 0 },
+	{ "logical_size", "ii", xdg_output_unstable_v1_types + 0 },
+	{ "done", "", xdg_output_unstable_v1_types + 0 },
+	{ "name", "2s", xdg_output_unstable_v1_types + 0 },
+	{ "description", "2s", xdg_output_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zxdg_output_v1_interface = {
+	"zxdg_output_v1", 3,
+	1, zxdg_output_v1_requests,
+	5, zxdg_output_v1_events,
+};
+
diff --git a/src/compositor/compositor_api/qwaylandkeyboard_p.h b/src/compositor/compositor_api/qwaylandkeyboard_p.h
index 96d174310bcfb9f68cb99fd6180ce70122445b2e..6006572e6ee8c2472f55f238a5beedbfaa1112fa 100644
--- a/qtwayland/src/compositor/compositor_api/qwaylandkeyboard_p.h
+++ a/qtwayland/src/compositor/compositor_api/qwaylandkeyboard_p.h
@@ -54,7 +54,7 @@
 #include <QtCore/QVector>
 
 #if QT_CONFIG(xkbcommon)
-#include <xkbcommon/xkbcommon.h>
+#include <xkbcommon-so_wrap.h>
 #include <QtXkbCommonSupport/private/qxkbcommon_p.h>
 #endif
 
diff --git a/src/hardwareintegration/client/brcm-egl/qwaylandbrcmeglintegration.h b/src/hardwareintegration/client/brcm-egl/qwaylandbrcmeglintegration.h
index 9db8e1612a14c743e2656c079e678bdcb73178b5..e7302f30eef00eb8f267209c55a3ed631323badc 100644
--- a/qtwayland/src/hardwareintegration/client/brcm-egl/qwaylandbrcmeglintegration.h
+++ a/qtwayland/src/hardwareintegration/client/brcm-egl/qwaylandbrcmeglintegration.h
@@ -42,7 +42,7 @@
 
 #include <QtWaylandClient/private/qwaylandclientbufferintegration_p.h>
 #include <QtWaylandClient/private/wayland-wayland-client-protocol.h>
-#include <wayland-client-core.h>
+#include <wayland_client-so_wrap.h>
 
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandeglclientbufferintegration.cpp b/src/hardwareintegration/client/wayland-egl/qwaylandeglclientbufferintegration.cpp
index 4e4ea11fb09958a5c7be3644ac7eab18f4f48e9e..33e9666fb884a2ec6c23321dca7a1eec7b191a01 100644
--- a/qtwayland/src/hardwareintegration/client/wayland-egl/qwaylandeglclientbufferintegration.cpp
+++ a/qtwayland/src/hardwareintegration/client/wayland-egl/qwaylandeglclientbufferintegration.cpp
@@ -42,7 +42,7 @@
 #include "qwaylandeglwindow.h"
 #include "qwaylandglcontext.h"
 
-#include <wayland-client-core.h>
+#include <wayland_client-so_wrap.h>
 
 #include <QtCore/QDebug>
 #include <private/qeglconvenience_p.h>
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandeglinclude.h b/src/hardwareintegration/client/wayland-egl/qwaylandeglinclude.h
index e9998b832b7afc30b0d2d7ea49164e7e83e2d3e2..c254c608404553fd2579193da54129d00d5f1313 100644
--- a/qtwayland/src/hardwareintegration/client/wayland-egl/qwaylandeglinclude.h
+++ a/qtwayland/src/hardwareintegration/client/wayland-egl/qwaylandeglinclude.h
@@ -41,9 +41,9 @@
 #define QWAYLANDEGLINCLUDE_H
 
 #include <string.h>
-#include <wayland-client-core.h>
+#include <wayland_client-so_wrap.h>
 
-#include <wayland-egl.h>
+#include <wayland_egl-so_wrap.h>
 
 #define EGL_EGLEXT_PROTOTYPES
 #include <QtEglSupport/private/qt_egl_p.h>
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp b/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
index c1f45fa69d05690665a0028eb9283c2cd4a3806b..aac8be9b8ab2af03112c3ae96c14d3cbdc278b28 100644
--- a/qtwayland/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
+++ a/qtwayland/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.cpp
@@ -337,6 +337,11 @@ QWaylandGLContext::QWaylandGLContext(EGLDisplay eglDisplay, QWaylandDisplay *dis
 
     m_supportSurfaceLessContext = q_hasEglExtension(m_eglDisplay, "EGL_KHR_surfaceless_context");
 
+    // Get basic GL functions used in this class, to avoid having to link GLESv2 directly.
+    Flush = reinterpret_cast<void (QOPENGLF_APIENTRYP)()>(getProcAddress("glFlush"));
+    GetIntegerv = reinterpret_cast<void (QOPENGLF_APIENTRYP)(GLenum, GLint *)>(getProcAddress("glGetIntegerv"));
+    GetString = reinterpret_cast<GLubyte * (QOPENGLF_APIENTRYP)(GLenum)>(getProcAddress("glGetString"));
+
     updateGLFormat();
 }
 
@@ -362,7 +367,7 @@ void QWaylandGLContext::updateGLFormat()
     if (eglMakeCurrent(m_eglDisplay, eglSurface, eglSurface, m_context)) {
         if (m_format.renderableType() == QSurfaceFormat::OpenGL
             || m_format.renderableType() == QSurfaceFormat::OpenGLES) {
-            const GLubyte *s = glGetString(GL_VERSION);
+            const GLubyte *s = GetString(GL_VERSION);
             if (s) {
                 QByteArray version = QByteArray(reinterpret_cast<const char *>(s));
                 int major, minor;
@@ -379,14 +384,14 @@ void QWaylandGLContext::updateGLFormat()
                     m_format.setOption(QSurfaceFormat::DeprecatedFunctions);
                 } else {
                     GLint value = 0;
-                    glGetIntegerv(GL_CONTEXT_FLAGS, &value);
+                    GetIntegerv(GL_CONTEXT_FLAGS, &value);
                     if (!(value & GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT))
                         m_format.setOption(QSurfaceFormat::DeprecatedFunctions);
                     if (value & GL_CONTEXT_FLAG_DEBUG_BIT)
                         m_format.setOption(QSurfaceFormat::DebugContext);
                     if (m_format.version() >= qMakePair(3, 2)) {
                         value = 0;
-                        glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &value);
+                        GetIntegerv(GL_CONTEXT_PROFILE_MASK, &value);
                         if (value & GL_CONTEXT_CORE_PROFILE_BIT)
                             m_format.setProfile(QSurfaceFormat::CoreProfile);
                         else if (value & GL_CONTEXT_COMPATIBILITY_PROFILE_BIT)
@@ -495,7 +500,7 @@ void QWaylandGLContext::swapBuffers(QPlatformSurface *surface)
     eglSwapInterval(m_eglDisplay, swapInterval);
     if (swapInterval == 0 && m_format.swapInterval() > 0) {
         // Emulating a blocking swap
-        glFlush(); // Flush before waiting so we can swap more quickly when the frame event arrives
+        Flush(); // Flush before waiting so we can swap more quickly when the frame event arrives
         window->waitForFrameSync(100);
     }
     window->handleUpdate();
diff --git a/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.h b/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.h
index 93edaec0e7289275fac1e1f248518e71546a4ac1..b8042a6f8e604c3874ad0daaf27eb8008cd82188 100644
--- a/qtwayland/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.h
+++ a/qtwayland/src/hardwareintegration/client/wayland-egl/qwaylandglcontext.h
@@ -94,6 +94,10 @@ private:
     uint m_api;
     bool m_supportNonBlockingSwap = true;
     bool m_supportSurfaceLessContext = false;
+
+    void (QOPENGLF_APIENTRYP Flush)() = nullptr;
+    void (QOPENGLF_APIENTRYP GetIntegerv)(GLenum, GLint *) = nullptr;
+    GLubyte * (QOPENGLF_APIENTRYP GetString)(GLenum) = nullptr;
 };
 
 }
diff --git a/src/hardwareintegration/client/xcomposite-egl/qwaylandxcompositeeglclientbufferintegration.h b/src/hardwareintegration/client/xcomposite-egl/qwaylandxcompositeeglclientbufferintegration.h
index 5fe21d7b7ff2e9787385c093e6e1b8d307f50d7a..b47e2bcfef7fbeb373d73737b40d29d1e59cfeec 100644
--- a/qtwayland/src/hardwareintegration/client/xcomposite-egl/qwaylandxcompositeeglclientbufferintegration.h
+++ a/qtwayland/src/hardwareintegration/client/xcomposite-egl/qwaylandxcompositeeglclientbufferintegration.h
@@ -41,7 +41,7 @@
 #define QWAYLANDXCOMPOSITEEGLCLIENTBUFFERINTEGRATION_H
 
 #include <QtWaylandClient/private/qwaylandclientbufferintegration_p.h>
-#include <wayland-client-core.h>
+#include <wayland_client-so_wrap.h>
 
 #include <QtCore/QTextStream>
 #include <QtCore/QDataStream>
diff --git a/src/hardwareintegration/client/xcomposite-glx/qwaylandxcompositeglxintegration.h b/src/hardwareintegration/client/xcomposite-glx/qwaylandxcompositeglxintegration.h
index 809690816fcf8355352c91fb38d8ae363c572897..b06c9af8eddd86b47dae38a7271bac84b95bbf5b 100644
--- a/qtwayland/src/hardwareintegration/client/xcomposite-glx/qwaylandxcompositeglxintegration.h
+++ a/qtwayland/src/hardwareintegration/client/xcomposite-glx/qwaylandxcompositeglxintegration.h
@@ -41,7 +41,7 @@
 #define QWAYLANDXCOMPOSITEGLXINTEGRATION_H
 
 #include <QtWaylandClient/private/qwaylandclientbufferintegration_p.h>
-#include <wayland-client-core.h>
+#include <wayland_client-so_wrap.h>
 
 #include <QtCore/QTextStream>
 #include <QtCore/QDataStream>
diff --git a/src/plugins/platforms/qwayland-generic/main.cpp b/src/plugins/platforms/qwayland-generic/main.cpp
index e66a5d45c951a9183393d5945763ae7ce0efb817..9198ff2dd6a8c9d2b868580121e71334bfd846b9 100644
--- a/qtwayland/src/plugins/platforms/qwayland-generic/main.cpp
+++ a/qtwayland/src/plugins/platforms/qwayland-generic/main.cpp
@@ -38,8 +38,15 @@
 ****************************************************************************/
 
 #include <qpa/qplatformintegrationplugin.h>
+#include <QtWaylandClient/private/qwaylanddisplay_p.h>
 #include <QtWaylandClient/private/qwaylandintegration_p.h>
 
+#include <wayland_client-so_wrap.h>
+#include <wayland_cursor-so_wrap.h>
+#include <wayland_egl-so_wrap.h>
+#include <egl-so_wrap.h>
+#include <xkbcommon-so_wrap.h>
+
 QT_BEGIN_NAMESPACE
 
 namespace QtWaylandClient {
@@ -56,6 +63,16 @@ QPlatformIntegration *QWaylandIntegrationPlugin::create(const QString& system, c
 {
     Q_UNUSED(paramList);
     Q_UNUSED(system);
+    // Try loading libraries. If any fails, skip initialization of this backend.
+    if (initialize_wayland_client(1) |
+        initialize_wayland_cursor(1) |
+        initialize_wayland_egl(1) |
+        initialize_egl(1) |
+        initialize_xkbcommon(1)) {
+        qCWarning(lcQpaWayland, "Unable to load required libraries, skipping initialization of wayland backend.");
+        return nullptr;
+    }
+
     auto *integration =  new QWaylandIntegration();
 
     if (integration->hasFailed()) {
diff --git a/src/plugins/shellintegration/fullscreen-shell-v1/qwaylandfullscreenshellv1integration.h b/src/plugins/shellintegration/fullscreen-shell-v1/qwaylandfullscreenshellv1integration.h
index 131f9e7209787028278281be0e13b9ac03a2cdd3..98cdf3a3ea1038ea34c3c40a599ca5c44db2a11a 100644
--- a/qtwayland/src/plugins/shellintegration/fullscreen-shell-v1/qwaylandfullscreenshellv1integration.h
+++ a/qtwayland/src/plugins/shellintegration/fullscreen-shell-v1/qwaylandfullscreenshellv1integration.h
@@ -40,7 +40,7 @@
 #ifndef QWAYLANDFULLSCREENSHELLV1INTEGRATION_H
 #define QWAYLANDFULLSCREENSHELLV1INTEGRATION_H
 
-#include <wayland-client.h>
+#include <wayland_client-so_wrap.h>
 #include <QtWaylandClient/private/qwayland-wayland.h>
 #include <QtWaylandClient/private/qwaylandshellintegration_p.h>
 
diff --git a/src/plugins/shellintegration/xdg-shell-v5/pregenerated/3rdparty/wayland-xdg-shell-unstable-v5-client-protocol_p.h b/src/plugins/shellintegration/xdg-shell-v5/pregenerated/3rdparty/wayland-xdg-shell-unstable-v5-client-protocol_p.h
index 8877e8830c31f2df6eddcc8510a3f23f58ff2d94..481d3e1f338b4ae927f946e936f633b1f6eb9de8 100644
--- a/qtwayland/src/plugins/shellintegration/xdg-shell-v5/pregenerated/3rdparty/wayland-xdg-shell-unstable-v5-client-protocol_p.h
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell-v5/pregenerated/3rdparty/wayland-xdg-shell-unstable-v5-client-protocol_p.h
@@ -7,7 +7,7 @@
 
 #include <stdint.h>
 #include <stddef.h>
-#include "wayland-client-core.h"
+#include <wayland_client-so_wrap.h>
 
 #ifdef  __cplusplus
 extern "C" {
diff --git a/src/plugins/shellintegration/xdg-shell/qwayland-xdg-decoration-unstable-v1.cpp b/src/plugins/shellintegration/xdg-shell/qwayland-xdg-decoration-unstable-v1.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..bbf3298300034b9b8e07b6e1a061a82b053854a6
--- /dev/null
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/qwayland-xdg-decoration-unstable-v1.cpp
@@ -0,0 +1,176 @@
+// This file was generated by qtwaylandscanner
+// source file is ../../../3rdparty/protocol/xdg-decoration-unstable-v1.xml
+
+#include "qwayland-xdg-decoration-unstable-v1.h"
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    zxdg_decoration_manager_v1::zxdg_decoration_manager_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zxdg_decoration_manager_v1::zxdg_decoration_manager_v1(struct ::zxdg_decoration_manager_v1 *obj)
+        : m_zxdg_decoration_manager_v1(obj)
+    {
+    }
+
+    zxdg_decoration_manager_v1::zxdg_decoration_manager_v1()
+        : m_zxdg_decoration_manager_v1(nullptr)
+    {
+    }
+
+    zxdg_decoration_manager_v1::~zxdg_decoration_manager_v1()
+    {
+    }
+
+    void zxdg_decoration_manager_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zxdg_decoration_manager_v1 = static_cast<struct ::zxdg_decoration_manager_v1 *>(wlRegistryBind(registry, id, &zxdg_decoration_manager_v1_interface, version));
+    }
+
+    void zxdg_decoration_manager_v1::init(struct ::zxdg_decoration_manager_v1 *obj)
+    {
+        m_zxdg_decoration_manager_v1 = obj;
+    }
+
+    zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1::fromObject(struct ::zxdg_decoration_manager_v1 *object)
+    {
+        return static_cast<zxdg_decoration_manager_v1 *>(zxdg_decoration_manager_v1_get_user_data(object));
+    }
+
+    bool zxdg_decoration_manager_v1::isInitialized() const
+    {
+        return m_zxdg_decoration_manager_v1 != nullptr;
+    }
+
+    const struct wl_interface *zxdg_decoration_manager_v1::interface()
+    {
+        return &::zxdg_decoration_manager_v1_interface;
+    }
+
+    void zxdg_decoration_manager_v1::destroy()
+    {
+        zxdg_decoration_manager_v1_destroy(
+            m_zxdg_decoration_manager_v1);
+        m_zxdg_decoration_manager_v1 = nullptr;
+    }
+
+    struct ::zxdg_toplevel_decoration_v1 *zxdg_decoration_manager_v1::get_toplevel_decoration(struct ::xdg_toplevel *toplevel)
+    {
+        return zxdg_decoration_manager_v1_get_toplevel_decoration(
+            m_zxdg_decoration_manager_v1,
+            toplevel);
+    }
+
+    zxdg_toplevel_decoration_v1::zxdg_toplevel_decoration_v1(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    zxdg_toplevel_decoration_v1::zxdg_toplevel_decoration_v1(struct ::zxdg_toplevel_decoration_v1 *obj)
+        : m_zxdg_toplevel_decoration_v1(obj)
+    {
+        init_listener();
+    }
+
+    zxdg_toplevel_decoration_v1::zxdg_toplevel_decoration_v1()
+        : m_zxdg_toplevel_decoration_v1(nullptr)
+    {
+    }
+
+    zxdg_toplevel_decoration_v1::~zxdg_toplevel_decoration_v1()
+    {
+    }
+
+    void zxdg_toplevel_decoration_v1::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_zxdg_toplevel_decoration_v1 = static_cast<struct ::zxdg_toplevel_decoration_v1 *>(wlRegistryBind(registry, id, &zxdg_toplevel_decoration_v1_interface, version));
+        init_listener();
+    }
+
+    void zxdg_toplevel_decoration_v1::init(struct ::zxdg_toplevel_decoration_v1 *obj)
+    {
+        m_zxdg_toplevel_decoration_v1 = obj;
+        init_listener();
+    }
+
+    zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1::fromObject(struct ::zxdg_toplevel_decoration_v1 *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_zxdg_toplevel_decoration_v1_listener)
+            return nullptr;
+        return static_cast<zxdg_toplevel_decoration_v1 *>(zxdg_toplevel_decoration_v1_get_user_data(object));
+    }
+
+    bool zxdg_toplevel_decoration_v1::isInitialized() const
+    {
+        return m_zxdg_toplevel_decoration_v1 != nullptr;
+    }
+
+    const struct wl_interface *zxdg_toplevel_decoration_v1::interface()
+    {
+        return &::zxdg_toplevel_decoration_v1_interface;
+    }
+
+    void zxdg_toplevel_decoration_v1::destroy()
+    {
+        zxdg_toplevel_decoration_v1_destroy(
+            m_zxdg_toplevel_decoration_v1);
+        m_zxdg_toplevel_decoration_v1 = nullptr;
+    }
+
+    void zxdg_toplevel_decoration_v1::set_mode(uint32_t mode)
+    {
+        zxdg_toplevel_decoration_v1_set_mode(
+            m_zxdg_toplevel_decoration_v1,
+            mode);
+    }
+
+    void zxdg_toplevel_decoration_v1::unset_mode()
+    {
+        zxdg_toplevel_decoration_v1_unset_mode(
+            m_zxdg_toplevel_decoration_v1);
+    }
+
+    void zxdg_toplevel_decoration_v1::zxdg_toplevel_decoration_v1_configure(uint32_t )
+    {
+    }
+
+    void zxdg_toplevel_decoration_v1::handle_configure(
+        void *data,
+        struct ::zxdg_toplevel_decoration_v1 *object,
+        uint32_t mode)
+    {
+        Q_UNUSED(object);
+        static_cast<zxdg_toplevel_decoration_v1 *>(data)->zxdg_toplevel_decoration_v1_configure(
+            mode);
+    }
+
+    const struct zxdg_toplevel_decoration_v1_listener zxdg_toplevel_decoration_v1::m_zxdg_toplevel_decoration_v1_listener = {
+        zxdg_toplevel_decoration_v1::handle_configure,
+    };
+
+    void zxdg_toplevel_decoration_v1::init_listener()
+    {
+        zxdg_toplevel_decoration_v1_add_listener(m_zxdg_toplevel_decoration_v1, &m_zxdg_toplevel_decoration_v1_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/plugins/shellintegration/xdg-shell/qwayland-xdg-decoration-unstable-v1.h b/src/plugins/shellintegration/xdg-shell/qwayland-xdg-decoration-unstable-v1.h
new file mode 100644
index 0000000000000000000000000000000000000000..fc7157e153c4fa8379b4ace4fc953fd65bff33f0
--- /dev/null
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/qwayland-xdg-decoration-unstable-v1.h
@@ -0,0 +1,97 @@
+// This file was generated by qtwaylandscanner
+// source file is ../../../3rdparty/protocol/xdg-decoration-unstable-v1.xml
+
+#ifndef QT_WAYLAND_XDG_DECORATION_UNSTABLE_V1
+#define QT_WAYLAND_XDG_DECORATION_UNSTABLE_V1
+
+#include "wayland-xdg-decoration-unstable-v1-client-protocol.h"
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+    class  zxdg_decoration_manager_v1
+    {
+    public:
+        zxdg_decoration_manager_v1(struct ::wl_registry *registry, int id, int version);
+        zxdg_decoration_manager_v1(struct ::zxdg_decoration_manager_v1 *object);
+        zxdg_decoration_manager_v1();
+
+        virtual ~zxdg_decoration_manager_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zxdg_decoration_manager_v1 *object);
+
+        struct ::zxdg_decoration_manager_v1 *object() { return m_zxdg_decoration_manager_v1; }
+        const struct ::zxdg_decoration_manager_v1 *object() const { return m_zxdg_decoration_manager_v1; }
+        static zxdg_decoration_manager_v1 *fromObject(struct ::zxdg_decoration_manager_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        void destroy();
+        struct ::zxdg_toplevel_decoration_v1 *get_toplevel_decoration(struct ::xdg_toplevel *toplevel);
+
+    private:
+        struct ::zxdg_decoration_manager_v1 *m_zxdg_decoration_manager_v1;
+    };
+
+    class  zxdg_toplevel_decoration_v1
+    {
+    public:
+        zxdg_toplevel_decoration_v1(struct ::wl_registry *registry, int id, int version);
+        zxdg_toplevel_decoration_v1(struct ::zxdg_toplevel_decoration_v1 *object);
+        zxdg_toplevel_decoration_v1();
+
+        virtual ~zxdg_toplevel_decoration_v1();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::zxdg_toplevel_decoration_v1 *object);
+
+        struct ::zxdg_toplevel_decoration_v1 *object() { return m_zxdg_toplevel_decoration_v1; }
+        const struct ::zxdg_toplevel_decoration_v1 *object() const { return m_zxdg_toplevel_decoration_v1; }
+        static zxdg_toplevel_decoration_v1 *fromObject(struct ::zxdg_toplevel_decoration_v1 *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_unconfigured_buffer = 0, // xdg_toplevel has a buffer attached before configure
+            error_already_constructed = 1, // xdg_toplevel already has a decoration object
+            error_orphaned = 2, // xdg_toplevel destroyed before the decoration object
+        };
+
+        enum mode {
+            mode_client_side = 1, // no server-side window decoration
+            mode_server_side = 2, // server-side window decoration
+        };
+
+        void destroy();
+        void set_mode(uint32_t mode);
+        void unset_mode();
+
+    protected:
+        virtual void zxdg_toplevel_decoration_v1_configure(uint32_t mode);
+
+    private:
+        void init_listener();
+        static const struct zxdg_toplevel_decoration_v1_listener m_zxdg_toplevel_decoration_v1_listener;
+        static void handle_configure(
+            void *data,
+            struct ::zxdg_toplevel_decoration_v1 *object,
+            uint32_t mode);
+        struct ::zxdg_toplevel_decoration_v1 *m_zxdg_toplevel_decoration_v1;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/shellintegration/xdg-shell/qwayland-xdg-shell.cpp b/src/plugins/shellintegration/xdg-shell/qwayland-xdg-shell.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..1375b0009ee4681052d8d85a3384e7ac5543a7dc
--- /dev/null
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/qwayland-xdg-shell.cpp
@@ -0,0 +1,630 @@
+// This file was generated by qtwaylandscanner
+// source file is ../../../3rdparty/protocol/xdg-shell.xml
+
+#include "qwayland-xdg-shell.h"
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+
+static inline void *wlRegistryBind(struct ::wl_registry *registry, uint32_t name, const struct ::wl_interface *interface, uint32_t version)
+{
+    const uint32_t bindOpCode = 0;
+#if (WAYLAND_VERSION_MAJOR == 1 && WAYLAND_VERSION_MINOR > 10) || WAYLAND_VERSION_MAJOR > 1
+    return (void *) wl_proxy_marshal_constructor_versioned((struct wl_proxy *) registry,
+        bindOpCode, interface, version, name, interface->name, version, nullptr);
+#else
+    return (void *) wl_proxy_marshal_constructor((struct wl_proxy *) registry,
+        bindOpCode, interface, name, interface->name, version, nullptr);
+#endif
+}
+
+    xdg_wm_base::xdg_wm_base(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    xdg_wm_base::xdg_wm_base(struct ::xdg_wm_base *obj)
+        : m_xdg_wm_base(obj)
+    {
+        init_listener();
+    }
+
+    xdg_wm_base::xdg_wm_base()
+        : m_xdg_wm_base(nullptr)
+    {
+    }
+
+    xdg_wm_base::~xdg_wm_base()
+    {
+    }
+
+    void xdg_wm_base::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_xdg_wm_base = static_cast<struct ::xdg_wm_base *>(wlRegistryBind(registry, id, &xdg_wm_base_interface, version));
+        init_listener();
+    }
+
+    void xdg_wm_base::init(struct ::xdg_wm_base *obj)
+    {
+        m_xdg_wm_base = obj;
+        init_listener();
+    }
+
+    xdg_wm_base *xdg_wm_base::fromObject(struct ::xdg_wm_base *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_xdg_wm_base_listener)
+            return nullptr;
+        return static_cast<xdg_wm_base *>(xdg_wm_base_get_user_data(object));
+    }
+
+    bool xdg_wm_base::isInitialized() const
+    {
+        return m_xdg_wm_base != nullptr;
+    }
+
+    const struct wl_interface *xdg_wm_base::interface()
+    {
+        return &::xdg_wm_base_interface;
+    }
+
+    void xdg_wm_base::destroy()
+    {
+        xdg_wm_base_destroy(
+            m_xdg_wm_base);
+        m_xdg_wm_base = nullptr;
+    }
+
+    struct ::xdg_positioner *xdg_wm_base::create_positioner()
+    {
+        return xdg_wm_base_create_positioner(
+            m_xdg_wm_base);
+    }
+
+    struct ::xdg_surface *xdg_wm_base::get_xdg_surface(struct ::wl_surface *surface)
+    {
+        return xdg_wm_base_get_xdg_surface(
+            m_xdg_wm_base,
+            surface);
+    }
+
+    void xdg_wm_base::pong(uint32_t serial)
+    {
+        xdg_wm_base_pong(
+            m_xdg_wm_base,
+            serial);
+    }
+
+    void xdg_wm_base::xdg_wm_base_ping(uint32_t )
+    {
+    }
+
+    void xdg_wm_base::handle_ping(
+        void *data,
+        struct ::xdg_wm_base *object,
+        uint32_t serial)
+    {
+        Q_UNUSED(object);
+        static_cast<xdg_wm_base *>(data)->xdg_wm_base_ping(
+            serial);
+    }
+
+    const struct xdg_wm_base_listener xdg_wm_base::m_xdg_wm_base_listener = {
+        xdg_wm_base::handle_ping,
+    };
+
+    void xdg_wm_base::init_listener()
+    {
+        xdg_wm_base_add_listener(m_xdg_wm_base, &m_xdg_wm_base_listener, this);
+    }
+
+    xdg_positioner::xdg_positioner(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    xdg_positioner::xdg_positioner(struct ::xdg_positioner *obj)
+        : m_xdg_positioner(obj)
+    {
+    }
+
+    xdg_positioner::xdg_positioner()
+        : m_xdg_positioner(nullptr)
+    {
+    }
+
+    xdg_positioner::~xdg_positioner()
+    {
+    }
+
+    void xdg_positioner::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_xdg_positioner = static_cast<struct ::xdg_positioner *>(wlRegistryBind(registry, id, &xdg_positioner_interface, version));
+    }
+
+    void xdg_positioner::init(struct ::xdg_positioner *obj)
+    {
+        m_xdg_positioner = obj;
+    }
+
+    xdg_positioner *xdg_positioner::fromObject(struct ::xdg_positioner *object)
+    {
+        return static_cast<xdg_positioner *>(xdg_positioner_get_user_data(object));
+    }
+
+    bool xdg_positioner::isInitialized() const
+    {
+        return m_xdg_positioner != nullptr;
+    }
+
+    const struct wl_interface *xdg_positioner::interface()
+    {
+        return &::xdg_positioner_interface;
+    }
+
+    void xdg_positioner::destroy()
+    {
+        xdg_positioner_destroy(
+            m_xdg_positioner);
+        m_xdg_positioner = nullptr;
+    }
+
+    void xdg_positioner::set_size(int32_t width, int32_t height)
+    {
+        xdg_positioner_set_size(
+            m_xdg_positioner,
+            width,
+            height);
+    }
+
+    void xdg_positioner::set_anchor_rect(int32_t x, int32_t y, int32_t width, int32_t height)
+    {
+        xdg_positioner_set_anchor_rect(
+            m_xdg_positioner,
+            x,
+            y,
+            width,
+            height);
+    }
+
+    void xdg_positioner::set_anchor(uint32_t anchor)
+    {
+        xdg_positioner_set_anchor(
+            m_xdg_positioner,
+            anchor);
+    }
+
+    void xdg_positioner::set_gravity(uint32_t gravity)
+    {
+        xdg_positioner_set_gravity(
+            m_xdg_positioner,
+            gravity);
+    }
+
+    void xdg_positioner::set_constraint_adjustment(uint32_t constraint_adjustment)
+    {
+        xdg_positioner_set_constraint_adjustment(
+            m_xdg_positioner,
+            constraint_adjustment);
+    }
+
+    void xdg_positioner::set_offset(int32_t x, int32_t y)
+    {
+        xdg_positioner_set_offset(
+            m_xdg_positioner,
+            x,
+            y);
+    }
+
+    xdg_surface::xdg_surface(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    xdg_surface::xdg_surface(struct ::xdg_surface *obj)
+        : m_xdg_surface(obj)
+    {
+        init_listener();
+    }
+
+    xdg_surface::xdg_surface()
+        : m_xdg_surface(nullptr)
+    {
+    }
+
+    xdg_surface::~xdg_surface()
+    {
+    }
+
+    void xdg_surface::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_xdg_surface = static_cast<struct ::xdg_surface *>(wlRegistryBind(registry, id, &xdg_surface_interface, version));
+        init_listener();
+    }
+
+    void xdg_surface::init(struct ::xdg_surface *obj)
+    {
+        m_xdg_surface = obj;
+        init_listener();
+    }
+
+    xdg_surface *xdg_surface::fromObject(struct ::xdg_surface *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_xdg_surface_listener)
+            return nullptr;
+        return static_cast<xdg_surface *>(xdg_surface_get_user_data(object));
+    }
+
+    bool xdg_surface::isInitialized() const
+    {
+        return m_xdg_surface != nullptr;
+    }
+
+    const struct wl_interface *xdg_surface::interface()
+    {
+        return &::xdg_surface_interface;
+    }
+
+    void xdg_surface::destroy()
+    {
+        xdg_surface_destroy(
+            m_xdg_surface);
+        m_xdg_surface = nullptr;
+    }
+
+    struct ::xdg_toplevel *xdg_surface::get_toplevel()
+    {
+        return xdg_surface_get_toplevel(
+            m_xdg_surface);
+    }
+
+    struct ::xdg_popup *xdg_surface::get_popup(struct ::xdg_surface *parent, struct ::xdg_positioner *positioner)
+    {
+        return xdg_surface_get_popup(
+            m_xdg_surface,
+            parent,
+            positioner);
+    }
+
+    void xdg_surface::set_window_geometry(int32_t x, int32_t y, int32_t width, int32_t height)
+    {
+        xdg_surface_set_window_geometry(
+            m_xdg_surface,
+            x,
+            y,
+            width,
+            height);
+    }
+
+    void xdg_surface::ack_configure(uint32_t serial)
+    {
+        xdg_surface_ack_configure(
+            m_xdg_surface,
+            serial);
+    }
+
+    void xdg_surface::xdg_surface_configure(uint32_t )
+    {
+    }
+
+    void xdg_surface::handle_configure(
+        void *data,
+        struct ::xdg_surface *object,
+        uint32_t serial)
+    {
+        Q_UNUSED(object);
+        static_cast<xdg_surface *>(data)->xdg_surface_configure(
+            serial);
+    }
+
+    const struct xdg_surface_listener xdg_surface::m_xdg_surface_listener = {
+        xdg_surface::handle_configure,
+    };
+
+    void xdg_surface::init_listener()
+    {
+        xdg_surface_add_listener(m_xdg_surface, &m_xdg_surface_listener, this);
+    }
+
+    xdg_toplevel::xdg_toplevel(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    xdg_toplevel::xdg_toplevel(struct ::xdg_toplevel *obj)
+        : m_xdg_toplevel(obj)
+    {
+        init_listener();
+    }
+
+    xdg_toplevel::xdg_toplevel()
+        : m_xdg_toplevel(nullptr)
+    {
+    }
+
+    xdg_toplevel::~xdg_toplevel()
+    {
+    }
+
+    void xdg_toplevel::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_xdg_toplevel = static_cast<struct ::xdg_toplevel *>(wlRegistryBind(registry, id, &xdg_toplevel_interface, version));
+        init_listener();
+    }
+
+    void xdg_toplevel::init(struct ::xdg_toplevel *obj)
+    {
+        m_xdg_toplevel = obj;
+        init_listener();
+    }
+
+    xdg_toplevel *xdg_toplevel::fromObject(struct ::xdg_toplevel *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_xdg_toplevel_listener)
+            return nullptr;
+        return static_cast<xdg_toplevel *>(xdg_toplevel_get_user_data(object));
+    }
+
+    bool xdg_toplevel::isInitialized() const
+    {
+        return m_xdg_toplevel != nullptr;
+    }
+
+    const struct wl_interface *xdg_toplevel::interface()
+    {
+        return &::xdg_toplevel_interface;
+    }
+
+    void xdg_toplevel::destroy()
+    {
+        xdg_toplevel_destroy(
+            m_xdg_toplevel);
+        m_xdg_toplevel = nullptr;
+    }
+
+    void xdg_toplevel::set_parent(struct ::xdg_toplevel *parent)
+    {
+        xdg_toplevel_set_parent(
+            m_xdg_toplevel,
+            parent);
+    }
+
+    void xdg_toplevel::set_title(const QString &title)
+    {
+        xdg_toplevel_set_title(
+            m_xdg_toplevel,
+            title.toUtf8().constData());
+    }
+
+    void xdg_toplevel::set_app_id(const QString &app_id)
+    {
+        xdg_toplevel_set_app_id(
+            m_xdg_toplevel,
+            app_id.toUtf8().constData());
+    }
+
+    void xdg_toplevel::show_window_menu(struct ::wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
+    {
+        xdg_toplevel_show_window_menu(
+            m_xdg_toplevel,
+            seat,
+            serial,
+            x,
+            y);
+    }
+
+    void xdg_toplevel::move(struct ::wl_seat *seat, uint32_t serial)
+    {
+        xdg_toplevel_move(
+            m_xdg_toplevel,
+            seat,
+            serial);
+    }
+
+    void xdg_toplevel::resize(struct ::wl_seat *seat, uint32_t serial, uint32_t edges)
+    {
+        xdg_toplevel_resize(
+            m_xdg_toplevel,
+            seat,
+            serial,
+            edges);
+    }
+
+    void xdg_toplevel::set_max_size(int32_t width, int32_t height)
+    {
+        xdg_toplevel_set_max_size(
+            m_xdg_toplevel,
+            width,
+            height);
+    }
+
+    void xdg_toplevel::set_min_size(int32_t width, int32_t height)
+    {
+        xdg_toplevel_set_min_size(
+            m_xdg_toplevel,
+            width,
+            height);
+    }
+
+    void xdg_toplevel::set_maximized()
+    {
+        xdg_toplevel_set_maximized(
+            m_xdg_toplevel);
+    }
+
+    void xdg_toplevel::unset_maximized()
+    {
+        xdg_toplevel_unset_maximized(
+            m_xdg_toplevel);
+    }
+
+    void xdg_toplevel::set_fullscreen(struct ::wl_output *output)
+    {
+        xdg_toplevel_set_fullscreen(
+            m_xdg_toplevel,
+            output);
+    }
+
+    void xdg_toplevel::unset_fullscreen()
+    {
+        xdg_toplevel_unset_fullscreen(
+            m_xdg_toplevel);
+    }
+
+    void xdg_toplevel::set_minimized()
+    {
+        xdg_toplevel_set_minimized(
+            m_xdg_toplevel);
+    }
+
+    void xdg_toplevel::xdg_toplevel_configure(int32_t , int32_t , wl_array *)
+    {
+    }
+
+    void xdg_toplevel::handle_configure(
+        void *data,
+        struct ::xdg_toplevel *object,
+        int32_t width,
+        int32_t height,
+        wl_array *states)
+    {
+        Q_UNUSED(object);
+        static_cast<xdg_toplevel *>(data)->xdg_toplevel_configure(
+            width,
+            height,
+            states);
+    }
+
+    void xdg_toplevel::xdg_toplevel_close()
+    {
+    }
+
+    void xdg_toplevel::handle_close(
+        void *data,
+        struct ::xdg_toplevel *object)
+    {
+        Q_UNUSED(object);
+        static_cast<xdg_toplevel *>(data)->xdg_toplevel_close();
+    }
+
+    const struct xdg_toplevel_listener xdg_toplevel::m_xdg_toplevel_listener = {
+        xdg_toplevel::handle_configure,
+        xdg_toplevel::handle_close,
+    };
+
+    void xdg_toplevel::init_listener()
+    {
+        xdg_toplevel_add_listener(m_xdg_toplevel, &m_xdg_toplevel_listener, this);
+    }
+
+    xdg_popup::xdg_popup(struct ::wl_registry *registry, int id, int version)
+    {
+        init(registry, id, version);
+    }
+
+    xdg_popup::xdg_popup(struct ::xdg_popup *obj)
+        : m_xdg_popup(obj)
+    {
+        init_listener();
+    }
+
+    xdg_popup::xdg_popup()
+        : m_xdg_popup(nullptr)
+    {
+    }
+
+    xdg_popup::~xdg_popup()
+    {
+    }
+
+    void xdg_popup::init(struct ::wl_registry *registry, int id, int version)
+    {
+        m_xdg_popup = static_cast<struct ::xdg_popup *>(wlRegistryBind(registry, id, &xdg_popup_interface, version));
+        init_listener();
+    }
+
+    void xdg_popup::init(struct ::xdg_popup *obj)
+    {
+        m_xdg_popup = obj;
+        init_listener();
+    }
+
+    xdg_popup *xdg_popup::fromObject(struct ::xdg_popup *object)
+    {
+        if (wl_proxy_get_listener((struct ::wl_proxy *)object) != (void *)&m_xdg_popup_listener)
+            return nullptr;
+        return static_cast<xdg_popup *>(xdg_popup_get_user_data(object));
+    }
+
+    bool xdg_popup::isInitialized() const
+    {
+        return m_xdg_popup != nullptr;
+    }
+
+    const struct wl_interface *xdg_popup::interface()
+    {
+        return &::xdg_popup_interface;
+    }
+
+    void xdg_popup::destroy()
+    {
+        xdg_popup_destroy(
+            m_xdg_popup);
+        m_xdg_popup = nullptr;
+    }
+
+    void xdg_popup::grab(struct ::wl_seat *seat, uint32_t serial)
+    {
+        xdg_popup_grab(
+            m_xdg_popup,
+            seat,
+            serial);
+    }
+
+    void xdg_popup::xdg_popup_configure(int32_t , int32_t , int32_t , int32_t )
+    {
+    }
+
+    void xdg_popup::handle_configure(
+        void *data,
+        struct ::xdg_popup *object,
+        int32_t x,
+        int32_t y,
+        int32_t width,
+        int32_t height)
+    {
+        Q_UNUSED(object);
+        static_cast<xdg_popup *>(data)->xdg_popup_configure(
+            x,
+            y,
+            width,
+            height);
+    }
+
+    void xdg_popup::xdg_popup_popup_done()
+    {
+    }
+
+    void xdg_popup::handle_popup_done(
+        void *data,
+        struct ::xdg_popup *object)
+    {
+        Q_UNUSED(object);
+        static_cast<xdg_popup *>(data)->xdg_popup_popup_done();
+    }
+
+    const struct xdg_popup_listener xdg_popup::m_xdg_popup_listener = {
+        xdg_popup::handle_configure,
+        xdg_popup::handle_popup_done,
+    };
+
+    void xdg_popup::init_listener()
+    {
+        xdg_popup_add_listener(m_xdg_popup, &m_xdg_popup_listener, this);
+    }
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
diff --git a/src/plugins/shellintegration/xdg-shell/qwayland-xdg-shell.h b/src/plugins/shellintegration/xdg-shell/qwayland-xdg-shell.h
new file mode 100644
index 0000000000000000000000000000000000000000..2ca759a9ffcf08acc6aa6bd5cb2720bfd6270185
--- /dev/null
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/qwayland-xdg-shell.h
@@ -0,0 +1,308 @@
+// This file was generated by qtwaylandscanner
+// source file is ../../../3rdparty/protocol/xdg-shell.xml
+
+#ifndef QT_WAYLAND_XDG_SHELL
+#define QT_WAYLAND_XDG_SHELL
+
+#include "wayland-xdg-shell-client-protocol.h"
+#include <QByteArray>
+#include <QString>
+
+struct wl_registry;
+
+QT_BEGIN_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_GCC("-Wmissing-field-initializers")
+
+namespace QtWayland {
+    class  xdg_wm_base
+    {
+    public:
+        xdg_wm_base(struct ::wl_registry *registry, int id, int version);
+        xdg_wm_base(struct ::xdg_wm_base *object);
+        xdg_wm_base();
+
+        virtual ~xdg_wm_base();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::xdg_wm_base *object);
+
+        struct ::xdg_wm_base *object() { return m_xdg_wm_base; }
+        const struct ::xdg_wm_base *object() const { return m_xdg_wm_base; }
+        static xdg_wm_base *fromObject(struct ::xdg_wm_base *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_role = 0, // given wl_surface has another role
+            error_defunct_surfaces = 1, // xdg_wm_base was destroyed before children
+            error_not_the_topmost_popup = 2, // the client tried to map or destroy a non-topmost popup
+            error_invalid_popup_parent = 3, // the client specified an invalid popup parent surface
+            error_invalid_surface_state = 4, // the client provided an invalid surface state
+            error_invalid_positioner = 5, // the client provided an invalid positioner
+        };
+
+        void destroy();
+        struct ::xdg_positioner *create_positioner();
+        struct ::xdg_surface *get_xdg_surface(struct ::wl_surface *surface);
+        void pong(uint32_t serial);
+
+    protected:
+        virtual void xdg_wm_base_ping(uint32_t serial);
+
+    private:
+        void init_listener();
+        static const struct xdg_wm_base_listener m_xdg_wm_base_listener;
+        static void handle_ping(
+            void *data,
+            struct ::xdg_wm_base *object,
+            uint32_t serial);
+        struct ::xdg_wm_base *m_xdg_wm_base;
+    };
+
+    class  xdg_positioner
+    {
+    public:
+        xdg_positioner(struct ::wl_registry *registry, int id, int version);
+        xdg_positioner(struct ::xdg_positioner *object);
+        xdg_positioner();
+
+        virtual ~xdg_positioner();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::xdg_positioner *object);
+
+        struct ::xdg_positioner *object() { return m_xdg_positioner; }
+        const struct ::xdg_positioner *object() const { return m_xdg_positioner; }
+        static xdg_positioner *fromObject(struct ::xdg_positioner *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_invalid_input = 0, // invalid input provided
+        };
+
+        enum anchor {
+            anchor_none = 0,
+            anchor_top = 1,
+            anchor_bottom = 2,
+            anchor_left = 3,
+            anchor_right = 4,
+            anchor_top_left = 5,
+            anchor_bottom_left = 6,
+            anchor_top_right = 7,
+            anchor_bottom_right = 8,
+        };
+
+        enum gravity {
+            gravity_none = 0,
+            gravity_top = 1,
+            gravity_bottom = 2,
+            gravity_left = 3,
+            gravity_right = 4,
+            gravity_top_left = 5,
+            gravity_bottom_left = 6,
+            gravity_top_right = 7,
+            gravity_bottom_right = 8,
+        };
+
+        enum constraint_adjustment {
+            constraint_adjustment_none = 0,
+            constraint_adjustment_slide_x = 1,
+            constraint_adjustment_slide_y = 2,
+            constraint_adjustment_flip_x = 4,
+            constraint_adjustment_flip_y = 8,
+            constraint_adjustment_resize_x = 16,
+            constraint_adjustment_resize_y = 32,
+        };
+
+        void destroy();
+        void set_size(int32_t width, int32_t height);
+        void set_anchor_rect(int32_t x, int32_t y, int32_t width, int32_t height);
+        void set_anchor(uint32_t anchor);
+        void set_gravity(uint32_t gravity);
+        void set_constraint_adjustment(uint32_t constraint_adjustment);
+        void set_offset(int32_t x, int32_t y);
+
+    private:
+        struct ::xdg_positioner *m_xdg_positioner;
+    };
+
+    class  xdg_surface
+    {
+    public:
+        xdg_surface(struct ::wl_registry *registry, int id, int version);
+        xdg_surface(struct ::xdg_surface *object);
+        xdg_surface();
+
+        virtual ~xdg_surface();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::xdg_surface *object);
+
+        struct ::xdg_surface *object() { return m_xdg_surface; }
+        const struct ::xdg_surface *object() const { return m_xdg_surface; }
+        static xdg_surface *fromObject(struct ::xdg_surface *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_not_constructed = 1,
+            error_already_constructed = 2,
+            error_unconfigured_buffer = 3,
+        };
+
+        void destroy();
+        struct ::xdg_toplevel *get_toplevel();
+        struct ::xdg_popup *get_popup(struct ::xdg_surface *parent, struct ::xdg_positioner *positioner);
+        void set_window_geometry(int32_t x, int32_t y, int32_t width, int32_t height);
+        void ack_configure(uint32_t serial);
+
+    protected:
+        virtual void xdg_surface_configure(uint32_t serial);
+
+    private:
+        void init_listener();
+        static const struct xdg_surface_listener m_xdg_surface_listener;
+        static void handle_configure(
+            void *data,
+            struct ::xdg_surface *object,
+            uint32_t serial);
+        struct ::xdg_surface *m_xdg_surface;
+    };
+
+    class  xdg_toplevel
+    {
+    public:
+        xdg_toplevel(struct ::wl_registry *registry, int id, int version);
+        xdg_toplevel(struct ::xdg_toplevel *object);
+        xdg_toplevel();
+
+        virtual ~xdg_toplevel();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::xdg_toplevel *object);
+
+        struct ::xdg_toplevel *object() { return m_xdg_toplevel; }
+        const struct ::xdg_toplevel *object() const { return m_xdg_toplevel; }
+        static xdg_toplevel *fromObject(struct ::xdg_toplevel *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum resize_edge {
+            resize_edge_none = 0,
+            resize_edge_top = 1,
+            resize_edge_bottom = 2,
+            resize_edge_left = 4,
+            resize_edge_top_left = 5,
+            resize_edge_bottom_left = 6,
+            resize_edge_right = 8,
+            resize_edge_top_right = 9,
+            resize_edge_bottom_right = 10,
+        };
+
+        enum state {
+            state_maximized = 1, // the surface is maximized
+            state_fullscreen = 2, // the surface is fullscreen
+            state_resizing = 3, // the surface is being resized
+            state_activated = 4, // the surface is now activated
+            state_tiled_left = 5,
+            state_tiled_right = 6,
+            state_tiled_top = 7,
+            state_tiled_bottom = 8,
+        };
+
+        void destroy();
+        void set_parent(struct ::xdg_toplevel *parent);
+        void set_title(const QString &title);
+        void set_app_id(const QString &app_id);
+        void show_window_menu(struct ::wl_seat *seat, uint32_t serial, int32_t x, int32_t y);
+        void move(struct ::wl_seat *seat, uint32_t serial);
+        void resize(struct ::wl_seat *seat, uint32_t serial, uint32_t edges);
+        void set_max_size(int32_t width, int32_t height);
+        void set_min_size(int32_t width, int32_t height);
+        void set_maximized();
+        void unset_maximized();
+        void set_fullscreen(struct ::wl_output *output);
+        void unset_fullscreen();
+        void set_minimized();
+
+    protected:
+        virtual void xdg_toplevel_configure(int32_t width, int32_t height, wl_array *states);
+        virtual void xdg_toplevel_close();
+
+    private:
+        void init_listener();
+        static const struct xdg_toplevel_listener m_xdg_toplevel_listener;
+        static void handle_configure(
+            void *data,
+            struct ::xdg_toplevel *object,
+            int32_t width,
+            int32_t height,
+            wl_array *states);
+        static void handle_close(
+            void *data,
+            struct ::xdg_toplevel *object);
+        struct ::xdg_toplevel *m_xdg_toplevel;
+    };
+
+    class  xdg_popup
+    {
+    public:
+        xdg_popup(struct ::wl_registry *registry, int id, int version);
+        xdg_popup(struct ::xdg_popup *object);
+        xdg_popup();
+
+        virtual ~xdg_popup();
+
+        void init(struct ::wl_registry *registry, int id, int version);
+        void init(struct ::xdg_popup *object);
+
+        struct ::xdg_popup *object() { return m_xdg_popup; }
+        const struct ::xdg_popup *object() const { return m_xdg_popup; }
+        static xdg_popup *fromObject(struct ::xdg_popup *object);
+
+        bool isInitialized() const;
+
+        static const struct ::wl_interface *interface();
+
+        enum error {
+            error_invalid_grab = 0, // tried to grab after being mapped
+        };
+
+        void destroy();
+        void grab(struct ::wl_seat *seat, uint32_t serial);
+
+    protected:
+        virtual void xdg_popup_configure(int32_t x, int32_t y, int32_t width, int32_t height);
+        virtual void xdg_popup_popup_done();
+
+    private:
+        void init_listener();
+        static const struct xdg_popup_listener m_xdg_popup_listener;
+        static void handle_configure(
+            void *data,
+            struct ::xdg_popup *object,
+            int32_t x,
+            int32_t y,
+            int32_t width,
+            int32_t height);
+        static void handle_popup_done(
+            void *data,
+            struct ::xdg_popup *object);
+        struct ::xdg_popup *m_xdg_popup;
+    };
+}
+
+QT_WARNING_POP
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/shellintegration/xdg-shell/wayland-xdg-decoration-unstable-v1-client-protocol.h b/src/plugins/shellintegration/xdg-shell/wayland-xdg-decoration-unstable-v1-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..e0a845b2b2ee1bd171ea69a6858a1c09816d71be
--- /dev/null
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/wayland-xdg-decoration-unstable-v1-client-protocol.h
@@ -0,0 +1,382 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef XDG_DECORATION_UNSTABLE_V1_CLIENT_PROTOCOL_H
+#define XDG_DECORATION_UNSTABLE_V1_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_decoration_unstable_v1 The xdg_decoration_unstable_v1 protocol
+ * @section page_ifaces_xdg_decoration_unstable_v1 Interfaces
+ * - @subpage page_iface_zxdg_decoration_manager_v1 - window decoration manager
+ * - @subpage page_iface_zxdg_toplevel_decoration_v1 - decoration object for a toplevel surface
+ * @section page_copyright_xdg_decoration_unstable_v1 Copyright
+ * <pre>
+ *
+ * Copyright © 2018 Simon Ser
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct xdg_toplevel;
+struct zxdg_decoration_manager_v1;
+struct zxdg_toplevel_decoration_v1;
+
+#ifndef ZXDG_DECORATION_MANAGER_V1_INTERFACE
+#define ZXDG_DECORATION_MANAGER_V1_INTERFACE
+/**
+ * @page page_iface_zxdg_decoration_manager_v1 zxdg_decoration_manager_v1
+ * @section page_iface_zxdg_decoration_manager_v1_desc Description
+ *
+ * This interface allows a compositor to announce support for server-side
+ * decorations.
+ *
+ * A window decoration is a set of window controls as deemed appropriate by
+ * the party managing them, such as user interface components used to move,
+ * resize and change a window's state.
+ *
+ * A client can use this protocol to request being decorated by a supporting
+ * compositor.
+ *
+ * If compositor and client do not negotiate the use of a server-side
+ * decoration using this protocol, clients continue to self-decorate as they
+ * see fit.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ * @section page_iface_zxdg_decoration_manager_v1_api API
+ * See @ref iface_zxdg_decoration_manager_v1.
+ */
+/**
+ * @defgroup iface_zxdg_decoration_manager_v1 The zxdg_decoration_manager_v1 interface
+ *
+ * This interface allows a compositor to announce support for server-side
+ * decorations.
+ *
+ * A window decoration is a set of window controls as deemed appropriate by
+ * the party managing them, such as user interface components used to move,
+ * resize and change a window's state.
+ *
+ * A client can use this protocol to request being decorated by a supporting
+ * compositor.
+ *
+ * If compositor and client do not negotiate the use of a server-side
+ * decoration using this protocol, clients continue to self-decorate as they
+ * see fit.
+ *
+ * Warning! The protocol described in this file is experimental and
+ * backward incompatible changes may be made. Backward compatible changes
+ * may be added together with the corresponding interface version bump.
+ * Backward incompatible changes are done by bumping the version number in
+ * the protocol and interface names and resetting the interface version.
+ * Once the protocol is to be declared stable, the 'z' prefix and the
+ * version number in the protocol and interface names are removed and the
+ * interface version number is reset.
+ */
+extern const struct wl_interface zxdg_decoration_manager_v1_interface;
+#endif
+#ifndef ZXDG_TOPLEVEL_DECORATION_V1_INTERFACE
+#define ZXDG_TOPLEVEL_DECORATION_V1_INTERFACE
+/**
+ * @page page_iface_zxdg_toplevel_decoration_v1 zxdg_toplevel_decoration_v1
+ * @section page_iface_zxdg_toplevel_decoration_v1_desc Description
+ *
+ * The decoration object allows the compositor to toggle server-side window
+ * decorations for a toplevel surface. The client can request to switch to
+ * another mode.
+ *
+ * The xdg_toplevel_decoration object must be destroyed before its
+ * xdg_toplevel.
+ * @section page_iface_zxdg_toplevel_decoration_v1_api API
+ * See @ref iface_zxdg_toplevel_decoration_v1.
+ */
+/**
+ * @defgroup iface_zxdg_toplevel_decoration_v1 The zxdg_toplevel_decoration_v1 interface
+ *
+ * The decoration object allows the compositor to toggle server-side window
+ * decorations for a toplevel surface. The client can request to switch to
+ * another mode.
+ *
+ * The xdg_toplevel_decoration object must be destroyed before its
+ * xdg_toplevel.
+ */
+extern const struct wl_interface zxdg_toplevel_decoration_v1_interface;
+#endif
+
+#define ZXDG_DECORATION_MANAGER_V1_DESTROY 0
+#define ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION 1
+
+
+/**
+ * @ingroup iface_zxdg_decoration_manager_v1
+ */
+#define ZXDG_DECORATION_MANAGER_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_decoration_manager_v1
+ */
+#define ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_decoration_manager_v1 */
+static inline void
+zxdg_decoration_manager_v1_set_user_data(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_decoration_manager_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_decoration_manager_v1 */
+static inline void *
+zxdg_decoration_manager_v1_get_user_data(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_decoration_manager_v1);
+}
+
+static inline uint32_t
+zxdg_decoration_manager_v1_get_version(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_decoration_manager_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_decoration_manager_v1
+ *
+ * Destroy the decoration manager. This doesn't destroy objects created
+ * with the manager.
+ */
+static inline void
+zxdg_decoration_manager_v1_destroy(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_decoration_manager_v1,
+			 ZXDG_DECORATION_MANAGER_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_decoration_manager_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_decoration_manager_v1
+ *
+ * Create a new decoration object associated with the given toplevel.
+ *
+ * Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
+ * buffer attached or committed is a client error, and any attempts by a
+ * client to attach or manipulate a buffer prior to the first
+ * xdg_toplevel_decoration.configure event must also be treated as
+ * errors.
+ */
+static inline struct zxdg_toplevel_decoration_v1 *
+zxdg_decoration_manager_v1_get_toplevel_decoration(struct zxdg_decoration_manager_v1 *zxdg_decoration_manager_v1, struct xdg_toplevel *toplevel)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) zxdg_decoration_manager_v1,
+			 ZXDG_DECORATION_MANAGER_V1_GET_TOPLEVEL_DECORATION, &zxdg_toplevel_decoration_v1_interface, NULL, toplevel);
+
+	return (struct zxdg_toplevel_decoration_v1 *) id;
+}
+
+#ifndef ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM
+#define ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM
+enum zxdg_toplevel_decoration_v1_error {
+	/**
+	 * xdg_toplevel has a buffer attached before configure
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_UNCONFIGURED_BUFFER = 0,
+	/**
+	 * xdg_toplevel already has a decoration object
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ALREADY_CONSTRUCTED = 1,
+	/**
+	 * xdg_toplevel destroyed before the decoration object
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ORPHANED = 2,
+};
+#endif /* ZXDG_TOPLEVEL_DECORATION_V1_ERROR_ENUM */
+
+#ifndef ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM
+#define ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ * window decoration modes
+ *
+ * These values describe window decoration modes.
+ */
+enum zxdg_toplevel_decoration_v1_mode {
+	/**
+	 * no server-side window decoration
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_MODE_CLIENT_SIDE = 1,
+	/**
+	 * server-side window decoration
+	 */
+	ZXDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE = 2,
+};
+#endif /* ZXDG_TOPLEVEL_DECORATION_V1_MODE_ENUM */
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ * @struct zxdg_toplevel_decoration_v1_listener
+ */
+struct zxdg_toplevel_decoration_v1_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * The configure event asks the client to change its decoration
+	 * mode. The configured state should not be applied immediately.
+	 * Clients must send an ack_configure in response to this event.
+	 * See xdg_surface.configure and xdg_surface.ack_configure for
+	 * details.
+	 *
+	 * A configure event can be sent at any time. The specified mode
+	 * must be obeyed by the client.
+	 * @param mode the decoration mode
+	 */
+	void (*configure)(void *data,
+			  struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1,
+			  uint32_t mode);
+};
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+static inline int
+zxdg_toplevel_decoration_v1_add_listener(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1,
+					 const struct zxdg_toplevel_decoration_v1_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) zxdg_toplevel_decoration_v1,
+				     (void (**)(void)) listener, data);
+}
+
+#define ZXDG_TOPLEVEL_DECORATION_V1_DESTROY 0
+#define ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE 1
+#define ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE 2
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+#define ZXDG_TOPLEVEL_DECORATION_V1_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+#define ZXDG_TOPLEVEL_DECORATION_V1_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+#define ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE_SINCE_VERSION 1
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ */
+#define ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE_SINCE_VERSION 1
+
+/** @ingroup iface_zxdg_toplevel_decoration_v1 */
+static inline void
+zxdg_toplevel_decoration_v1_set_user_data(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) zxdg_toplevel_decoration_v1, user_data);
+}
+
+/** @ingroup iface_zxdg_toplevel_decoration_v1 */
+static inline void *
+zxdg_toplevel_decoration_v1_get_user_data(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_toplevel_decoration_v1);
+}
+
+static inline uint32_t
+zxdg_toplevel_decoration_v1_get_version(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
+{
+	return wl_proxy_get_version((struct wl_proxy *) zxdg_toplevel_decoration_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ *
+ * Switch back to a mode without any server-side decorations at the next
+ * commit.
+ */
+static inline void
+zxdg_toplevel_decoration_v1_destroy(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_decoration_v1,
+			 ZXDG_TOPLEVEL_DECORATION_V1_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) zxdg_toplevel_decoration_v1);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ *
+ * Set the toplevel surface decoration mode. This informs the compositor
+ * that the client prefers the provided decoration mode.
+ *
+ * After requesting a decoration mode, the compositor will respond by
+ * emitting a xdg_surface.configure event. The client should then update
+ * its content, drawing it without decorations if the received mode is
+ * server-side decorations. The client must also acknowledge the configure
+ * when committing the new content (see xdg_surface.ack_configure).
+ *
+ * The compositor can decide not to use the client's mode and enforce a
+ * different mode instead.
+ *
+ * Clients whose decoration mode depend on the xdg_toplevel state may send
+ * a set_mode request in response to a xdg_surface.configure event and wait
+ * for the next xdg_surface.configure event to prevent unwanted state.
+ * Such clients are responsible for preventing configure loops and must
+ * make sure not to send multiple successive set_mode requests with the
+ * same decoration mode.
+ */
+static inline void
+zxdg_toplevel_decoration_v1_set_mode(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1, uint32_t mode)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_decoration_v1,
+			 ZXDG_TOPLEVEL_DECORATION_V1_SET_MODE, mode);
+}
+
+/**
+ * @ingroup iface_zxdg_toplevel_decoration_v1
+ *
+ * Unset the toplevel surface decoration mode. This informs the compositor
+ * that the client doesn't prefer a particular decoration mode.
+ *
+ * This request has the same semantics as set_mode.
+ */
+static inline void
+zxdg_toplevel_decoration_v1_unset_mode(struct zxdg_toplevel_decoration_v1 *zxdg_toplevel_decoration_v1)
+{
+	wl_proxy_marshal((struct wl_proxy *) zxdg_toplevel_decoration_v1,
+			 ZXDG_TOPLEVEL_DECORATION_V1_UNSET_MODE);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/plugins/shellintegration/xdg-shell/wayland-xdg-decoration-unstable-v1-protocol.c b/src/plugins/shellintegration/xdg-shell/wayland-xdg-decoration-unstable-v1-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..763bc86f25a88480b143b2e34564410eaf9d850a
--- /dev/null
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/wayland-xdg-decoration-unstable-v1-protocol.c
@@ -0,0 +1,65 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright © 2018 Simon Ser
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface xdg_toplevel_interface;
+extern const struct wl_interface zxdg_toplevel_decoration_v1_interface;
+
+static const struct wl_interface *xdg_decoration_unstable_v1_types[] = {
+	NULL,
+	&zxdg_toplevel_decoration_v1_interface,
+	&xdg_toplevel_interface,
+};
+
+static const struct wl_message zxdg_decoration_manager_v1_requests[] = {
+	{ "destroy", "", xdg_decoration_unstable_v1_types + 0 },
+	{ "get_toplevel_decoration", "no", xdg_decoration_unstable_v1_types + 1 },
+};
+
+WL_EXPORT const struct wl_interface zxdg_decoration_manager_v1_interface = {
+	"zxdg_decoration_manager_v1", 1,
+	2, zxdg_decoration_manager_v1_requests,
+	0, NULL,
+};
+
+static const struct wl_message zxdg_toplevel_decoration_v1_requests[] = {
+	{ "destroy", "", xdg_decoration_unstable_v1_types + 0 },
+	{ "set_mode", "u", xdg_decoration_unstable_v1_types + 0 },
+	{ "unset_mode", "", xdg_decoration_unstable_v1_types + 0 },
+};
+
+static const struct wl_message zxdg_toplevel_decoration_v1_events[] = {
+	{ "configure", "u", xdg_decoration_unstable_v1_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface zxdg_toplevel_decoration_v1_interface = {
+	"zxdg_toplevel_decoration_v1", 1,
+	3, zxdg_toplevel_decoration_v1_requests,
+	1, zxdg_toplevel_decoration_v1_events,
+};
+
diff --git a/src/plugins/shellintegration/xdg-shell/wayland-xdg-shell-client-protocol.h b/src/plugins/shellintegration/xdg-shell/wayland-xdg-shell-client-protocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..14f1bb7247ba3ae88f5f1a2363cd03d972c077f3
--- /dev/null
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/wayland-xdg-shell-client-protocol.h
@@ -0,0 +1,1857 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+#ifndef XDG_SHELL_CLIENT_PROTOCOL_H
+#define XDG_SHELL_CLIENT_PROTOCOL_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include <wayland_client-so_wrap.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @page page_xdg_shell The xdg_shell protocol
+ * @section page_ifaces_xdg_shell Interfaces
+ * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
+ * - @subpage page_iface_xdg_positioner - child surface positioner
+ * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
+ * - @subpage page_iface_xdg_toplevel - toplevel surface
+ * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
+ * @section page_copyright_xdg_shell Copyright
+ * <pre>
+ *
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ * Copyright © 2015-2017 Samsung Electronics Co., Ltd
+ * Copyright © 2015-2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ * </pre>
+ */
+struct wl_output;
+struct wl_seat;
+struct wl_surface;
+struct xdg_popup;
+struct xdg_positioner;
+struct xdg_surface;
+struct xdg_toplevel;
+struct xdg_wm_base;
+
+#ifndef XDG_WM_BASE_INTERFACE
+#define XDG_WM_BASE_INTERFACE
+/**
+ * @page page_iface_xdg_wm_base xdg_wm_base
+ * @section page_iface_xdg_wm_base_desc Description
+ *
+ * The xdg_wm_base interface is exposed as a global object enabling clients
+ * to turn their wl_surfaces into windows in a desktop environment. It
+ * defines the basic functionality needed for clients and the compositor to
+ * create windows that can be dragged, resized, maximized, etc, as well as
+ * creating transient windows such as popup menus.
+ * @section page_iface_xdg_wm_base_api API
+ * See @ref iface_xdg_wm_base.
+ */
+/**
+ * @defgroup iface_xdg_wm_base The xdg_wm_base interface
+ *
+ * The xdg_wm_base interface is exposed as a global object enabling clients
+ * to turn their wl_surfaces into windows in a desktop environment. It
+ * defines the basic functionality needed for clients and the compositor to
+ * create windows that can be dragged, resized, maximized, etc, as well as
+ * creating transient windows such as popup menus.
+ */
+extern const struct wl_interface xdg_wm_base_interface;
+#endif
+#ifndef XDG_POSITIONER_INTERFACE
+#define XDG_POSITIONER_INTERFACE
+/**
+ * @page page_iface_xdg_positioner xdg_positioner
+ * @section page_iface_xdg_positioner_desc Description
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle. These positioner-created rules are
+ * constrained by the requirement that a child surface must intersect with or
+ * be at least partially adjacent to its parent surface.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an error.
+ * @section page_iface_xdg_positioner_api API
+ * See @ref iface_xdg_positioner.
+ */
+/**
+ * @defgroup iface_xdg_positioner The xdg_positioner interface
+ *
+ * The xdg_positioner provides a collection of rules for the placement of a
+ * child surface relative to a parent surface. Rules can be defined to ensure
+ * the child surface remains within the visible area's borders, and to
+ * specify how the child surface changes its position, such as sliding along
+ * an axis, or flipping around a rectangle. These positioner-created rules are
+ * constrained by the requirement that a child surface must intersect with or
+ * be at least partially adjacent to its parent surface.
+ *
+ * See the various requests for details about possible rules.
+ *
+ * At the time of the request, the compositor makes a copy of the rules
+ * specified by the xdg_positioner. Thus, after the request is complete the
+ * xdg_positioner object can be destroyed or reused; further changes to the
+ * object will have no effect on previous usages.
+ *
+ * For an xdg_positioner object to be considered complete, it must have a
+ * non-zero size set by set_size, and a non-zero anchor rectangle set by
+ * set_anchor_rect. Passing an incomplete xdg_positioner object when
+ * positioning a surface raises an error.
+ */
+extern const struct wl_interface xdg_positioner_interface;
+#endif
+#ifndef XDG_SURFACE_INTERFACE
+#define XDG_SURFACE_INTERFACE
+/**
+ * @page page_iface_xdg_surface xdg_surface
+ * @section page_iface_xdg_surface_desc Description
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * Mapping an xdg_surface-based role surface is defined as making it
+ * possible for the surface to be shown by the compositor. Note that
+ * a mapped surface is not guaranteed to be visible once it is mapped.
+ *
+ * For an xdg_surface to be mapped by the compositor, the following
+ * conditions must be met:
+ * (1) the client has assigned an xdg_surface-based role to the surface
+ * (2) the client has set and committed the xdg_surface state and the
+ * role-dependent state to the surface
+ * (3) the client has committed a buffer to the surface
+ *
+ * A newly-unmapped surface is considered to have met condition (1) out
+ * of the 3 required conditions for mapping a surface if its role surface
+ * has not been destroyed.
+ * @section page_iface_xdg_surface_api API
+ * See @ref iface_xdg_surface.
+ */
+/**
+ * @defgroup iface_xdg_surface The xdg_surface interface
+ *
+ * An interface that may be implemented by a wl_surface, for
+ * implementations that provide a desktop-style user interface.
+ *
+ * It provides a base set of functionality required to construct user
+ * interface elements requiring management by the compositor, such as
+ * toplevel windows, menus, etc. The types of functionality are split into
+ * xdg_surface roles.
+ *
+ * Creating an xdg_surface does not set the role for a wl_surface. In order
+ * to map an xdg_surface, the client must create a role-specific object
+ * using, e.g., get_toplevel, get_popup. The wl_surface for any given
+ * xdg_surface can have at most one role, and may not be assigned any role
+ * not based on xdg_surface.
+ *
+ * A role must be assigned before any other requests are made to the
+ * xdg_surface object.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_surface state to take effect.
+ *
+ * Creating an xdg_surface from a wl_surface which has a buffer attached or
+ * committed is a client error, and any attempts by a client to attach or
+ * manipulate a buffer prior to the first xdg_surface.configure call must
+ * also be treated as errors.
+ *
+ * Mapping an xdg_surface-based role surface is defined as making it
+ * possible for the surface to be shown by the compositor. Note that
+ * a mapped surface is not guaranteed to be visible once it is mapped.
+ *
+ * For an xdg_surface to be mapped by the compositor, the following
+ * conditions must be met:
+ * (1) the client has assigned an xdg_surface-based role to the surface
+ * (2) the client has set and committed the xdg_surface state and the
+ * role-dependent state to the surface
+ * (3) the client has committed a buffer to the surface
+ *
+ * A newly-unmapped surface is considered to have met condition (1) out
+ * of the 3 required conditions for mapping a surface if its role surface
+ * has not been destroyed.
+ */
+extern const struct wl_interface xdg_surface_interface;
+#endif
+#ifndef XDG_TOPLEVEL_INTERFACE
+#define XDG_TOPLEVEL_INTERFACE
+/**
+ * @page page_iface_xdg_toplevel xdg_toplevel
+ * @section page_iface_xdg_toplevel_desc Description
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ *
+ * Unmapping an xdg_toplevel means that the surface cannot be shown
+ * by the compositor until it is explicitly mapped again.
+ * All active operations (e.g., move, resize) are canceled and all
+ * attributes (e.g. title, state, stacking, ...) are discarded for
+ * an xdg_toplevel surface when it is unmapped.
+ *
+ * Attaching a null buffer to a toplevel unmaps the surface.
+ * @section page_iface_xdg_toplevel_api API
+ * See @ref iface_xdg_toplevel.
+ */
+/**
+ * @defgroup iface_xdg_toplevel The xdg_toplevel interface
+ *
+ * This interface defines an xdg_surface role which allows a surface to,
+ * among other things, set window-like properties such as maximize,
+ * fullscreen, and minimize, set application-specific metadata like title and
+ * id, and well as trigger user interactive operations such as interactive
+ * resize and move.
+ *
+ * Unmapping an xdg_toplevel means that the surface cannot be shown
+ * by the compositor until it is explicitly mapped again.
+ * All active operations (e.g., move, resize) are canceled and all
+ * attributes (e.g. title, state, stacking, ...) are discarded for
+ * an xdg_toplevel surface when it is unmapped.
+ *
+ * Attaching a null buffer to a toplevel unmaps the surface.
+ */
+extern const struct wl_interface xdg_toplevel_interface;
+#endif
+#ifndef XDG_POPUP_INTERFACE
+#define XDG_POPUP_INTERFACE
+/**
+ * @page page_iface_xdg_popup xdg_popup
+ * @section page_iface_xdg_popup_desc Description
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The x and y arguments passed when creating the popup object specify
+ * where the top left of the popup should be placed, relative to the
+ * local surface coordinates of the parent surface. See
+ * xdg_surface.get_popup. An xdg_popup must intersect with or be at least
+ * partially adjacent to its parent surface.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ * @section page_iface_xdg_popup_api API
+ * See @ref iface_xdg_popup.
+ */
+/**
+ * @defgroup iface_xdg_popup The xdg_popup interface
+ *
+ * A popup surface is a short-lived, temporary surface. It can be used to
+ * implement for example menus, popovers, tooltips and other similar user
+ * interface concepts.
+ *
+ * A popup can be made to take an explicit grab. See xdg_popup.grab for
+ * details.
+ *
+ * When the popup is dismissed, a popup_done event will be sent out, and at
+ * the same time the surface will be unmapped. See the xdg_popup.popup_done
+ * event for details.
+ *
+ * Explicitly destroying the xdg_popup object will also dismiss the popup and
+ * unmap the surface. Clients that want to dismiss the popup when another
+ * surface of their own is clicked should dismiss the popup using the destroy
+ * request.
+ *
+ * A newly created xdg_popup will be stacked on top of all previously created
+ * xdg_popup surfaces associated with the same xdg_toplevel.
+ *
+ * The parent of an xdg_popup must be mapped (see the xdg_surface
+ * description) before the xdg_popup itself.
+ *
+ * The x and y arguments passed when creating the popup object specify
+ * where the top left of the popup should be placed, relative to the
+ * local surface coordinates of the parent surface. See
+ * xdg_surface.get_popup. An xdg_popup must intersect with or be at least
+ * partially adjacent to its parent surface.
+ *
+ * The client must call wl_surface.commit on the corresponding wl_surface
+ * for the xdg_popup state to take effect.
+ */
+extern const struct wl_interface xdg_popup_interface;
+#endif
+
+#ifndef XDG_WM_BASE_ERROR_ENUM
+#define XDG_WM_BASE_ERROR_ENUM
+enum xdg_wm_base_error {
+	/**
+	 * given wl_surface has another role
+	 */
+	XDG_WM_BASE_ERROR_ROLE = 0,
+	/**
+	 * xdg_wm_base was destroyed before children
+	 */
+	XDG_WM_BASE_ERROR_DEFUNCT_SURFACES = 1,
+	/**
+	 * the client tried to map or destroy a non-topmost popup
+	 */
+	XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP = 2,
+	/**
+	 * the client specified an invalid popup parent surface
+	 */
+	XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT = 3,
+	/**
+	 * the client provided an invalid surface state
+	 */
+	XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE = 4,
+	/**
+	 * the client provided an invalid positioner
+	 */
+	XDG_WM_BASE_ERROR_INVALID_POSITIONER = 5,
+};
+#endif /* XDG_WM_BASE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_wm_base
+ * @struct xdg_wm_base_listener
+ */
+struct xdg_wm_base_listener {
+	/**
+	 * check if the client is alive
+	 *
+	 * The ping event asks the client if it's still alive. Pass the
+	 * serial specified in the event back to the compositor by sending
+	 * a "pong" request back with the specified serial. See
+	 * xdg_wm_base.pong.
+	 *
+	 * Compositors can use this to determine if the client is still
+	 * alive. It's unspecified what will happen if the client doesn't
+	 * respond to the ping request, or in what timeframe. Clients
+	 * should try to respond in a reasonable amount of time.
+	 *
+	 * A compositor is free to ping in any way it wants, but a client
+	 * must always respond to any xdg_wm_base object it created.
+	 * @param serial pass this to the pong request
+	 */
+	void (*ping)(void *data,
+		     struct xdg_wm_base *xdg_wm_base,
+		     uint32_t serial);
+};
+
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+static inline int
+xdg_wm_base_add_listener(struct xdg_wm_base *xdg_wm_base,
+			 const struct xdg_wm_base_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_wm_base,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_WM_BASE_DESTROY 0
+#define XDG_WM_BASE_CREATE_POSITIONER 1
+#define XDG_WM_BASE_GET_XDG_SURFACE 2
+#define XDG_WM_BASE_PONG 3
+
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_PING_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_CREATE_POSITIONER_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_GET_XDG_SURFACE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_wm_base
+ */
+#define XDG_WM_BASE_PONG_SINCE_VERSION 1
+
+/** @ingroup iface_xdg_wm_base */
+static inline void
+xdg_wm_base_set_user_data(struct xdg_wm_base *xdg_wm_base, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_wm_base, user_data);
+}
+
+/** @ingroup iface_xdg_wm_base */
+static inline void *
+xdg_wm_base_get_user_data(struct xdg_wm_base *xdg_wm_base)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_wm_base);
+}
+
+static inline uint32_t
+xdg_wm_base_get_version(struct xdg_wm_base *xdg_wm_base)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_wm_base);
+}
+
+/**
+ * @ingroup iface_xdg_wm_base
+ *
+ * Destroy this xdg_wm_base object.
+ *
+ * Destroying a bound xdg_wm_base object while there are surfaces
+ * still alive created by this xdg_wm_base object instance is illegal
+ * and will result in a protocol error.
+ */
+static inline void
+xdg_wm_base_destroy(struct xdg_wm_base *xdg_wm_base)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_wm_base,
+			 XDG_WM_BASE_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) xdg_wm_base);
+}
+
+/**
+ * @ingroup iface_xdg_wm_base
+ *
+ * Create a positioner object. A positioner object is used to position
+ * surfaces relative to some parent surface. See the interface description
+ * and xdg_surface.get_popup for details.
+ */
+static inline struct xdg_positioner *
+xdg_wm_base_create_positioner(struct xdg_wm_base *xdg_wm_base)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) xdg_wm_base,
+			 XDG_WM_BASE_CREATE_POSITIONER, &xdg_positioner_interface, NULL);
+
+	return (struct xdg_positioner *) id;
+}
+
+/**
+ * @ingroup iface_xdg_wm_base
+ *
+ * This creates an xdg_surface for the given surface. While xdg_surface
+ * itself is not a role, the corresponding surface may only be assigned
+ * a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
+ *
+ * This creates an xdg_surface for the given surface. An xdg_surface is
+ * used as basis to define a role to a given surface, such as xdg_toplevel
+ * or xdg_popup. It also manages functionality shared between xdg_surface
+ * based surface roles.
+ *
+ * See the documentation of xdg_surface for more details about what an
+ * xdg_surface is and how it is used.
+ */
+static inline struct xdg_surface *
+xdg_wm_base_get_xdg_surface(struct xdg_wm_base *xdg_wm_base, struct wl_surface *surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) xdg_wm_base,
+			 XDG_WM_BASE_GET_XDG_SURFACE, &xdg_surface_interface, NULL, surface);
+
+	return (struct xdg_surface *) id;
+}
+
+/**
+ * @ingroup iface_xdg_wm_base
+ *
+ * A client must respond to a ping event with a pong request or
+ * the client may be deemed unresponsive. See xdg_wm_base.ping.
+ */
+static inline void
+xdg_wm_base_pong(struct xdg_wm_base *xdg_wm_base, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_wm_base,
+			 XDG_WM_BASE_PONG, serial);
+}
+
+#ifndef XDG_POSITIONER_ERROR_ENUM
+#define XDG_POSITIONER_ERROR_ENUM
+enum xdg_positioner_error {
+	/**
+	 * invalid input provided
+	 */
+	XDG_POSITIONER_ERROR_INVALID_INPUT = 0,
+};
+#endif /* XDG_POSITIONER_ERROR_ENUM */
+
+#ifndef XDG_POSITIONER_ANCHOR_ENUM
+#define XDG_POSITIONER_ANCHOR_ENUM
+enum xdg_positioner_anchor {
+	XDG_POSITIONER_ANCHOR_NONE = 0,
+	XDG_POSITIONER_ANCHOR_TOP = 1,
+	XDG_POSITIONER_ANCHOR_BOTTOM = 2,
+	XDG_POSITIONER_ANCHOR_LEFT = 3,
+	XDG_POSITIONER_ANCHOR_RIGHT = 4,
+	XDG_POSITIONER_ANCHOR_TOP_LEFT = 5,
+	XDG_POSITIONER_ANCHOR_BOTTOM_LEFT = 6,
+	XDG_POSITIONER_ANCHOR_TOP_RIGHT = 7,
+	XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT = 8,
+};
+#endif /* XDG_POSITIONER_ANCHOR_ENUM */
+
+#ifndef XDG_POSITIONER_GRAVITY_ENUM
+#define XDG_POSITIONER_GRAVITY_ENUM
+enum xdg_positioner_gravity {
+	XDG_POSITIONER_GRAVITY_NONE = 0,
+	XDG_POSITIONER_GRAVITY_TOP = 1,
+	XDG_POSITIONER_GRAVITY_BOTTOM = 2,
+	XDG_POSITIONER_GRAVITY_LEFT = 3,
+	XDG_POSITIONER_GRAVITY_RIGHT = 4,
+	XDG_POSITIONER_GRAVITY_TOP_LEFT = 5,
+	XDG_POSITIONER_GRAVITY_BOTTOM_LEFT = 6,
+	XDG_POSITIONER_GRAVITY_TOP_RIGHT = 7,
+	XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT = 8,
+};
+#endif /* XDG_POSITIONER_GRAVITY_ENUM */
+
+#ifndef XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
+#define XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
+/**
+ * @ingroup iface_xdg_positioner
+ * vertically resize the surface
+ *
+ * Resize the surface vertically so that it is completely unconstrained.
+ */
+enum xdg_positioner_constraint_adjustment {
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE = 0,
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
+	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
+};
+#endif /* XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM */
+
+#define XDG_POSITIONER_DESTROY 0
+#define XDG_POSITIONER_SET_SIZE 1
+#define XDG_POSITIONER_SET_ANCHOR_RECT 2
+#define XDG_POSITIONER_SET_ANCHOR 3
+#define XDG_POSITIONER_SET_GRAVITY 4
+#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT 5
+#define XDG_POSITIONER_SET_OFFSET 6
+
+
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_ANCHOR_RECT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_ANCHOR_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_GRAVITY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_positioner
+ */
+#define XDG_POSITIONER_SET_OFFSET_SINCE_VERSION 1
+
+/** @ingroup iface_xdg_positioner */
+static inline void
+xdg_positioner_set_user_data(struct xdg_positioner *xdg_positioner, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_positioner, user_data);
+}
+
+/** @ingroup iface_xdg_positioner */
+static inline void *
+xdg_positioner_get_user_data(struct xdg_positioner *xdg_positioner)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_positioner);
+}
+
+static inline uint32_t
+xdg_positioner_get_version(struct xdg_positioner *xdg_positioner)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_positioner);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Notify the compositor that the xdg_positioner will no longer be used.
+ */
+static inline void
+xdg_positioner_destroy(struct xdg_positioner *xdg_positioner)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) xdg_positioner);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Set the size of the surface that is to be positioned with the positioner
+ * object. The size is in surface-local coordinates and corresponds to the
+ * window geometry. See xdg_surface.set_window_geometry.
+ *
+ * If a zero or negative size is set the invalid_input error is raised.
+ */
+static inline void
+xdg_positioner_set_size(struct xdg_positioner *xdg_positioner, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Specify the anchor rectangle within the parent surface that the child
+ * surface will be placed relative to. The rectangle is relative to the
+ * window geometry as defined by xdg_surface.set_window_geometry of the
+ * parent surface.
+ *
+ * When the xdg_positioner object is used to position a child surface, the
+ * anchor rectangle may not extend outside the window geometry of the
+ * positioned child's parent surface.
+ *
+ * If a negative size is set the invalid_input error is raised.
+ */
+static inline void
+xdg_positioner_set_anchor_rect(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_ANCHOR_RECT, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Defines the anchor point for the anchor rectangle. The specified anchor
+ * is used derive an anchor point that the child surface will be
+ * positioned relative to. If a corner anchor is set (e.g. 'top_left' or
+ * 'bottom_right'), the anchor point will be at the specified corner;
+ * otherwise, the derived anchor point will be centered on the specified
+ * edge, or in the center of the anchor rectangle if no edge is specified.
+ */
+static inline void
+xdg_positioner_set_anchor(struct xdg_positioner *xdg_positioner, uint32_t anchor)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_ANCHOR, anchor);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Defines in what direction a surface should be positioned, relative to
+ * the anchor point of the parent surface. If a corner gravity is
+ * specified (e.g. 'bottom_right' or 'top_left'), then the child surface
+ * will be placed towards the specified gravity; otherwise, the child
+ * surface will be centered over the anchor point on any axis that had no
+ * gravity specified.
+ */
+static inline void
+xdg_positioner_set_gravity(struct xdg_positioner *xdg_positioner, uint32_t gravity)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_GRAVITY, gravity);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Specify how the window should be positioned if the originally intended
+ * position caused the surface to be constrained, meaning at least
+ * partially outside positioning boundaries set by the compositor. The
+ * adjustment is set by constructing a bitmask describing the adjustment to
+ * be made when the surface is constrained on that axis.
+ *
+ * If no bit for one axis is set, the compositor will assume that the child
+ * surface should not change its position on that axis when constrained.
+ *
+ * If more than one bit for one axis is set, the order of how adjustments
+ * are applied is specified in the corresponding adjustment descriptions.
+ *
+ * The default adjustment is none.
+ */
+static inline void
+xdg_positioner_set_constraint_adjustment(struct xdg_positioner *xdg_positioner, uint32_t constraint_adjustment)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT, constraint_adjustment);
+}
+
+/**
+ * @ingroup iface_xdg_positioner
+ *
+ * Specify the surface position offset relative to the position of the
+ * anchor on the anchor rectangle and the anchor on the surface. For
+ * example if the anchor of the anchor rectangle is at (x, y), the surface
+ * has the gravity bottom|right, and the offset is (ox, oy), the calculated
+ * surface position will be (x + ox, y + oy). The offset position of the
+ * surface is the one used for constraint testing. See
+ * set_constraint_adjustment.
+ *
+ * An example use case is placing a popup menu on top of a user interface
+ * element, while aligning the user interface element of the parent surface
+ * with some user interface element placed somewhere in the popup surface.
+ */
+static inline void
+xdg_positioner_set_offset(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_positioner,
+			 XDG_POSITIONER_SET_OFFSET, x, y);
+}
+
+#ifndef XDG_SURFACE_ERROR_ENUM
+#define XDG_SURFACE_ERROR_ENUM
+enum xdg_surface_error {
+	XDG_SURFACE_ERROR_NOT_CONSTRUCTED = 1,
+	XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED = 2,
+	XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER = 3,
+};
+#endif /* XDG_SURFACE_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_surface
+ * @struct xdg_surface_listener
+ */
+struct xdg_surface_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * The configure event marks the end of a configure sequence. A
+	 * configure sequence is a set of one or more events configuring
+	 * the state of the xdg_surface, including the final
+	 * xdg_surface.configure event.
+	 *
+	 * Where applicable, xdg_surface surface roles will during a
+	 * configure sequence extend this event as a latched state sent as
+	 * events before the xdg_surface.configure event. Such events
+	 * should be considered to make up a set of atomically applied
+	 * configuration states, where the xdg_surface.configure commits
+	 * the accumulated state.
+	 *
+	 * Clients should arrange their surface for the new states, and
+	 * then send an ack_configure request with the serial sent in this
+	 * configure event at some point before committing the new surface.
+	 *
+	 * If the client receives multiple configure events before it can
+	 * respond to one, it is free to discard all but the last event it
+	 * received.
+	 * @param serial serial of the configure event
+	 */
+	void (*configure)(void *data,
+			  struct xdg_surface *xdg_surface,
+			  uint32_t serial);
+};
+
+/**
+ * @ingroup iface_xdg_surface
+ */
+static inline int
+xdg_surface_add_listener(struct xdg_surface *xdg_surface,
+			 const struct xdg_surface_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_surface,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_SURFACE_DESTROY 0
+#define XDG_SURFACE_GET_TOPLEVEL 1
+#define XDG_SURFACE_GET_POPUP 2
+#define XDG_SURFACE_SET_WINDOW_GEOMETRY 3
+#define XDG_SURFACE_ACK_CONFIGURE 4
+
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_CONFIGURE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_GET_TOPLEVEL_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_GET_POPUP_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_SET_WINDOW_GEOMETRY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_surface
+ */
+#define XDG_SURFACE_ACK_CONFIGURE_SINCE_VERSION 1
+
+/** @ingroup iface_xdg_surface */
+static inline void
+xdg_surface_set_user_data(struct xdg_surface *xdg_surface, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_surface, user_data);
+}
+
+/** @ingroup iface_xdg_surface */
+static inline void *
+xdg_surface_get_user_data(struct xdg_surface *xdg_surface)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_surface);
+}
+
+static inline uint32_t
+xdg_surface_get_version(struct xdg_surface *xdg_surface)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_surface);
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * Destroy the xdg_surface object. An xdg_surface must only be destroyed
+ * after its role object has been destroyed.
+ */
+static inline void
+xdg_surface_destroy(struct xdg_surface *xdg_surface)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) xdg_surface);
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * This creates an xdg_toplevel object for the given xdg_surface and gives
+ * the associated wl_surface the xdg_toplevel role.
+ *
+ * See the documentation of xdg_toplevel for more details about what an
+ * xdg_toplevel is and how it is used.
+ */
+static inline struct xdg_toplevel *
+xdg_surface_get_toplevel(struct xdg_surface *xdg_surface)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_GET_TOPLEVEL, &xdg_toplevel_interface, NULL);
+
+	return (struct xdg_toplevel *) id;
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * This creates an xdg_popup object for the given xdg_surface and gives
+ * the associated wl_surface the xdg_popup role.
+ *
+ * If null is passed as a parent, a parent surface must be specified using
+ * some other protocol, before committing the initial state.
+ *
+ * See the documentation of xdg_popup for more details about what an
+ * xdg_popup is and how it is used.
+ */
+static inline struct xdg_popup *
+xdg_surface_get_popup(struct xdg_surface *xdg_surface, struct xdg_surface *parent, struct xdg_positioner *positioner)
+{
+	struct wl_proxy *id;
+
+	id = wl_proxy_marshal_constructor((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_GET_POPUP, &xdg_popup_interface, NULL, parent, positioner);
+
+	return (struct xdg_popup *) id;
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * The window geometry of a surface is its "visible bounds" from the
+ * user's perspective. Client-side decorations often have invisible
+ * portions like drop-shadows which should be ignored for the
+ * purposes of aligning, placing and constraining windows.
+ *
+ * The window geometry is double buffered, and will be applied at the
+ * time wl_surface.commit of the corresponding wl_surface is called.
+ *
+ * When maintaining a position, the compositor should treat the (x, y)
+ * coordinate of the window geometry as the top left corner of the window.
+ * A client changing the (x, y) window geometry coordinate should in
+ * general not alter the position of the window.
+ *
+ * Once the window geometry of the surface is set, it is not possible to
+ * unset it, and it will remain the same until set_window_geometry is
+ * called again, even if a new subsurface or buffer is attached.
+ *
+ * If never set, the value is the full bounds of the surface,
+ * including any subsurfaces. This updates dynamically on every
+ * commit. This unset is meant for extremely simple clients.
+ *
+ * The arguments are given in the surface-local coordinate space of
+ * the wl_surface associated with this xdg_surface.
+ *
+ * The width and height must be greater than zero. Setting an invalid size
+ * will raise an error. When applied, the effective window geometry will be
+ * the set window geometry clamped to the bounding rectangle of the
+ * combined geometry of the surface of the xdg_surface and the associated
+ * subsurfaces.
+ */
+static inline void
+xdg_surface_set_window_geometry(struct xdg_surface *xdg_surface, int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_SET_WINDOW_GEOMETRY, x, y, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_surface
+ *
+ * When a configure event is received, if a client commits the
+ * surface in response to the configure event, then the client
+ * must make an ack_configure request sometime before the commit
+ * request, passing along the serial of the configure event.
+ *
+ * For instance, for toplevel surfaces the compositor might use this
+ * information to move a surface to the top left only when the client has
+ * drawn itself for the maximized or fullscreen state.
+ *
+ * If the client receives multiple configure events before it
+ * can respond to one, it only has to ack the last configure event.
+ *
+ * A client is not required to commit immediately after sending
+ * an ack_configure request - it may even ack_configure several times
+ * before its next surface commit.
+ *
+ * A client may send multiple ack_configure requests before committing, but
+ * only the last request sent before a commit indicates which configure
+ * event the client really is responding to.
+ */
+static inline void
+xdg_surface_ack_configure(struct xdg_surface *xdg_surface, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_surface,
+			 XDG_SURFACE_ACK_CONFIGURE, serial);
+}
+
+#ifndef XDG_TOPLEVEL_RESIZE_EDGE_ENUM
+#define XDG_TOPLEVEL_RESIZE_EDGE_ENUM
+/**
+ * @ingroup iface_xdg_toplevel
+ * edge values for resizing
+ *
+ * These values are used to indicate which edge of a surface
+ * is being dragged in a resize operation.
+ */
+enum xdg_toplevel_resize_edge {
+	XDG_TOPLEVEL_RESIZE_EDGE_NONE = 0,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP = 1,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM = 2,
+	XDG_TOPLEVEL_RESIZE_EDGE_LEFT = 4,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT = 5,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT = 6,
+	XDG_TOPLEVEL_RESIZE_EDGE_RIGHT = 8,
+	XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT = 9,
+	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT = 10,
+};
+#endif /* XDG_TOPLEVEL_RESIZE_EDGE_ENUM */
+
+#ifndef XDG_TOPLEVEL_STATE_ENUM
+#define XDG_TOPLEVEL_STATE_ENUM
+/**
+ * @ingroup iface_xdg_toplevel
+ * the surface is tiled
+ *
+ * The window is currently in a tiled layout and the bottom edge is
+ * considered to be adjacent to another part of the tiling grid.
+ */
+enum xdg_toplevel_state {
+	/**
+	 * the surface is maximized
+	 */
+	XDG_TOPLEVEL_STATE_MAXIMIZED = 1,
+	/**
+	 * the surface is fullscreen
+	 */
+	XDG_TOPLEVEL_STATE_FULLSCREEN = 2,
+	/**
+	 * the surface is being resized
+	 */
+	XDG_TOPLEVEL_STATE_RESIZING = 3,
+	/**
+	 * the surface is now activated
+	 */
+	XDG_TOPLEVEL_STATE_ACTIVATED = 4,
+	/**
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_LEFT = 5,
+	/**
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_RIGHT = 6,
+	/**
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_TOP = 7,
+	/**
+	 * @since 2
+	 */
+	XDG_TOPLEVEL_STATE_TILED_BOTTOM = 8,
+};
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_LEFT_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_RIGHT_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_TOP_SINCE_VERSION 2
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_STATE_TILED_BOTTOM_SINCE_VERSION 2
+#endif /* XDG_TOPLEVEL_STATE_ENUM */
+
+/**
+ * @ingroup iface_xdg_toplevel
+ * @struct xdg_toplevel_listener
+ */
+struct xdg_toplevel_listener {
+	/**
+	 * suggest a surface change
+	 *
+	 * This configure event asks the client to resize its toplevel
+	 * surface or to change its state. The configured state should not
+	 * be applied immediately. See xdg_surface.configure for details.
+	 *
+	 * The width and height arguments specify a hint to the window
+	 * about how its surface should be resized in window geometry
+	 * coordinates. See set_window_geometry.
+	 *
+	 * If the width or height arguments are zero, it means the client
+	 * should decide its own window dimension. This may happen when the
+	 * compositor needs to configure the state of the surface but
+	 * doesn't have any information about any previous or expected
+	 * dimension.
+	 *
+	 * The states listed in the event specify how the width/height
+	 * arguments should be interpreted, and possibly how it should be
+	 * drawn.
+	 *
+	 * Clients must send an ack_configure in response to this event.
+	 * See xdg_surface.configure and xdg_surface.ack_configure for
+	 * details.
+	 */
+	void (*configure)(void *data,
+			  struct xdg_toplevel *xdg_toplevel,
+			  int32_t width,
+			  int32_t height,
+			  struct wl_array *states);
+	/**
+	 * surface wants to be closed
+	 *
+	 * The close event is sent by the compositor when the user wants
+	 * the surface to be closed. This should be equivalent to the user
+	 * clicking the close button in client-side decorations, if your
+	 * application has any.
+	 *
+	 * This is only a request that the user intends to close the
+	 * window. The client may choose to ignore this request, or show a
+	 * dialog to ask the user to save their data, etc.
+	 */
+	void (*close)(void *data,
+		      struct xdg_toplevel *xdg_toplevel);
+};
+
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+static inline int
+xdg_toplevel_add_listener(struct xdg_toplevel *xdg_toplevel,
+			  const struct xdg_toplevel_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_toplevel,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_TOPLEVEL_DESTROY 0
+#define XDG_TOPLEVEL_SET_PARENT 1
+#define XDG_TOPLEVEL_SET_TITLE 2
+#define XDG_TOPLEVEL_SET_APP_ID 3
+#define XDG_TOPLEVEL_SHOW_WINDOW_MENU 4
+#define XDG_TOPLEVEL_MOVE 5
+#define XDG_TOPLEVEL_RESIZE 6
+#define XDG_TOPLEVEL_SET_MAX_SIZE 7
+#define XDG_TOPLEVEL_SET_MIN_SIZE 8
+#define XDG_TOPLEVEL_SET_MAXIMIZED 9
+#define XDG_TOPLEVEL_UNSET_MAXIMIZED 10
+#define XDG_TOPLEVEL_SET_FULLSCREEN 11
+#define XDG_TOPLEVEL_UNSET_FULLSCREEN 12
+#define XDG_TOPLEVEL_SET_MINIMIZED 13
+
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_CLOSE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_PARENT_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_TITLE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_APP_ID_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SHOW_WINDOW_MENU_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_MOVE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_RESIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MAX_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MIN_SIZE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_UNSET_MAXIMIZED_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_UNSET_FULLSCREEN_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_toplevel
+ */
+#define XDG_TOPLEVEL_SET_MINIMIZED_SINCE_VERSION 1
+
+/** @ingroup iface_xdg_toplevel */
+static inline void
+xdg_toplevel_set_user_data(struct xdg_toplevel *xdg_toplevel, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_toplevel, user_data);
+}
+
+/** @ingroup iface_xdg_toplevel */
+static inline void *
+xdg_toplevel_get_user_data(struct xdg_toplevel *xdg_toplevel)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_toplevel);
+}
+
+static inline uint32_t
+xdg_toplevel_get_version(struct xdg_toplevel *xdg_toplevel)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_toplevel);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * This request destroys the role surface and unmaps the surface;
+ * see "Unmapping" behavior in interface section for details.
+ */
+static inline void
+xdg_toplevel_destroy(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) xdg_toplevel);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set the "parent" of this surface. This surface should be stacked
+ * above the parent surface and all other ancestor surfaces.
+ *
+ * Parent windows should be set on dialogs, toolboxes, or other
+ * "auxiliary" surfaces, so that the parent is raised when the dialog
+ * is raised.
+ *
+ * Setting a null parent for a child window removes any parent-child
+ * relationship for the child. Setting a null parent for a window which
+ * currently has no parent is a no-op.
+ *
+ * If the parent is unmapped then its children are managed as
+ * though the parent of the now-unmapped parent has become the
+ * parent of this surface. If no parent exists for the now-unmapped
+ * parent then the children are managed as though they have no
+ * parent surface.
+ */
+static inline void
+xdg_toplevel_set_parent(struct xdg_toplevel *xdg_toplevel, struct xdg_toplevel *parent)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_PARENT, parent);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set a short title for the surface.
+ *
+ * This string may be used to identify the surface in a task bar,
+ * window list, or other user interface elements provided by the
+ * compositor.
+ *
+ * The string must be encoded in UTF-8.
+ */
+static inline void
+xdg_toplevel_set_title(struct xdg_toplevel *xdg_toplevel, const char *title)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_TITLE, title);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set an application identifier for the surface.
+ *
+ * The app ID identifies the general class of applications to which
+ * the surface belongs. The compositor can use this to group multiple
+ * surfaces together, or to determine how to launch a new application.
+ *
+ * For D-Bus activatable applications, the app ID is used as the D-Bus
+ * service name.
+ *
+ * The compositor shell will try to group application surfaces together
+ * by their app ID. As a best practice, it is suggested to select app
+ * ID's that match the basename of the application's .desktop file.
+ * For example, "org.freedesktop.FooViewer" where the .desktop file is
+ * "org.freedesktop.FooViewer.desktop".
+ *
+ * Like other properties, a set_app_id request can be sent after the
+ * xdg_toplevel has been mapped to update the property.
+ *
+ * See the desktop-entry specification [0] for more details on
+ * application identifiers and how they relate to well-known D-Bus
+ * names and .desktop files.
+ *
+ * [0] http://standards.freedesktop.org/desktop-entry-spec/
+ */
+static inline void
+xdg_toplevel_set_app_id(struct xdg_toplevel *xdg_toplevel, const char *app_id)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_APP_ID, app_id);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Clients implementing client-side decorations might want to show
+ * a context menu when right-clicking on the decorations, giving the
+ * user a menu that they can use to maximize or minimize the window.
+ *
+ * This request asks the compositor to pop up such a window menu at
+ * the given position, relative to the local surface coordinates of
+ * the parent surface. There are no guarantees as to what menu items
+ * the window menu contains.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event.
+ */
+static inline void
+xdg_toplevel_show_window_menu(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SHOW_WINDOW_MENU, seat, serial, x, y);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Start an interactive, user-driven move of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive move (touch,
+ * pointer, etc).
+ *
+ * The server may ignore move requests depending on the state of
+ * the surface (e.g. fullscreen or maximized), or if the passed serial
+ * is no longer valid.
+ *
+ * If triggered, the surface will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the move. It is up to the
+ * compositor to visually indicate that the move is taking place, such as
+ * updating a pointer cursor, during the move. There is no guarantee
+ * that the device focus will return when the move is completed.
+ */
+static inline void
+xdg_toplevel_move(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_MOVE, seat, serial);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Start a user-driven, interactive resize of the surface.
+ *
+ * This request must be used in response to some sort of user action
+ * like a button press, key press, or touch down event. The passed
+ * serial is used to determine the type of interactive resize (touch,
+ * pointer, etc).
+ *
+ * The server may ignore resize requests depending on the state of
+ * the surface (e.g. fullscreen or maximized).
+ *
+ * If triggered, the client will receive configure events with the
+ * "resize" state enum value and the expected sizes. See the "resize"
+ * enum value for more details about what is required. The client
+ * must also acknowledge configure events using "ack_configure". After
+ * the resize is completed, the client will receive another "configure"
+ * event without the resize state.
+ *
+ * If triggered, the surface also will lose the focus of the device
+ * (wl_pointer, wl_touch, etc) used for the resize. It is up to the
+ * compositor to visually indicate that the resize is taking place,
+ * such as updating a pointer cursor, during the resize. There is no
+ * guarantee that the device focus will return when the resize is
+ * completed.
+ *
+ * The edges parameter specifies how the surface should be resized,
+ * and is one of the values of the resize_edge enum. The compositor
+ * may use this information to update the surface position for
+ * example when dragging the top left corner. The compositor may also
+ * use this information to adapt its behavior, e.g. choose an
+ * appropriate cursor image.
+ */
+static inline void
+xdg_toplevel_resize(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, uint32_t edges)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_RESIZE, seat, serial, edges);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set a maximum size for the window.
+ *
+ * The client can specify a maximum size so that the compositor does
+ * not try to configure the window beyond this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the maximum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a larger size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected maximum size in the given dimension.
+ * As a result, a client wishing to reset the maximum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a maximum size to be smaller than the minimum size of
+ * a surface is illegal and will result in a protocol error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * protocol error.
+ */
+static inline void
+xdg_toplevel_set_max_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_MAX_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Set a minimum size for the window.
+ *
+ * The client can specify a minimum size so that the compositor does
+ * not try to configure the window below this size.
+ *
+ * The width and height arguments are in window geometry coordinates.
+ * See xdg_surface.set_window_geometry.
+ *
+ * Values set in this way are double-buffered. They will get applied
+ * on the next commit.
+ *
+ * The compositor can use this information to allow or disallow
+ * different states like maximize or fullscreen and draw accurate
+ * animations.
+ *
+ * Similarly, a tiling window manager may use this information to
+ * place and resize client windows in a more effective way.
+ *
+ * The client should not rely on the compositor to obey the minimum
+ * size. The compositor may decide to ignore the values set by the
+ * client and request a smaller size.
+ *
+ * If never set, or a value of zero in the request, means that the
+ * client has no expected minimum size in the given dimension.
+ * As a result, a client wishing to reset the minimum size
+ * to an unspecified state can use zero for width and height in the
+ * request.
+ *
+ * Requesting a minimum size to be larger than the maximum size of
+ * a surface is illegal and will result in a protocol error.
+ *
+ * The width and height must be greater than or equal to zero. Using
+ * strictly negative values for width and height will result in a
+ * protocol error.
+ */
+static inline void
+xdg_toplevel_set_min_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_MIN_SIZE, width, height);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Maximize the surface.
+ *
+ * After requesting that the surface should be maximized, the compositor
+ * will respond by emitting a configure event. Whether this configure
+ * actually sets the window maximized is subject to compositor policies.
+ * The client must then update its content, drawing in the configured
+ * state. The client must also acknowledge the configure when committing
+ * the new content (see ack_configure).
+ *
+ * It is up to the compositor to decide how and where to maximize the
+ * surface, for example which output and what region of the screen should
+ * be used.
+ *
+ * If the surface was already maximized, the compositor will still emit
+ * a configure event with the "maximized" state.
+ *
+ * If the surface is in a fullscreen state, this request has no direct
+ * effect. It may alter the state the surface is returned to when
+ * unmaximized unless overridden by the compositor.
+ */
+static inline void
+xdg_toplevel_set_maximized(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_MAXIMIZED);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Unmaximize the surface.
+ *
+ * After requesting that the surface should be unmaximized, the compositor
+ * will respond by emitting a configure event. Whether this actually
+ * un-maximizes the window is subject to compositor policies.
+ * If available and applicable, the compositor will include the window
+ * geometry dimensions the window had prior to being maximized in the
+ * configure event. The client must then update its content, drawing it in
+ * the configured state. The client must also acknowledge the configure
+ * when committing the new content (see ack_configure).
+ *
+ * It is up to the compositor to position the surface after it was
+ * unmaximized; usually the position the surface had before maximizing, if
+ * applicable.
+ *
+ * If the surface was already not maximized, the compositor will still
+ * emit a configure event without the "maximized" state.
+ *
+ * If the surface is in a fullscreen state, this request has no direct
+ * effect. It may alter the state the surface is returned to when
+ * unmaximized unless overridden by the compositor.
+ */
+static inline void
+xdg_toplevel_unset_maximized(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_UNSET_MAXIMIZED);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Make the surface fullscreen.
+ *
+ * After requesting that the surface should be fullscreened, the
+ * compositor will respond by emitting a configure event. Whether the
+ * client is actually put into a fullscreen state is subject to compositor
+ * policies. The client must also acknowledge the configure when
+ * committing the new content (see ack_configure).
+ *
+ * The output passed by the request indicates the client's preference as
+ * to which display it should be set fullscreen on. If this value is NULL,
+ * it's up to the compositor to choose which display will be used to map
+ * this surface.
+ *
+ * If the surface doesn't cover the whole output, the compositor will
+ * position the surface in the center of the output and compensate with
+ * with border fill covering the rest of the output. The content of the
+ * border fill is undefined, but should be assumed to be in some way that
+ * attempts to blend into the surrounding area (e.g. solid black).
+ *
+ * If the fullscreened surface is not opaque, the compositor must make
+ * sure that other screen content not part of the same surface tree (made
+ * up of subsurfaces, popups or similarly coupled surfaces) are not
+ * visible below the fullscreened surface.
+ */
+static inline void
+xdg_toplevel_set_fullscreen(struct xdg_toplevel *xdg_toplevel, struct wl_output *output)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_FULLSCREEN, output);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Make the surface no longer fullscreen.
+ *
+ * After requesting that the surface should be unfullscreened, the
+ * compositor will respond by emitting a configure event.
+ * Whether this actually removes the fullscreen state of the client is
+ * subject to compositor policies.
+ *
+ * Making a surface unfullscreen sets states for the surface based on the following:
+ * * the state(s) it may have had before becoming fullscreen
+ * * any state(s) decided by the compositor
+ * * any state(s) requested by the client while the surface was fullscreen
+ *
+ * The compositor may include the previous window geometry dimensions in
+ * the configure event, if applicable.
+ *
+ * The client must also acknowledge the configure when committing the new
+ * content (see ack_configure).
+ */
+static inline void
+xdg_toplevel_unset_fullscreen(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_UNSET_FULLSCREEN);
+}
+
+/**
+ * @ingroup iface_xdg_toplevel
+ *
+ * Request that the compositor minimize your surface. There is no
+ * way to know if the surface is currently minimized, nor is there
+ * any way to unset minimization on this surface.
+ *
+ * If you are looking to throttle redrawing when minimized, please
+ * instead use the wl_surface.frame event for this, as this will
+ * also work with live previews on windows in Alt-Tab, Expose or
+ * similar compositor features.
+ */
+static inline void
+xdg_toplevel_set_minimized(struct xdg_toplevel *xdg_toplevel)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_toplevel,
+			 XDG_TOPLEVEL_SET_MINIMIZED);
+}
+
+#ifndef XDG_POPUP_ERROR_ENUM
+#define XDG_POPUP_ERROR_ENUM
+enum xdg_popup_error {
+	/**
+	 * tried to grab after being mapped
+	 */
+	XDG_POPUP_ERROR_INVALID_GRAB = 0,
+};
+#endif /* XDG_POPUP_ERROR_ENUM */
+
+/**
+ * @ingroup iface_xdg_popup
+ * @struct xdg_popup_listener
+ */
+struct xdg_popup_listener {
+	/**
+	 * configure the popup surface
+	 *
+	 * This event asks the popup surface to configure itself given
+	 * the configuration. The configured state should not be applied
+	 * immediately. See xdg_surface.configure for details.
+	 *
+	 * The x and y arguments represent the position the popup was
+	 * placed at given the xdg_positioner rule, relative to the upper
+	 * left corner of the window geometry of the parent surface.
+	 * @param x x position relative to parent surface window geometry
+	 * @param y y position relative to parent surface window geometry
+	 * @param width window geometry width
+	 * @param height window geometry height
+	 */
+	void (*configure)(void *data,
+			  struct xdg_popup *xdg_popup,
+			  int32_t x,
+			  int32_t y,
+			  int32_t width,
+			  int32_t height);
+	/**
+	 * popup interaction is done
+	 *
+	 * The popup_done event is sent out when a popup is dismissed by
+	 * the compositor. The client should destroy the xdg_popup object
+	 * at this point.
+	 */
+	void (*popup_done)(void *data,
+			   struct xdg_popup *xdg_popup);
+};
+
+/**
+ * @ingroup iface_xdg_popup
+ */
+static inline int
+xdg_popup_add_listener(struct xdg_popup *xdg_popup,
+		       const struct xdg_popup_listener *listener, void *data)
+{
+	return wl_proxy_add_listener((struct wl_proxy *) xdg_popup,
+				     (void (**)(void)) listener, data);
+}
+
+#define XDG_POPUP_DESTROY 0
+#define XDG_POPUP_GRAB 1
+
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_CONFIGURE_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_POPUP_DONE_SINCE_VERSION 1
+
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_DESTROY_SINCE_VERSION 1
+/**
+ * @ingroup iface_xdg_popup
+ */
+#define XDG_POPUP_GRAB_SINCE_VERSION 1
+
+/** @ingroup iface_xdg_popup */
+static inline void
+xdg_popup_set_user_data(struct xdg_popup *xdg_popup, void *user_data)
+{
+	wl_proxy_set_user_data((struct wl_proxy *) xdg_popup, user_data);
+}
+
+/** @ingroup iface_xdg_popup */
+static inline void *
+xdg_popup_get_user_data(struct xdg_popup *xdg_popup)
+{
+	return wl_proxy_get_user_data((struct wl_proxy *) xdg_popup);
+}
+
+static inline uint32_t
+xdg_popup_get_version(struct xdg_popup *xdg_popup)
+{
+	return wl_proxy_get_version((struct wl_proxy *) xdg_popup);
+}
+
+/**
+ * @ingroup iface_xdg_popup
+ *
+ * This destroys the popup. Explicitly destroying the xdg_popup
+ * object will also dismiss the popup, and unmap the surface.
+ *
+ * If this xdg_popup is not the "topmost" popup, a protocol error
+ * will be sent.
+ */
+static inline void
+xdg_popup_destroy(struct xdg_popup *xdg_popup)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_popup,
+			 XDG_POPUP_DESTROY);
+
+	wl_proxy_destroy((struct wl_proxy *) xdg_popup);
+}
+
+/**
+ * @ingroup iface_xdg_popup
+ *
+ * This request makes the created popup take an explicit grab. An explicit
+ * grab will be dismissed when the user dismisses the popup, or when the
+ * client destroys the xdg_popup. This can be done by the user clicking
+ * outside the surface, using the keyboard, or even locking the screen
+ * through closing the lid or a timeout.
+ *
+ * If the compositor denies the grab, the popup will be immediately
+ * dismissed.
+ *
+ * This request must be used in response to some sort of user action like a
+ * button press, key press, or touch down event. The serial number of the
+ * event should be passed as 'serial'.
+ *
+ * The parent of a grabbing popup must either be an xdg_toplevel surface or
+ * another xdg_popup with an explicit grab. If the parent is another
+ * xdg_popup it means that the popups are nested, with this popup now being
+ * the topmost popup.
+ *
+ * Nested popups must be destroyed in the reverse order they were created
+ * in, e.g. the only popup you are allowed to destroy at all times is the
+ * topmost one.
+ *
+ * When compositors choose to dismiss a popup, they may dismiss every
+ * nested grabbing popup as well. When a compositor dismisses popups, it
+ * will follow the same dismissing order as required from the client.
+ *
+ * The parent of a grabbing popup must either be another xdg_popup with an
+ * active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
+ * explicit grabs already taken.
+ *
+ * If the topmost grabbing popup is destroyed, the grab will be returned to
+ * the parent of the popup, if that parent previously had an explicit grab.
+ *
+ * If the parent is a grabbing popup which has already been dismissed, this
+ * popup will be immediately dismissed. If the parent is a popup that did
+ * not take an explicit grab, an error will be raised.
+ *
+ * During a popup grab, the client owning the grab will receive pointer
+ * and touch events for all their surfaces as normal (similar to an
+ * "owner-events" grab in X11 parlance), while the top most grabbing popup
+ * will always have keyboard focus.
+ */
+static inline void
+xdg_popup_grab(struct xdg_popup *xdg_popup, struct wl_seat *seat, uint32_t serial)
+{
+	wl_proxy_marshal((struct wl_proxy *) xdg_popup,
+			 XDG_POPUP_GRAB, seat, serial);
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/plugins/shellintegration/xdg-shell/wayland-xdg-shell-protocol.c b/src/plugins/shellintegration/xdg-shell/wayland-xdg-shell-protocol.c
new file mode 100644
index 0000000000000000000000000000000000000000..d42a1254c86bfcff555b59b87c2c9c64fa47cac4
--- /dev/null
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/wayland-xdg-shell-protocol.c
@@ -0,0 +1,164 @@
+/* Generated by wayland-scanner 1.19.0 */
+
+/*
+ * Copyright © 2008-2013 Kristian Høgsberg
+ * Copyright © 2013      Rafael Antognolli
+ * Copyright © 2013      Jasper St. Pierre
+ * Copyright © 2010-2013 Intel Corporation
+ * Copyright © 2015-2017 Samsung Electronics Co., Ltd
+ * Copyright © 2015-2017 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "wayland-util.h"
+
+extern const struct wl_interface wl_output_interface;
+extern const struct wl_interface wl_seat_interface;
+extern const struct wl_interface wl_surface_interface;
+extern const struct wl_interface xdg_popup_interface;
+extern const struct wl_interface xdg_positioner_interface;
+extern const struct wl_interface xdg_surface_interface;
+extern const struct wl_interface xdg_toplevel_interface;
+
+static const struct wl_interface *xdg_shell_types[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	&xdg_positioner_interface,
+	&xdg_surface_interface,
+	&wl_surface_interface,
+	&xdg_toplevel_interface,
+	&xdg_popup_interface,
+	&xdg_surface_interface,
+	&xdg_positioner_interface,
+	&xdg_toplevel_interface,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	NULL,
+	&wl_seat_interface,
+	NULL,
+	&wl_seat_interface,
+	NULL,
+	NULL,
+	&wl_output_interface,
+	&wl_seat_interface,
+	NULL,
+};
+
+static const struct wl_message xdg_wm_base_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "create_positioner", "n", xdg_shell_types + 4 },
+	{ "get_xdg_surface", "no", xdg_shell_types + 5 },
+	{ "pong", "u", xdg_shell_types + 0 },
+};
+
+static const struct wl_message xdg_wm_base_events[] = {
+	{ "ping", "u", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_wm_base_interface = {
+	"xdg_wm_base", 2,
+	4, xdg_wm_base_requests,
+	1, xdg_wm_base_events,
+};
+
+static const struct wl_message xdg_positioner_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "set_size", "ii", xdg_shell_types + 0 },
+	{ "set_anchor_rect", "iiii", xdg_shell_types + 0 },
+	{ "set_anchor", "u", xdg_shell_types + 0 },
+	{ "set_gravity", "u", xdg_shell_types + 0 },
+	{ "set_constraint_adjustment", "u", xdg_shell_types + 0 },
+	{ "set_offset", "ii", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_positioner_interface = {
+	"xdg_positioner", 2,
+	7, xdg_positioner_requests,
+	0, NULL,
+};
+
+static const struct wl_message xdg_surface_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "get_toplevel", "n", xdg_shell_types + 7 },
+	{ "get_popup", "n?oo", xdg_shell_types + 8 },
+	{ "set_window_geometry", "iiii", xdg_shell_types + 0 },
+	{ "ack_configure", "u", xdg_shell_types + 0 },
+};
+
+static const struct wl_message xdg_surface_events[] = {
+	{ "configure", "u", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_surface_interface = {
+	"xdg_surface", 2,
+	5, xdg_surface_requests,
+	1, xdg_surface_events,
+};
+
+static const struct wl_message xdg_toplevel_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "set_parent", "?o", xdg_shell_types + 11 },
+	{ "set_title", "s", xdg_shell_types + 0 },
+	{ "set_app_id", "s", xdg_shell_types + 0 },
+	{ "show_window_menu", "ouii", xdg_shell_types + 12 },
+	{ "move", "ou", xdg_shell_types + 16 },
+	{ "resize", "ouu", xdg_shell_types + 18 },
+	{ "set_max_size", "ii", xdg_shell_types + 0 },
+	{ "set_min_size", "ii", xdg_shell_types + 0 },
+	{ "set_maximized", "", xdg_shell_types + 0 },
+	{ "unset_maximized", "", xdg_shell_types + 0 },
+	{ "set_fullscreen", "?o", xdg_shell_types + 21 },
+	{ "unset_fullscreen", "", xdg_shell_types + 0 },
+	{ "set_minimized", "", xdg_shell_types + 0 },
+};
+
+static const struct wl_message xdg_toplevel_events[] = {
+	{ "configure", "iia", xdg_shell_types + 0 },
+	{ "close", "", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_toplevel_interface = {
+	"xdg_toplevel", 2,
+	14, xdg_toplevel_requests,
+	2, xdg_toplevel_events,
+};
+
+static const struct wl_message xdg_popup_requests[] = {
+	{ "destroy", "", xdg_shell_types + 0 },
+	{ "grab", "ou", xdg_shell_types + 22 },
+};
+
+static const struct wl_message xdg_popup_events[] = {
+	{ "configure", "iiii", xdg_shell_types + 0 },
+	{ "popup_done", "", xdg_shell_types + 0 },
+};
+
+WL_EXPORT const struct wl_interface xdg_popup_interface = {
+	"xdg_popup", 2,
+	2, xdg_popup_requests,
+	2, xdg_popup_events,
+};
+
diff --git a/src/plugins/shellintegration/xdg-shell/xdg-shell.pro b/src/plugins/shellintegration/xdg-shell/xdg-shell.pro
index 261715845c8e358006dee59d25421dfa5838e050..02f5fad94a22cf9b8903fb7a6e19b1b322c0e410 100644
--- a/qtwayland/src/plugins/shellintegration/xdg-shell/xdg-shell.pro
+++ a/qtwayland/src/plugins/shellintegration/xdg-shell/xdg-shell.pro
@@ -1,13 +1,16 @@
 QT += gui-private waylandclient-private
-CONFIG += wayland-scanner
 
 QMAKE_USE += wayland-client
 qtConfig(xkbcommon): \
     QMAKE_USE_PRIVATE += xkbcommon
 
-WAYLANDCLIENTSOURCES += \
-    ../../../3rdparty/protocol/xdg-decoration-unstable-v1.xml \
-    ../../../3rdparty/protocol/xdg-shell.xml
+HEADERS += \
+    wayland-xdg-decoration-unstable-v1-client-protocol.h \
+    wayland-xdg-shell-client-protocol.h
+
+SOURCES += \
+    wayland-xdg-decoration-unstable-v1-protocol.c \
+    wayland-xdg-shell-protocol.c
 
 HEADERS += \
     qwaylandxdgdecorationv1_p.h \
@@ -20,6 +23,14 @@ SOURCES += \
     qwaylandxdgshell.cpp \
     qwaylandxdgshellintegration.cpp \
 
+HEADERS += \
+    qwayland-xdg-decoration-unstable-v1.h \
+    qwayland-xdg-shell.h
+
+SOURCES += \
+    qwayland-xdg-decoration-unstable-v1.cpp \
+    qwayland-xdg-shell.cpp
+
 OTHER_FILES += \
     xdg-shell.json
 
-- 
2.39.2

