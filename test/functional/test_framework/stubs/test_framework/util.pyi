from . import coverage as coverage
from .authproxy import AuthServiceProxy as AuthServiceProxy, JSONRPCException as JSONRPCException
from typing import Any, Optional

logger: Any

def assert_approx(v: Any, vexp: Any, vspan: float = ...) -> None: ...
def assert_fee_amount(fee: Any, tx_size: Any, fee_per_kB: Any) -> None: ...
def assert_equal(thing1: Any, thing2: Any, *args: Any) -> None: ...
def assert_greater_than(thing1: Any, thing2: Any) -> None: ...
def assert_greater_than_or_equal(thing1: Any, thing2: Any) -> None: ...
def assert_raises(exc: Any, fun: Any, *args: Any, **kwds: Any) -> None: ...
def assert_raises_message(exc: Any, message: Any, fun: Any, *args: Any, **kwds: Any) -> None: ...
def assert_raises_process_error(returncode: Any, output: Any, fun: Any, *args: Any, **kwds: Any) -> None: ...
def assert_raises_rpc_error(code: Any, message: Any, fun: Any, *args: Any, **kwds: Any) -> None: ...
def try_rpc(code: Any, message: Any, fun: Any, *args: Any, **kwds: Any): ...
def assert_is_hex_string(string: Any) -> None: ...
def assert_is_hash_string(string: Any, length: int = ...) -> None: ...
def assert_array_result(object_array: Any, to_match: Any, expected: Any, should_not_find: bool = ...) -> None: ...
def check_json_precision() -> None: ...
def EncodeDecimal(o: Any): ...
def count_bytes(hex_string: Any): ...
def hex_str_to_bytes(hex_str: Any): ...
def str_to_b64str(string: Any): ...
def satoshi_round(amount: Any): ...
def wait_until(predicate: Any, *, attempts: Any = ..., timeout: Any = ..., lock: Optional[Any] = ..., timeout_factor: float = ...) -> None: ...

MAX_NODES: int
PORT_MIN: Any
PORT_RANGE: int

class PortSeed:
    n: Any = ...

def get_rpc_proxy(url: Any, node_number: Any, *, timeout: Optional[Any] = ..., coveragedir: Optional[Any] = ...): ...
def p2p_port(n: Any): ...
def rpc_port(n: Any): ...
def rpc_url(datadir: Any, i: Any, chain: Any, rpchost: Any): ...
def initialize_datadir(dirname: Any, n: Any, chain: Any): ...
def get_datadir_path(dirname: Any, n: Any): ...
def append_config(datadir: Any, options: Any) -> None: ...
def get_auth_cookie(datadir: Any, chain: Any): ...
def delete_cookie_file(datadir: Any, chain: Any) -> None: ...
def softfork_active(node: Any, key: Any): ...
def set_node_times(nodes: Any, t: Any) -> None: ...
def disconnect_nodes(from_connection: Any, node_num: Any): ...
def connect_nodes(from_connection: Any, node_num: Any): ...
def find_output(node: Any, txid: Any, amount: Any, *, blockhash: Optional[Any] = ...): ...
def gather_inputs(from_node: Any, amount_needed: Any, confirmations_required: int = ...): ...
def make_change(from_node: Any, amount_in: Any, amount_out: Any, fee: Any): ...
def random_transaction(nodes: Any, amount: Any, min_fee: Any, fee_increment: Any, fee_variants: Any): ...
def create_confirmed_utxos(fee: Any, node: Any, count: Any): ...
def gen_return_txouts(): ...
def create_lots_of_big_transactions(node: Any, txouts: Any, utxos: Any, num: Any, fee: Any): ...
def mine_large_block(node: Any, utxos: Optional[Any] = ...) -> None: ...
def find_vout_for_address(node: Any, txid: Any, addr: Any): ...
