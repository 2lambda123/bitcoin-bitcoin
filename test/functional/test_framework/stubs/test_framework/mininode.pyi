import asyncio
import threading
from test_framework.messages import CBlockHeader as CBlockHeader, MAX_HEADERS_RESULTS as MAX_HEADERS_RESULTS, MIN_VERSION_SUPPORTED as MIN_VERSION_SUPPORTED, MSG_BLOCK as MSG_BLOCK, MSG_TX as MSG_TX, MSG_TYPE_MASK as MSG_TYPE_MASK, NODE_NETWORK as NODE_NETWORK, NODE_WITNESS as NODE_WITNESS, msg_addr as msg_addr, msg_block as msg_block, msg_blocktxn as msg_blocktxn, msg_cfcheckpt as msg_cfcheckpt, msg_cfheaders as msg_cfheaders, msg_cfilter as msg_cfilter, msg_cmpctblock as msg_cmpctblock, msg_feefilter as msg_feefilter, msg_filteradd as msg_filteradd, msg_filterclear as msg_filterclear, msg_filterload as msg_filterload, msg_getaddr as msg_getaddr, msg_getblocks as msg_getblocks, msg_getblocktxn as msg_getblocktxn, msg_getdata as msg_getdata, msg_getheaders as msg_getheaders, msg_headers as msg_headers, msg_inv as msg_inv, msg_mempool as msg_mempool, msg_merkleblock as msg_merkleblock, msg_notfound as msg_notfound, msg_ping as msg_ping, msg_pong as msg_pong, msg_sendcmpct as msg_sendcmpct, msg_sendheaders as msg_sendheaders, msg_tx as msg_tx, msg_verack as msg_verack, msg_version as msg_version, sha256 as sha256
from test_framework.util import wait_until as wait_until
from typing import Any, Optional

logger: Any
MESSAGEMAP: Any
MAGIC_BYTES: Any

class P2PConnection(asyncio.Protocol):
    def __init__(self) -> None: ...
    @property
    def is_connected(self): ...
    timeout_factor: Any = ...
    dstaddr: Any = ...
    dstport: Any = ...
    on_connection_send_msg: Any = ...
    recvbuf: bytes = ...
    magic_bytes: Any = ...
    def peer_connect(self, dstaddr: Any, dstport: Any, net: Any, timeout_factor: Any): ...
    def peer_disconnect(self): ...
    def connection_made(self, transport: Any) -> None: ...
    def connection_lost(self, exc: Any) -> None: ...
    def data_received(self, t: Any) -> None: ...
    def on_message(self, message: Any) -> None: ...
    def send_message(self, message: Any): ...
    def send_raw_message(self, raw_message_bytes: Any) -> None: ...
    def build_message(self, message: Any): ...

class P2PInterface(P2PConnection):
    message_count: Any = ...
    last_message: Any = ...
    ping_counter: int = ...
    nServices: int = ...
    def __init__(self) -> None: ...
    on_connection_send_msg: Any = ...
    def peer_connect(self, *args: Any, services: Any = ..., send_version: bool = ..., **kwargs: Any): ...
    def on_message(self, message: Any) -> None: ...
    def on_open(self) -> None: ...
    def on_close(self) -> None: ...
    def on_addr(self, message: Any) -> None: ...
    def on_block(self, message: Any) -> None: ...
    def on_blocktxn(self, message: Any) -> None: ...
    def on_cfcheckpt(self, message: Any) -> None: ...
    def on_cfheaders(self, message: Any) -> None: ...
    def on_cfilter(self, message: Any) -> None: ...
    def on_cmpctblock(self, message: Any) -> None: ...
    def on_feefilter(self, message: Any) -> None: ...
    def on_filteradd(self, message: Any) -> None: ...
    def on_filterclear(self, message: Any) -> None: ...
    def on_filterload(self, message: Any) -> None: ...
    def on_getaddr(self, message: Any) -> None: ...
    def on_getblocks(self, message: Any) -> None: ...
    def on_getblocktxn(self, message: Any) -> None: ...
    def on_getdata(self, message: Any) -> None: ...
    def on_getheaders(self, message: Any) -> None: ...
    def on_headers(self, message: Any) -> None: ...
    def on_mempool(self, message: Any) -> None: ...
    def on_merkleblock(self, message: Any) -> None: ...
    def on_notfound(self, message: Any) -> None: ...
    def on_pong(self, message: Any) -> None: ...
    def on_sendcmpct(self, message: Any) -> None: ...
    def on_sendheaders(self, message: Any) -> None: ...
    def on_tx(self, message: Any) -> None: ...
    def on_inv(self, message: Any) -> None: ...
    def on_ping(self, message: Any) -> None: ...
    def on_verack(self, message: Any) -> None: ...
    def on_version(self, message: Any) -> None: ...
    def wait_until(self, test_function: Any, timeout: int = ...) -> None: ...
    def wait_for_disconnect(self, timeout: int = ...): ...
    def wait_for_tx(self, txid: Any, timeout: int = ...): ...
    def wait_for_block(self, blockhash: Any, timeout: int = ...): ...
    def wait_for_header(self, blockhash: Any, timeout: int = ...): ...
    def wait_for_merkleblock(self, blockhash: Any, timeout: int = ...): ...
    def wait_for_getdata(self, hash_list: Any, timeout: int = ...): ...
    def wait_for_getheaders(self, timeout: int = ...): ...
    def wait_for_inv(self, expected_inv: Any, timeout: int = ...): ...
    def wait_for_verack(self, timeout: int = ...): ...
    def send_and_ping(self, message: Any, timeout: int = ...) -> None: ...
    def sync_with_ping(self, timeout: int = ...): ...

mininode_lock: Any

class NetworkThread(threading.Thread):
    network_event_loop: Any = ...
    def __init__(self) -> None: ...
    def run(self) -> None: ...
    def close(self, timeout: int = ...): ...

class P2PDataStore(P2PInterface):
    block_store: Any = ...
    last_block_hash: str = ...
    tx_store: Any = ...
    getdata_requests: Any = ...
    def __init__(self) -> None: ...
    def on_getdata(self, message: Any) -> None: ...
    def on_getheaders(self, message: Any) -> None: ...
    def send_blocks_and_test(self, blocks: Any, node: Any, *, success: bool = ..., force_send: bool = ..., reject_reason: Optional[Any] = ..., expect_disconnect: bool = ..., timeout: int = ...): ...
    def send_txs_and_test(self, txs: Any, node: Any, *, success: bool = ..., expect_disconnect: bool = ..., reject_reason: Optional[Any] = ...) -> None: ...

class P2PTxInvStore(P2PInterface):
    tx_invs_received: Any = ...
    def __init__(self) -> None: ...
    def on_inv(self, message: Any) -> None: ...
    def get_invs(self): ...
    def wait_for_broadcast(self, txns: Any, timeout: int = ...): ...
